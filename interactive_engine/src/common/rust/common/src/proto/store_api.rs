//
//! Copyright 2020 Alibaba Group Holding Limited.
//! 
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//! 
//!     http://www.apache.org/licenses/LICENSE-2.0
//! 
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct ScanRequest {
    // message fields
    pub snapshot_id: i64,
    pub type_id: i32,
    pub offset: i32,
    pub limit: i32,
    pub partition_id: i32,
    pub property_ids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ScanRequest {
    pub fn new() -> ScanRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // int32 type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // int32 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = v;
    }

    pub fn get_offset(&self) -> i32 {
        self.offset
    }

    // int32 limit = 4;

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    pub fn get_limit(&self) -> i32 {
        self.limit
    }

    // int32 partition_id = 5;

    pub fn clear_partition_id(&mut self) {
        self.partition_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_partition_id(&mut self, v: i32) {
        self.partition_id = v;
    }

    pub fn get_partition_id(&self) -> i32 {
        self.partition_id
    }

    // repeated int32 property_ids = 6;

    pub fn clear_property_ids(&mut self) {
        self.property_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_property_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.property_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.property_ids
    }

    // Take field
    pub fn take_property_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.property_ids, ::std::vec::Vec::new())
    }

    pub fn get_property_ids(&self) -> &[i32] {
        &self.property_ids
    }
}

impl ::protobuf::Message for ScanRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.property_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.partition_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.partition_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.property_ids {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(2, self.type_id)?;
        }
        if self.offset != 0 {
            os.write_int32(3, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int32(4, self.limit)?;
        }
        if self.partition_id != 0 {
            os.write_int32(5, self.partition_id)?;
        }
        for v in &self.property_ids {
            os.write_int32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanRequest {
        ScanRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &ScanRequest| { &m.snapshot_id },
                    |m: &mut ScanRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &ScanRequest| { &m.type_id },
                    |m: &mut ScanRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "offset",
                    |m: &ScanRequest| { &m.offset },
                    |m: &mut ScanRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "limit",
                    |m: &ScanRequest| { &m.limit },
                    |m: &mut ScanRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partition_id",
                    |m: &ScanRequest| { &m.partition_id },
                    |m: &mut ScanRequest| { &mut m.partition_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_ids",
                    |m: &ScanRequest| { &m.property_ids },
                    |m: &mut ScanRequest| { &mut m.property_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScanRequest>(
                    "ScanRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScanRequest {
        static mut instance: ::protobuf::lazy::Lazy<ScanRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanRequest,
        };
        unsafe {
            instance.get(ScanRequest::new)
        }
    }
}

impl ::protobuf::Clear for ScanRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_type_id();
        self.clear_offset();
        self.clear_limit();
        self.clear_partition_id();
        self.clear_property_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScanRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanEdgeRequest {
    // message fields
    pub snapshot_id: i64,
    pub type_id: i32,
    pub offset: i32,
    pub limit: i32,
    pub partition_id: i32,
    pub property_ids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ScanEdgeRequest {
    pub fn new() -> ScanEdgeRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // int32 type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // int32 offset = 3;

    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = v;
    }

    pub fn get_offset(&self) -> i32 {
        self.offset
    }

    // int32 limit = 4;

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    pub fn get_limit(&self) -> i32 {
        self.limit
    }

    // int32 partition_id = 5;

    pub fn clear_partition_id(&mut self) {
        self.partition_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_partition_id(&mut self, v: i32) {
        self.partition_id = v;
    }

    pub fn get_partition_id(&self) -> i32 {
        self.partition_id
    }

    // repeated int32 property_ids = 6;

    pub fn clear_property_ids(&mut self) {
        self.property_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_property_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.property_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.property_ids
    }

    // Take field
    pub fn take_property_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.property_ids, ::std::vec::Vec::new())
    }

    pub fn get_property_ids(&self) -> &[i32] {
        &self.property_ids
    }
}

impl ::protobuf::Message for ScanEdgeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.property_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(3, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.partition_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.partition_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.property_ids {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(2, self.type_id)?;
        }
        if self.offset != 0 {
            os.write_int32(3, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int32(4, self.limit)?;
        }
        if self.partition_id != 0 {
            os.write_int32(5, self.partition_id)?;
        }
        for v in &self.property_ids {
            os.write_int32(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanEdgeRequest {
        ScanEdgeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &ScanEdgeRequest| { &m.snapshot_id },
                    |m: &mut ScanEdgeRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &ScanEdgeRequest| { &m.type_id },
                    |m: &mut ScanEdgeRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "offset",
                    |m: &ScanEdgeRequest| { &m.offset },
                    |m: &mut ScanEdgeRequest| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "limit",
                    |m: &ScanEdgeRequest| { &m.limit },
                    |m: &mut ScanEdgeRequest| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partition_id",
                    |m: &ScanEdgeRequest| { &m.partition_id },
                    |m: &mut ScanEdgeRequest| { &mut m.partition_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_ids",
                    |m: &ScanEdgeRequest| { &m.property_ids },
                    |m: &mut ScanEdgeRequest| { &mut m.property_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScanEdgeRequest>(
                    "ScanEdgeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScanEdgeRequest {
        static mut instance: ::protobuf::lazy::Lazy<ScanEdgeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanEdgeRequest,
        };
        unsafe {
            instance.get(ScanEdgeRequest::new)
        }
    }
}

impl ::protobuf::Clear for ScanEdgeRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_type_id();
        self.clear_offset();
        self.clear_limit();
        self.clear_partition_id();
        self.clear_property_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScanEdgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanEdgeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOutEdgesRequest {
    // message fields
    pub snapshot_id: i64,
    pub src_id: i64,
    pub type_id: i32,
    pub property_ids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetOutEdgesRequest {
    pub fn new() -> GetOutEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // int64 src_id = 2;

    pub fn clear_src_id(&mut self) {
        self.src_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: i64) {
        self.src_id = v;
    }

    pub fn get_src_id(&self) -> i64 {
        self.src_id
    }

    // int32 type_id = 3;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // repeated int32 property_ids = 4;

    pub fn clear_property_ids(&mut self) {
        self.property_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_property_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.property_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.property_ids
    }

    // Take field
    pub fn take_property_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.property_ids, ::std::vec::Vec::new())
    }

    pub fn get_property_ids(&self) -> &[i32] {
        &self.property_ids
    }
}

impl ::protobuf::Message for GetOutEdgesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.src_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.property_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.property_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.src_id != 0 {
            os.write_int64(2, self.src_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(3, self.type_id)?;
        }
        for v in &self.property_ids {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOutEdgesRequest {
        GetOutEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetOutEdgesRequest| { &m.snapshot_id },
                    |m: &mut GetOutEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "src_id",
                    |m: &GetOutEdgesRequest| { &m.src_id },
                    |m: &mut GetOutEdgesRequest| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &GetOutEdgesRequest| { &m.type_id },
                    |m: &mut GetOutEdgesRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_ids",
                    |m: &GetOutEdgesRequest| { &m.property_ids },
                    |m: &mut GetOutEdgesRequest| { &mut m.property_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetOutEdgesRequest>(
                    "GetOutEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetOutEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetOutEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetOutEdgesRequest,
        };
        unsafe {
            instance.get(GetOutEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetOutEdgesRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_src_id();
        self.clear_type_id();
        self.clear_property_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOutEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOutEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInEdgesRequest {
    // message fields
    pub snapshot_id: i64,
    pub dst_id: i64,
    pub type_id: i32,
    pub property_ids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetInEdgesRequest {
    pub fn new() -> GetInEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // int64 dst_id = 2;

    pub fn clear_dst_id(&mut self) {
        self.dst_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: i64) {
        self.dst_id = v;
    }

    pub fn get_dst_id(&self) -> i64 {
        self.dst_id
    }

    // int32 type_id = 3;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // repeated int32 property_ids = 4;

    pub fn clear_property_ids(&mut self) {
        self.property_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_property_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.property_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.property_ids
    }

    // Take field
    pub fn take_property_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.property_ids, ::std::vec::Vec::new())
    }

    pub fn get_property_ids(&self) -> &[i32] {
        &self.property_ids
    }
}

impl ::protobuf::Message for GetInEdgesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dst_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.property_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dst_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.property_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.dst_id != 0 {
            os.write_int64(2, self.dst_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(3, self.type_id)?;
        }
        for v in &self.property_ids {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInEdgesRequest {
        GetInEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetInEdgesRequest| { &m.snapshot_id },
                    |m: &mut GetInEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dst_id",
                    |m: &GetInEdgesRequest| { &m.dst_id },
                    |m: &mut GetInEdgesRequest| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &GetInEdgesRequest| { &m.type_id },
                    |m: &mut GetInEdgesRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_ids",
                    |m: &GetInEdgesRequest| { &m.property_ids },
                    |m: &mut GetInEdgesRequest| { &mut m.property_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInEdgesRequest>(
                    "GetInEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetInEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInEdgesRequest,
        };
        unsafe {
            instance.get(GetInEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetInEdgesRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_dst_id();
        self.clear_type_id();
        self.clear_property_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphEdgeReponse {
    // message fields
    pub src_id: ::protobuf::SingularPtrField<super::gremlin_query::VertexId>,
    pub dst_id: ::protobuf::SingularPtrField<super::gremlin_query::VertexId>,
    pub edge_id: i64,
    pub type_id: i32,
    pub pros: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphEdgeReponse {
    pub fn new() -> GraphEdgeReponse {
        ::std::default::Default::default()
    }

    // .tinkerpop.VertexId src_id = 1;

    pub fn clear_src_id(&mut self) {
        self.src_id.clear();
    }

    pub fn has_src_id(&self) -> bool {
        self.src_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: super::gremlin_query::VertexId) {
        self.src_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_id(&mut self) -> &mut super::gremlin_query::VertexId {
        if self.src_id.is_none() {
            self.src_id.set_default();
        }
        self.src_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_id(&mut self) -> super::gremlin_query::VertexId {
        self.src_id.take().unwrap_or_else(|| super::gremlin_query::VertexId::new())
    }

    pub fn get_src_id(&self) -> &super::gremlin_query::VertexId {
        self.src_id.as_ref().unwrap_or_else(|| super::gremlin_query::VertexId::default_instance())
    }

    // .tinkerpop.VertexId dst_id = 2;

    pub fn clear_dst_id(&mut self) {
        self.dst_id.clear();
    }

    pub fn has_dst_id(&self) -> bool {
        self.dst_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: super::gremlin_query::VertexId) {
        self.dst_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_id(&mut self) -> &mut super::gremlin_query::VertexId {
        if self.dst_id.is_none() {
            self.dst_id.set_default();
        }
        self.dst_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_id(&mut self) -> super::gremlin_query::VertexId {
        self.dst_id.take().unwrap_or_else(|| super::gremlin_query::VertexId::new())
    }

    pub fn get_dst_id(&self) -> &super::gremlin_query::VertexId {
        self.dst_id.as_ref().unwrap_or_else(|| super::gremlin_query::VertexId::default_instance())
    }

    // int64 edge_id = 3;

    pub fn clear_edge_id(&mut self) {
        self.edge_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_id(&mut self, v: i64) {
        self.edge_id = v;
    }

    pub fn get_edge_id(&self) -> i64 {
        self.edge_id
    }

    // int32 type_id = 4;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // bytes pros = 5;

    pub fn clear_pros(&mut self) {
        self.pros.clear();
    }

    // Param is passed by value, moved
    pub fn set_pros(&mut self, v: ::std::vec::Vec<u8>) {
        self.pros = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pros(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pros
    }

    // Take field
    pub fn take_pros(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pros, ::std::vec::Vec::new())
    }

    pub fn get_pros(&self) -> &[u8] {
        &self.pros
    }
}

impl ::protobuf::Message for GraphEdgeReponse {
    fn is_initialized(&self) -> bool {
        for v in &self.src_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dst_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.edge_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pros)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.edge_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.edge_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pros.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.pros);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.edge_id != 0 {
            os.write_int64(3, self.edge_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(4, self.type_id)?;
        }
        if !self.pros.is_empty() {
            os.write_bytes(5, &self.pros)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphEdgeReponse {
        GraphEdgeReponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gremlin_query::VertexId>>(
                    "src_id",
                    |m: &GraphEdgeReponse| { &m.src_id },
                    |m: &mut GraphEdgeReponse| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gremlin_query::VertexId>>(
                    "dst_id",
                    |m: &GraphEdgeReponse| { &m.dst_id },
                    |m: &mut GraphEdgeReponse| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "edge_id",
                    |m: &GraphEdgeReponse| { &m.edge_id },
                    |m: &mut GraphEdgeReponse| { &mut m.edge_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &GraphEdgeReponse| { &m.type_id },
                    |m: &mut GraphEdgeReponse| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pros",
                    |m: &GraphEdgeReponse| { &m.pros },
                    |m: &mut GraphEdgeReponse| { &mut m.pros },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphEdgeReponse>(
                    "GraphEdgeReponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphEdgeReponse {
        static mut instance: ::protobuf::lazy::Lazy<GraphEdgeReponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphEdgeReponse,
        };
        unsafe {
            instance.get(GraphEdgeReponse::new)
        }
    }
}

impl ::protobuf::Clear for GraphEdgeReponse {
    fn clear(&mut self) {
        self.clear_src_id();
        self.clear_dst_id();
        self.clear_edge_id();
        self.clear_type_id();
        self.clear_pros();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphEdgeReponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphEdgeReponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetVertexsRequest {
    // message fields
    pub snapshot_id: i64,
    pub type_id: i32,
    pub ids: ::std::vec::Vec<i64>,
    pub prop_ids: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetVertexsRequest {
    pub fn new() -> GetVertexsRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // int32 type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // repeated int64 ids = 3;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ids, ::std::vec::Vec::new())
    }

    pub fn get_ids(&self) -> &[i64] {
        &self.ids
    }

    // repeated int32 prop_ids = 4;

    pub fn clear_prop_ids(&mut self) {
        self.prop_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.prop_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.prop_ids
    }

    // Take field
    pub fn take_prop_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.prop_ids, ::std::vec::Vec::new())
    }

    pub fn get_prop_ids(&self) -> &[i32] {
        &self.prop_ids
    }
}

impl ::protobuf::Message for GetVertexsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.prop_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.prop_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(2, self.type_id)?;
        }
        for v in &self.ids {
            os.write_int64(3, *v)?;
        };
        for v in &self.prop_ids {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetVertexsRequest {
        GetVertexsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetVertexsRequest| { &m.snapshot_id },
                    |m: &mut GetVertexsRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &GetVertexsRequest| { &m.type_id },
                    |m: &mut GetVertexsRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ids",
                    |m: &GetVertexsRequest| { &m.ids },
                    |m: &mut GetVertexsRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_ids",
                    |m: &GetVertexsRequest| { &m.prop_ids },
                    |m: &mut GetVertexsRequest| { &mut m.prop_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetVertexsRequest>(
                    "GetVertexsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetVertexsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetVertexsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetVertexsRequest,
        };
        unsafe {
            instance.get(GetVertexsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetVertexsRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_type_id();
        self.clear_ids();
        self.clear_prop_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetVertexsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVertexsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEdgesRequest {
    // message fields
    pub snapshot_id: i64,
    pub type_id: i32,
    pub ids: ::std::vec::Vec<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetEdgesRequest {
    pub fn new() -> GetEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // int32 type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // repeated int64 ids = 3;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ids, ::std::vec::Vec::new())
    }

    pub fn get_ids(&self) -> &[i64] {
        &self.ids
    }
}

impl ::protobuf::Message for GetEdgesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(2, self.type_id)?;
        }
        for v in &self.ids {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEdgesRequest {
        GetEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetEdgesRequest| { &m.snapshot_id },
                    |m: &mut GetEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &GetEdgesRequest| { &m.type_id },
                    |m: &mut GetEdgesRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ids",
                    |m: &GetEdgesRequest| { &m.ids },
                    |m: &mut GetEdgesRequest| { &mut m.ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetEdgesRequest>(
                    "GetEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetEdgesRequest,
        };
        unsafe {
            instance.get(GetEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetEdgesRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_type_id();
        self.clear_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchVertexEdgeRequest {
    // message fields
    pub snapshot_id: i64,
    pub vertex_id: ::protobuf::RepeatedField<super::gremlin_query::VertexId>,
    pub seq: ::std::vec::Vec<i64>,
    pub label_list: ::std::vec::Vec<u32>,
    pub edge_prop_flag: bool,
    pub limit_count: u64,
    pub logical_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BatchVertexEdgeRequest {
    pub fn new() -> BatchVertexEdgeRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // repeated .tinkerpop.VertexId vertex_id = 2;

    pub fn clear_vertex_id(&mut self) {
        self.vertex_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertex_id(&mut self, v: ::protobuf::RepeatedField<super::gremlin_query::VertexId>) {
        self.vertex_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertex_id(&mut self) -> &mut ::protobuf::RepeatedField<super::gremlin_query::VertexId> {
        &mut self.vertex_id
    }

    // Take field
    pub fn take_vertex_id(&mut self) -> ::protobuf::RepeatedField<super::gremlin_query::VertexId> {
        ::std::mem::replace(&mut self.vertex_id, ::protobuf::RepeatedField::new())
    }

    pub fn get_vertex_id(&self) -> &[super::gremlin_query::VertexId] {
        &self.vertex_id
    }

    // repeated int64 seq = 3;

    pub fn clear_seq(&mut self) {
        self.seq.clear();
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: ::std::vec::Vec<i64>) {
        self.seq = v;
    }

    // Mutable pointer to the field.
    pub fn mut_seq(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.seq
    }

    // Take field
    pub fn take_seq(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.seq, ::std::vec::Vec::new())
    }

    pub fn get_seq(&self) -> &[i64] {
        &self.seq
    }

    // repeated uint32 label_list = 4;

    pub fn clear_label_list(&mut self) {
        self.label_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.label_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.label_list
    }

    // Take field
    pub fn take_label_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.label_list, ::std::vec::Vec::new())
    }

    pub fn get_label_list(&self) -> &[u32] {
        &self.label_list
    }

    // bool edge_prop_flag = 5;

    pub fn clear_edge_prop_flag(&mut self) {
        self.edge_prop_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_edge_prop_flag(&mut self, v: bool) {
        self.edge_prop_flag = v;
    }

    pub fn get_edge_prop_flag(&self) -> bool {
        self.edge_prop_flag
    }

    // uint64 limit_count = 6;

    pub fn clear_limit_count(&mut self) {
        self.limit_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit_count(&mut self, v: u64) {
        self.limit_count = v;
    }

    pub fn get_limit_count(&self) -> u64 {
        self.limit_count
    }

    // repeated .maxgraph.LogicalCompare logical_compare = 7;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare
    }
}

impl ::protobuf::Message for BatchVertexEdgeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.vertex_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vertex_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.seq)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.label_list)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.edge_prop_flag = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit_count = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.vertex_id {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.seq {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.label_list {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.edge_prop_flag != false {
            my_size += 2;
        }
        if self.limit_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.limit_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        for v in &self.vertex_id {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.seq {
            os.write_int64(3, *v)?;
        };
        for v in &self.label_list {
            os.write_uint32(4, *v)?;
        };
        if self.edge_prop_flag != false {
            os.write_bool(5, self.edge_prop_flag)?;
        }
        if self.limit_count != 0 {
            os.write_uint64(6, self.limit_count)?;
        }
        for v in &self.logical_compare {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchVertexEdgeRequest {
        BatchVertexEdgeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &BatchVertexEdgeRequest| { &m.snapshot_id },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gremlin_query::VertexId>>(
                    "vertex_id",
                    |m: &BatchVertexEdgeRequest| { &m.vertex_id },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.vertex_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seq",
                    |m: &BatchVertexEdgeRequest| { &m.seq },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label_list",
                    |m: &BatchVertexEdgeRequest| { &m.label_list },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.label_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "edge_prop_flag",
                    |m: &BatchVertexEdgeRequest| { &m.edge_prop_flag },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.edge_prop_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit_count",
                    |m: &BatchVertexEdgeRequest| { &m.limit_count },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.limit_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare",
                    |m: &BatchVertexEdgeRequest| { &m.logical_compare },
                    |m: &mut BatchVertexEdgeRequest| { &mut m.logical_compare },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchVertexEdgeRequest>(
                    "BatchVertexEdgeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchVertexEdgeRequest {
        static mut instance: ::protobuf::lazy::Lazy<BatchVertexEdgeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchVertexEdgeRequest,
        };
        unsafe {
            instance.get(BatchVertexEdgeRequest::new)
        }
    }
}

impl ::protobuf::Clear for BatchVertexEdgeRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_vertex_id();
        self.clear_seq();
        self.clear_label_list();
        self.clear_edge_prop_flag();
        self.clear_limit_count();
        self.clear_logical_compare();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchVertexEdgeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchVertexEdgeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchVertexEdgeResponse {
    // message fields
    pub seq: i64,
    pub edge_id: i64,
    pub edge_label_id: i32,
    pub target_vid: ::protobuf::SingularPtrField<super::gremlin_query::VertexId>,
    pub edge_props: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BatchVertexEdgeResponse {
    pub fn new() -> BatchVertexEdgeResponse {
        ::std::default::Default::default()
    }

    // int64 seq = 1;

    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i64) {
        self.seq = v;
    }

    pub fn get_seq(&self) -> i64 {
        self.seq
    }

    // int64 edge_id = 2;

    pub fn clear_edge_id(&mut self) {
        self.edge_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_id(&mut self, v: i64) {
        self.edge_id = v;
    }

    pub fn get_edge_id(&self) -> i64 {
        self.edge_id
    }

    // int32 edge_label_id = 3;

    pub fn clear_edge_label_id(&mut self) {
        self.edge_label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_label_id(&mut self, v: i32) {
        self.edge_label_id = v;
    }

    pub fn get_edge_label_id(&self) -> i32 {
        self.edge_label_id
    }

    // .tinkerpop.VertexId target_vid = 4;

    pub fn clear_target_vid(&mut self) {
        self.target_vid.clear();
    }

    pub fn has_target_vid(&self) -> bool {
        self.target_vid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_vid(&mut self, v: super::gremlin_query::VertexId) {
        self.target_vid = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_vid(&mut self) -> &mut super::gremlin_query::VertexId {
        if self.target_vid.is_none() {
            self.target_vid.set_default();
        }
        self.target_vid.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_vid(&mut self) -> super::gremlin_query::VertexId {
        self.target_vid.take().unwrap_or_else(|| super::gremlin_query::VertexId::new())
    }

    pub fn get_target_vid(&self) -> &super::gremlin_query::VertexId {
        self.target_vid.as_ref().unwrap_or_else(|| super::gremlin_query::VertexId::default_instance())
    }

    // bytes edge_props = 5;

    pub fn clear_edge_props(&mut self) {
        self.edge_props.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_props(&mut self, v: ::std::vec::Vec<u8>) {
        self.edge_props = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_edge_props(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.edge_props
    }

    // Take field
    pub fn take_edge_props(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.edge_props, ::std::vec::Vec::new())
    }

    pub fn get_edge_props(&self) -> &[u8] {
        &self.edge_props
    }
}

impl ::protobuf::Message for BatchVertexEdgeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.target_vid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seq = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.edge_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.edge_label_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target_vid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.edge_props)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.edge_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.edge_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.edge_label_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.edge_label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target_vid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.edge_props.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.edge_props);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.seq != 0 {
            os.write_int64(1, self.seq)?;
        }
        if self.edge_id != 0 {
            os.write_int64(2, self.edge_id)?;
        }
        if self.edge_label_id != 0 {
            os.write_int32(3, self.edge_label_id)?;
        }
        if let Some(ref v) = self.target_vid.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.edge_props.is_empty() {
            os.write_bytes(5, &self.edge_props)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchVertexEdgeResponse {
        BatchVertexEdgeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "seq",
                    |m: &BatchVertexEdgeResponse| { &m.seq },
                    |m: &mut BatchVertexEdgeResponse| { &mut m.seq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "edge_id",
                    |m: &BatchVertexEdgeResponse| { &m.edge_id },
                    |m: &mut BatchVertexEdgeResponse| { &mut m.edge_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_label_id",
                    |m: &BatchVertexEdgeResponse| { &m.edge_label_id },
                    |m: &mut BatchVertexEdgeResponse| { &mut m.edge_label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gremlin_query::VertexId>>(
                    "target_vid",
                    |m: &BatchVertexEdgeResponse| { &m.target_vid },
                    |m: &mut BatchVertexEdgeResponse| { &mut m.target_vid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "edge_props",
                    |m: &BatchVertexEdgeResponse| { &m.edge_props },
                    |m: &mut BatchVertexEdgeResponse| { &mut m.edge_props },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchVertexEdgeResponse>(
                    "BatchVertexEdgeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchVertexEdgeResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchVertexEdgeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchVertexEdgeResponse,
        };
        unsafe {
            instance.get(BatchVertexEdgeResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchVertexEdgeResponse {
    fn clear(&mut self) {
        self.clear_seq();
        self.clear_edge_id();
        self.clear_edge_label_id();
        self.clear_target_vid();
        self.clear_edge_props();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchVertexEdgeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchVertexEdgeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchVertexCountResponse {
    // message fields
    pub vid: i64,
    pub count_val: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BatchVertexCountResponse {
    pub fn new() -> BatchVertexCountResponse {
        ::std::default::Default::default()
    }

    // int64 vid = 1;

    pub fn clear_vid(&mut self) {
        self.vid = 0;
    }

    // Param is passed by value, moved
    pub fn set_vid(&mut self, v: i64) {
        self.vid = v;
    }

    pub fn get_vid(&self) -> i64 {
        self.vid
    }

    // int64 count_val = 2;

    pub fn clear_count_val(&mut self) {
        self.count_val = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_val(&mut self, v: i64) {
        self.count_val = v;
    }

    pub fn get_count_val(&self) -> i64 {
        self.count_val
    }
}

impl ::protobuf::Message for BatchVertexCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count_val = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.vid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.vid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count_val != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count_val, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.vid != 0 {
            os.write_int64(1, self.vid)?;
        }
        if self.count_val != 0 {
            os.write_int64(2, self.count_val)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchVertexCountResponse {
        BatchVertexCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vid",
                    |m: &BatchVertexCountResponse| { &m.vid },
                    |m: &mut BatchVertexCountResponse| { &mut m.vid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "count_val",
                    |m: &BatchVertexCountResponse| { &m.count_val },
                    |m: &mut BatchVertexCountResponse| { &mut m.count_val },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchVertexCountResponse>(
                    "BatchVertexCountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchVertexCountResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchVertexCountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchVertexCountResponse,
        };
        unsafe {
            instance.get(BatchVertexCountResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchVertexCountResponse {
    fn clear(&mut self) {
        self.clear_vid();
        self.clear_count_val();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchVertexCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchVertexCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryResponse {
    // message fields
    pub value: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub error_code: i32,
    pub message: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    // repeated bytes value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }

    pub fn get_value(&self) -> &[::std::vec::Vec<u8>] {
        &self.value
    }

    // int32 error_code = 2;

    pub fn clear_error_code(&mut self) {
        self.error_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: i32) {
        self.error_code = v;
    }

    pub fn get_error_code(&self) -> i32 {
        self.error_code
    }

    // string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for QueryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.error_code = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if self.error_code != 0 {
            my_size += ::protobuf::rt::value_size(2, self.error_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_bytes(1, &v)?;
        };
        if self.error_code != 0 {
            os.write_int32(2, self.error_code)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &QueryResponse| { &m.value },
                    |m: &mut QueryResponse| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "error_code",
                    |m: &QueryResponse| { &m.error_code },
                    |m: &mut QueryResponse| { &mut m.error_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &QueryResponse| { &m.message },
                    |m: &mut QueryResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryResponse>(
                    "QueryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryResponse,
        };
        unsafe {
            instance.get(QueryResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryResponse {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_error_code();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0fstore_api.proto\x12\ttinkerpop\x1a\x13gremlin_query.proto\x1a\x11s\
    dk/message.proto\"\xbb\x01\n\x0bScanRequest\x12\x1f\n\x0bsnapshot_id\x18\
    \x01\x20\x01(\x03R\nsnapshotId\x12\x17\n\x07type_id\x18\x02\x20\x01(\x05\
    R\x06typeId\x12\x16\n\x06offset\x18\x03\x20\x01(\x05R\x06offset\x12\x14\
    \n\x05limit\x18\x04\x20\x01(\x05R\x05limit\x12!\n\x0cpartition_id\x18\
    \x05\x20\x01(\x05R\x0bpartitionId\x12!\n\x0cproperty_ids\x18\x06\x20\x03\
    (\x05R\x0bpropertyIds\"\xbf\x01\n\x0fScanEdgeRequest\x12\x1f\n\x0bsnapsh\
    ot_id\x18\x01\x20\x01(\x03R\nsnapshotId\x12\x17\n\x07type_id\x18\x02\x20\
    \x01(\x05R\x06typeId\x12\x16\n\x06offset\x18\x03\x20\x01(\x05R\x06offset\
    \x12\x14\n\x05limit\x18\x04\x20\x01(\x05R\x05limit\x12!\n\x0cpartition_i\
    d\x18\x05\x20\x01(\x05R\x0bpartitionId\x12!\n\x0cproperty_ids\x18\x06\
    \x20\x03(\x05R\x0bpropertyIds\"\x88\x01\n\x12GetOutEdgesRequest\x12\x1f\
    \n\x0bsnapshot_id\x18\x01\x20\x01(\x03R\nsnapshotId\x12\x15\n\x06src_id\
    \x18\x02\x20\x01(\x03R\x05srcId\x12\x17\n\x07type_id\x18\x03\x20\x01(\
    \x05R\x06typeId\x12!\n\x0cproperty_ids\x18\x04\x20\x03(\x05R\x0bproperty\
    Ids\"\x87\x01\n\x11GetInEdgesRequest\x12\x1f\n\x0bsnapshot_id\x18\x01\
    \x20\x01(\x03R\nsnapshotId\x12\x15\n\x06dst_id\x18\x02\x20\x01(\x03R\x05\
    dstId\x12\x17\n\x07type_id\x18\x03\x20\x01(\x05R\x06typeId\x12!\n\x0cpro\
    perty_ids\x18\x04\x20\x03(\x05R\x0bpropertyIds\"\xb0\x01\n\x10GraphEdgeR\
    eponse\x12*\n\x06src_id\x18\x01\x20\x01(\x0b2\x13.tinkerpop.VertexIdR\
    \x05srcId\x12*\n\x06dst_id\x18\x02\x20\x01(\x0b2\x13.tinkerpop.VertexIdR\
    \x05dstId\x12\x17\n\x07edge_id\x18\x03\x20\x01(\x03R\x06edgeId\x12\x17\n\
    \x07type_id\x18\x04\x20\x01(\x05R\x06typeId\x12\x12\n\x04pros\x18\x05\
    \x20\x01(\x0cR\x04pros\"z\n\x11GetVertexsRequest\x12\x1f\n\x0bsnapshot_i\
    d\x18\x01\x20\x01(\x03R\nsnapshotId\x12\x17\n\x07type_id\x18\x02\x20\x01\
    (\x05R\x06typeId\x12\x10\n\x03ids\x18\x03\x20\x03(\x03R\x03ids\x12\x19\n\
    \x08prop_ids\x18\x04\x20\x03(\x05R\x07propIds\"]\n\x0fGetEdgesRequest\
    \x12\x1f\n\x0bsnapshot_id\x18\x01\x20\x01(\x03R\nsnapshotId\x12\x17\n\
    \x07type_id\x18\x02\x20\x01(\x05R\x06typeId\x12\x10\n\x03ids\x18\x03\x20\
    \x03(\x03R\x03ids\"\xa6\x02\n\x16BatchVertexEdgeRequest\x12\x1f\n\x0bsna\
    pshot_id\x18\x01\x20\x01(\x03R\nsnapshotId\x120\n\tvertex_id\x18\x02\x20\
    \x03(\x0b2\x13.tinkerpop.VertexIdR\x08vertexId\x12\x10\n\x03seq\x18\x03\
    \x20\x03(\x03R\x03seq\x12\x1d\n\nlabel_list\x18\x04\x20\x03(\rR\tlabelLi\
    st\x12$\n\x0eedge_prop_flag\x18\x05\x20\x01(\x08R\x0cedgePropFlag\x12\
    \x1f\n\x0blimit_count\x18\x06\x20\x01(\x04R\nlimitCount\x12A\n\x0flogica\
    l_compare\x18\x07\x20\x03(\x0b2\x18.maxgraph.LogicalCompareR\x0elogicalC\
    ompare\"\xbb\x01\n\x17BatchVertexEdgeResponse\x12\x10\n\x03seq\x18\x01\
    \x20\x01(\x03R\x03seq\x12\x17\n\x07edge_id\x18\x02\x20\x01(\x03R\x06edge\
    Id\x12\"\n\redge_label_id\x18\x03\x20\x01(\x05R\x0bedgeLabelId\x122\n\nt\
    arget_vid\x18\x04\x20\x01(\x0b2\x13.tinkerpop.VertexIdR\ttargetVid\x12\
    \x1d\n\nedge_props\x18\x05\x20\x01(\x0cR\tedgeProps\"I\n\x18BatchVertexC\
    ountResponse\x12\x10\n\x03vid\x18\x01\x20\x01(\x03R\x03vid\x12\x1b\n\tco\
    unt_val\x18\x02\x20\x01(\x03R\x08countVal\"^\n\rQueryResponse\x12\x14\n\
    \x05value\x18\x01\x20\x03(\x0cR\x05value\x12\x1d\n\nerror_code\x18\x02\
    \x20\x01(\x05R\terrorCode\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07me\
    ssage2\xb1\x06\n\x0cStoreService\x12K\n\x0bgetOutEdges\x12\x1d.tinkerpop\
    .GetOutEdgesRequest\x1a\x1b.tinkerpop.GraphEdgeReponse0\x01\x12\\\n\x11g\
    etBatchOutTarget\x12!.tinkerpop.BatchVertexEdgeRequest\x1a\".tinkerpop.B\
    atchVertexEdgeResponse0\x01\x12\\\n\x10getBatchOutCount\x12!.tinkerpop.B\
    atchVertexEdgeRequest\x1a#.tinkerpop.BatchVertexCountResponse0\x01\x12I\
    \n\ngetInEdges\x12\x1c.tinkerpop.GetInEdgesRequest\x1a\x1b.tinkerpop.Gra\
    phEdgeReponse0\x01\x12[\n\x10getBatchInTarget\x12!.tinkerpop.BatchVertex\
    EdgeRequest\x1a\".tinkerpop.BatchVertexEdgeResponse0\x01\x12[\n\x0fgetBa\
    tchInCount\x12!.tinkerpop.BatchVertexEdgeRequest\x1a#.tinkerpop.BatchVer\
    texCountResponse0\x01\x12G\n\ngetVertexs\x12\x1c.tinkerpop.GetVertexsReq\
    uest\x1a\x19.tinkerpop.VertexResponse0\x01\x12E\n\x08getEdges\x12\x1a.ti\
    nkerpop.GetEdgesRequest\x1a\x1b.tinkerpop.GraphEdgeReponse0\x01\x12F\n\t\
    scanEdges\x12\x1a.tinkerpop.ScanEdgeRequest\x1a\x1b.tinkerpop.GraphEdgeR\
    eponse0\x01\x12;\n\x04scan\x12\x16.tinkerpop.ScanRequest\x1a\x19.tinkerp\
    op.VertexResponse0\x01B\x1c\n\x1acom.alibaba.maxgraph.protob\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
