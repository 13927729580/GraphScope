//
//! Copyright 2020 Alibaba Group Holding Limited.
//! 
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//! 
//!     http://www.apache.org/licenses/LICENSE-2.0
//! 
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct BatchVerticesEdgesRequest {
    // message fields
    pub snapshot_id: i64,
    pub vertex_id: ::std::vec::Vec<i64>,
    pub label_list: ::std::vec::Vec<u32>,
    pub logical_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    pub conditions: ::protobuf::SingularPtrField<OutputCondition>,
    pub vertex_flag: bool,
    pub partition_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BatchVerticesEdgesRequest {
    pub fn new() -> BatchVerticesEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // repeated int64 vertex_id = 2;

    pub fn clear_vertex_id(&mut self) {
        self.vertex_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertex_id(&mut self, v: ::std::vec::Vec<i64>) {
        self.vertex_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertex_id(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.vertex_id
    }

    // Take field
    pub fn take_vertex_id(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.vertex_id, ::std::vec::Vec::new())
    }

    pub fn get_vertex_id(&self) -> &[i64] {
        &self.vertex_id
    }

    // repeated uint32 label_list = 3;

    pub fn clear_label_list(&mut self) {
        self.label_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.label_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.label_list
    }

    // Take field
    pub fn take_label_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.label_list, ::std::vec::Vec::new())
    }

    pub fn get_label_list(&self) -> &[u32] {
        &self.label_list
    }

    // repeated .maxgraph.LogicalCompare logical_compare = 4;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare
    }

    // .tinkerpop.OutputCondition conditions = 5;

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    pub fn has_conditions(&self) -> bool {
        self.conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: OutputCondition) {
        self.conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conditions(&mut self) -> &mut OutputCondition {
        if self.conditions.is_none() {
            self.conditions.set_default();
        }
        self.conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_conditions(&mut self) -> OutputCondition {
        self.conditions.take().unwrap_or_else(|| OutputCondition::new())
    }

    pub fn get_conditions(&self) -> &OutputCondition {
        self.conditions.as_ref().unwrap_or_else(|| OutputCondition::default_instance())
    }

    // bool vertex_flag = 6;

    pub fn clear_vertex_flag(&mut self) {
        self.vertex_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_vertex_flag(&mut self, v: bool) {
        self.vertex_flag = v;
    }

    pub fn get_vertex_flag(&self) -> bool {
        self.vertex_flag
    }

    // repeated uint32 partition_ids = 7;

    pub fn clear_partition_ids(&mut self) {
        self.partition_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.partition_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.partition_ids
    }

    // Take field
    pub fn take_partition_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.partition_ids, ::std::vec::Vec::new())
    }

    pub fn get_partition_ids(&self) -> &[u32] {
        &self.partition_ids
    }
}

impl ::protobuf::Message for BatchVerticesEdgesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.vertex_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.label_list)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conditions)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vertex_flag = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.partition_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.vertex_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.label_list {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.vertex_flag != false {
            my_size += 2;
        }
        for value in &self.partition_ids {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        for v in &self.vertex_id {
            os.write_int64(2, *v)?;
        };
        for v in &self.label_list {
            os.write_uint32(3, *v)?;
        };
        for v in &self.logical_compare {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.conditions.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.vertex_flag != false {
            os.write_bool(6, self.vertex_flag)?;
        }
        for v in &self.partition_ids {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchVerticesEdgesRequest {
        BatchVerticesEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &BatchVerticesEdgesRequest| { &m.snapshot_id },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vertex_id",
                    |m: &BatchVerticesEdgesRequest| { &m.vertex_id },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.vertex_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label_list",
                    |m: &BatchVerticesEdgesRequest| { &m.label_list },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.label_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare",
                    |m: &BatchVerticesEdgesRequest| { &m.logical_compare },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.logical_compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputCondition>>(
                    "conditions",
                    |m: &BatchVerticesEdgesRequest| { &m.conditions },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.conditions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "vertex_flag",
                    |m: &BatchVerticesEdgesRequest| { &m.vertex_flag },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.vertex_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partition_ids",
                    |m: &BatchVerticesEdgesRequest| { &m.partition_ids },
                    |m: &mut BatchVerticesEdgesRequest| { &mut m.partition_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchVerticesEdgesRequest>(
                    "BatchVerticesEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchVerticesEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<BatchVerticesEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchVerticesEdgesRequest,
        };
        unsafe {
            instance.get(BatchVerticesEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for BatchVerticesEdgesRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_vertex_id();
        self.clear_label_list();
        self.clear_logical_compare();
        self.clear_conditions();
        self.clear_vertex_flag();
        self.clear_partition_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchVerticesEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchVerticesEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchVerticesEdgesResponse {
    // message fields
    pub src_id: ::protobuf::SingularPtrField<super::gremlin_query::VertexId>,
    pub dst_id: ::protobuf::SingularPtrField<super::gremlin_query::VertexId>,
    pub edge_id: i64,
    pub type_id: u32,
    pub pros: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BatchVerticesEdgesResponse {
    pub fn new() -> BatchVerticesEdgesResponse {
        ::std::default::Default::default()
    }

    // .tinkerpop.VertexId src_id = 1;

    pub fn clear_src_id(&mut self) {
        self.src_id.clear();
    }

    pub fn has_src_id(&self) -> bool {
        self.src_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: super::gremlin_query::VertexId) {
        self.src_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_id(&mut self) -> &mut super::gremlin_query::VertexId {
        if self.src_id.is_none() {
            self.src_id.set_default();
        }
        self.src_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_src_id(&mut self) -> super::gremlin_query::VertexId {
        self.src_id.take().unwrap_or_else(|| super::gremlin_query::VertexId::new())
    }

    pub fn get_src_id(&self) -> &super::gremlin_query::VertexId {
        self.src_id.as_ref().unwrap_or_else(|| super::gremlin_query::VertexId::default_instance())
    }

    // .tinkerpop.VertexId dst_id = 2;

    pub fn clear_dst_id(&mut self) {
        self.dst_id.clear();
    }

    pub fn has_dst_id(&self) -> bool {
        self.dst_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: super::gremlin_query::VertexId) {
        self.dst_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_id(&mut self) -> &mut super::gremlin_query::VertexId {
        if self.dst_id.is_none() {
            self.dst_id.set_default();
        }
        self.dst_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst_id(&mut self) -> super::gremlin_query::VertexId {
        self.dst_id.take().unwrap_or_else(|| super::gremlin_query::VertexId::new())
    }

    pub fn get_dst_id(&self) -> &super::gremlin_query::VertexId {
        self.dst_id.as_ref().unwrap_or_else(|| super::gremlin_query::VertexId::default_instance())
    }

    // int64 edge_id = 3;

    pub fn clear_edge_id(&mut self) {
        self.edge_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_id(&mut self, v: i64) {
        self.edge_id = v;
    }

    pub fn get_edge_id(&self) -> i64 {
        self.edge_id
    }

    // uint32 type_id = 4;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: u32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> u32 {
        self.type_id
    }

    // bytes pros = 5;

    pub fn clear_pros(&mut self) {
        self.pros.clear();
    }

    // Param is passed by value, moved
    pub fn set_pros(&mut self, v: ::std::vec::Vec<u8>) {
        self.pros = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pros(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pros
    }

    // Take field
    pub fn take_pros(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pros, ::std::vec::Vec::new())
    }

    pub fn get_pros(&self) -> &[u8] {
        &self.pros
    }
}

impl ::protobuf::Message for BatchVerticesEdgesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.src_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dst_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.edge_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.type_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pros)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.edge_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.edge_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.pros.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.pros);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src_id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.edge_id != 0 {
            os.write_int64(3, self.edge_id)?;
        }
        if self.type_id != 0 {
            os.write_uint32(4, self.type_id)?;
        }
        if !self.pros.is_empty() {
            os.write_bytes(5, &self.pros)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchVerticesEdgesResponse {
        BatchVerticesEdgesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gremlin_query::VertexId>>(
                    "src_id",
                    |m: &BatchVerticesEdgesResponse| { &m.src_id },
                    |m: &mut BatchVerticesEdgesResponse| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::gremlin_query::VertexId>>(
                    "dst_id",
                    |m: &BatchVerticesEdgesResponse| { &m.dst_id },
                    |m: &mut BatchVerticesEdgesResponse| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "edge_id",
                    |m: &BatchVerticesEdgesResponse| { &m.edge_id },
                    |m: &mut BatchVerticesEdgesResponse| { &mut m.edge_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type_id",
                    |m: &BatchVerticesEdgesResponse| { &m.type_id },
                    |m: &mut BatchVerticesEdgesResponse| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pros",
                    |m: &BatchVerticesEdgesResponse| { &m.pros },
                    |m: &mut BatchVerticesEdgesResponse| { &mut m.pros },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchVerticesEdgesResponse>(
                    "BatchVerticesEdgesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchVerticesEdgesResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchVerticesEdgesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchVerticesEdgesResponse,
        };
        unsafe {
            instance.get(BatchVerticesEdgesResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchVerticesEdgesResponse {
    fn clear(&mut self) {
        self.clear_src_id();
        self.clear_dst_id();
        self.clear_edge_id();
        self.clear_type_id();
        self.clear_pros();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchVerticesEdgesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchVerticesEdgesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchVerticesCountResponse {
    // message fields
    pub vid: i64,
    pub count_val: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BatchVerticesCountResponse {
    pub fn new() -> BatchVerticesCountResponse {
        ::std::default::Default::default()
    }

    // int64 vid = 1;

    pub fn clear_vid(&mut self) {
        self.vid = 0;
    }

    // Param is passed by value, moved
    pub fn set_vid(&mut self, v: i64) {
        self.vid = v;
    }

    pub fn get_vid(&self) -> i64 {
        self.vid
    }

    // int64 count_val = 2;

    pub fn clear_count_val(&mut self) {
        self.count_val = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_val(&mut self, v: i64) {
        self.count_val = v;
    }

    pub fn get_count_val(&self) -> i64 {
        self.count_val
    }
}

impl ::protobuf::Message for BatchVerticesCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count_val = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.vid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.vid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.count_val != 0 {
            my_size += ::protobuf::rt::value_size(2, self.count_val, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.vid != 0 {
            os.write_int64(1, self.vid)?;
        }
        if self.count_val != 0 {
            os.write_int64(2, self.count_val)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchVerticesCountResponse {
        BatchVerticesCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vid",
                    |m: &BatchVerticesCountResponse| { &m.vid },
                    |m: &mut BatchVerticesCountResponse| { &mut m.vid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "count_val",
                    |m: &BatchVerticesCountResponse| { &m.count_val },
                    |m: &mut BatchVerticesCountResponse| { &mut m.count_val },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchVerticesCountResponse>(
                    "BatchVerticesCountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchVerticesCountResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchVerticesCountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchVerticesCountResponse,
        };
        unsafe {
            instance.get(BatchVerticesCountResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchVerticesCountResponse {
    fn clear(&mut self) {
        self.clear_vid();
        self.clear_count_val();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchVerticesCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchVerticesCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerticesRequest {
    // message fields
    pub snapshot_id: i64,
    pub type_id: u32,
    pub ids: ::std::vec::Vec<i64>,
    pub prop_ids: ::std::vec::Vec<i32>,
    pub prop_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VerticesRequest {
    pub fn new() -> VerticesRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // uint32 type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: u32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> u32 {
        self.type_id
    }

    // repeated int64 ids = 3;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ids, ::std::vec::Vec::new())
    }

    pub fn get_ids(&self) -> &[i64] {
        &self.ids
    }

    // repeated int32 prop_ids = 4;

    pub fn clear_prop_ids(&mut self) {
        self.prop_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.prop_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.prop_ids
    }

    // Take field
    pub fn take_prop_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.prop_ids, ::std::vec::Vec::new())
    }

    pub fn get_prop_ids(&self) -> &[i32] {
        &self.prop_ids
    }

    // bool prop_flag = 5;

    pub fn clear_prop_flag(&mut self) {
        self.prop_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_prop_flag(&mut self, v: bool) {
        self.prop_flag = v;
    }

    pub fn get_prop_flag(&self) -> bool {
        self.prop_flag
    }
}

impl ::protobuf::Message for VerticesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.type_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.prop_ids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prop_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ids {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.prop_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.prop_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if self.type_id != 0 {
            os.write_uint32(2, self.type_id)?;
        }
        for v in &self.ids {
            os.write_int64(3, *v)?;
        };
        for v in &self.prop_ids {
            os.write_int32(4, *v)?;
        };
        if self.prop_flag != false {
            os.write_bool(5, self.prop_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerticesRequest {
        VerticesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &VerticesRequest| { &m.snapshot_id },
                    |m: &mut VerticesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "type_id",
                    |m: &VerticesRequest| { &m.type_id },
                    |m: &mut VerticesRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ids",
                    |m: &VerticesRequest| { &m.ids },
                    |m: &mut VerticesRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_ids",
                    |m: &VerticesRequest| { &m.prop_ids },
                    |m: &mut VerticesRequest| { &mut m.prop_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prop_flag",
                    |m: &VerticesRequest| { &m.prop_flag },
                    |m: &mut VerticesRequest| { &mut m.prop_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerticesRequest>(
                    "VerticesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerticesRequest {
        static mut instance: ::protobuf::lazy::Lazy<VerticesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerticesRequest,
        };
        unsafe {
            instance.get(VerticesRequest::new)
        }
    }
}

impl ::protobuf::Clear for VerticesRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_type_id();
        self.clear_ids();
        self.clear_prop_ids();
        self.clear_prop_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerticesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerticesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphEdgesRequest {
    // message fields
    pub snapshot_id: i64,
    pub type_id: ::protobuf::SingularPtrField<EdgeType>,
    pub ids: ::protobuf::RepeatedField<EdgeId>,
    pub prop_ids: ::std::vec::Vec<i32>,
    pub prop_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphEdgesRequest {
    pub fn new() -> GraphEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // .tinkerpop.EdgeType type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id.clear();
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: EdgeType) {
        self.type_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_id(&mut self) -> &mut EdgeType {
        if self.type_id.is_none() {
            self.type_id.set_default();
        }
        self.type_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_id(&mut self) -> EdgeType {
        self.type_id.take().unwrap_or_else(|| EdgeType::new())
    }

    pub fn get_type_id(&self) -> &EdgeType {
        self.type_id.as_ref().unwrap_or_else(|| EdgeType::default_instance())
    }

    // repeated .tinkerpop.EdgeId ids = 3;

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<EdgeId>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<EdgeId> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<EdgeId> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_ids(&self) -> &[EdgeId] {
        &self.ids
    }

    // repeated int32 prop_ids = 4;

    pub fn clear_prop_ids(&mut self) {
        self.prop_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.prop_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.prop_ids
    }

    // Take field
    pub fn take_prop_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.prop_ids, ::std::vec::Vec::new())
    }

    pub fn get_prop_ids(&self) -> &[i32] {
        &self.prop_ids
    }

    // bool prop_flag = 5;

    pub fn clear_prop_flag(&mut self) {
        self.prop_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_prop_flag(&mut self, v: bool) {
        self.prop_flag = v;
    }

    pub fn get_prop_flag(&self) -> bool {
        self.prop_flag
    }
}

impl ::protobuf::Message for GraphEdgesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.type_id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.type_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.prop_ids)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prop_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.type_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.prop_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.prop_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        if let Some(ref v) = self.type_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ids {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.prop_ids {
            os.write_int32(4, *v)?;
        };
        if self.prop_flag != false {
            os.write_bool(5, self.prop_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphEdgesRequest {
        GraphEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GraphEdgesRequest| { &m.snapshot_id },
                    |m: &mut GraphEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeType>>(
                    "type_id",
                    |m: &GraphEdgesRequest| { &m.type_id },
                    |m: &mut GraphEdgesRequest| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EdgeId>>(
                    "ids",
                    |m: &GraphEdgesRequest| { &m.ids },
                    |m: &mut GraphEdgesRequest| { &mut m.ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_ids",
                    |m: &GraphEdgesRequest| { &m.prop_ids },
                    |m: &mut GraphEdgesRequest| { &mut m.prop_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prop_flag",
                    |m: &GraphEdgesRequest| { &m.prop_flag },
                    |m: &mut GraphEdgesRequest| { &mut m.prop_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphEdgesRequest>(
                    "GraphEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GraphEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphEdgesRequest,
        };
        unsafe {
            instance.get(GraphEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GraphEdgesRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_type_id();
        self.clear_ids();
        self.clear_prop_ids();
        self.clear_prop_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryRequest {
    // message fields
    pub snapshot_id: i64,
    pub label_id: ::std::vec::Vec<u32>,
    pub logical_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    pub conditions: ::protobuf::SingularPtrField<OutputCondition>,
    pub partition_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryRequest {
    pub fn new() -> QueryRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // repeated uint32 label_id = 2;

    pub fn clear_label_id(&mut self) {
        self.label_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.label_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.label_id
    }

    // Take field
    pub fn take_label_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.label_id, ::std::vec::Vec::new())
    }

    pub fn get_label_id(&self) -> &[u32] {
        &self.label_id
    }

    // repeated .maxgraph.LogicalCompare logical_compare = 3;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare
    }

    // .tinkerpop.OutputCondition conditions = 4;

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    pub fn has_conditions(&self) -> bool {
        self.conditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: OutputCondition) {
        self.conditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conditions(&mut self) -> &mut OutputCondition {
        if self.conditions.is_none() {
            self.conditions.set_default();
        }
        self.conditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_conditions(&mut self) -> OutputCondition {
        self.conditions.take().unwrap_or_else(|| OutputCondition::new())
    }

    pub fn get_conditions(&self) -> &OutputCondition {
        self.conditions.as_ref().unwrap_or_else(|| OutputCondition::default_instance())
    }

    // repeated uint32 partition_ids = 5;

    pub fn clear_partition_ids(&mut self) {
        self.partition_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.partition_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.partition_ids
    }

    // Take field
    pub fn take_partition_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.partition_ids, ::std::vec::Vec::new())
    }

    pub fn get_partition_ids(&self) -> &[u32] {
        &self.partition_ids
    }
}

impl ::protobuf::Message for QueryRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.label_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.conditions)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.partition_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.label_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.partition_ids {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        for v in &self.label_id {
            os.write_uint32(2, *v)?;
        };
        for v in &self.logical_compare {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.conditions.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.partition_ids {
            os.write_uint32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryRequest {
        QueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &QueryRequest| { &m.snapshot_id },
                    |m: &mut QueryRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label_id",
                    |m: &QueryRequest| { &m.label_id },
                    |m: &mut QueryRequest| { &mut m.label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare",
                    |m: &QueryRequest| { &m.logical_compare },
                    |m: &mut QueryRequest| { &mut m.logical_compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OutputCondition>>(
                    "conditions",
                    |m: &QueryRequest| { &m.conditions },
                    |m: &mut QueryRequest| { &mut m.conditions },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partition_ids",
                    |m: &QueryRequest| { &m.partition_ids },
                    |m: &mut QueryRequest| { &mut m.partition_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryRequest>(
                    "QueryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryRequest {
        static mut instance: ::protobuf::lazy::Lazy<QueryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryRequest,
        };
        unsafe {
            instance.get(QueryRequest::new)
        }
    }
}

impl ::protobuf::Clear for QueryRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_label_id();
        self.clear_logical_compare();
        self.clear_conditions();
        self.clear_partition_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryCountRequest {
    // message fields
    pub snapshot_id: i64,
    pub label_id: ::std::vec::Vec<u32>,
    pub logical_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    pub partition_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryCountRequest {
    pub fn new() -> QueryCountRequest {
        ::std::default::Default::default()
    }

    // int64 snapshot_id = 1;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // repeated uint32 label_id = 2;

    pub fn clear_label_id(&mut self) {
        self.label_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: ::std::vec::Vec<u32>) {
        self.label_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_id(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.label_id
    }

    // Take field
    pub fn take_label_id(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.label_id, ::std::vec::Vec::new())
    }

    pub fn get_label_id(&self) -> &[u32] {
        &self.label_id
    }

    // repeated .maxgraph.LogicalCompare logical_compare = 3;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare
    }

    // repeated uint32 partition_ids = 4;

    pub fn clear_partition_ids(&mut self) {
        self.partition_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.partition_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.partition_ids
    }

    // Take field
    pub fn take_partition_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.partition_ids, ::std::vec::Vec::new())
    }

    pub fn get_partition_ids(&self) -> &[u32] {
        &self.partition_ids
    }
}

impl ::protobuf::Message for QueryCountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.label_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.partition_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.label_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.partition_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.snapshot_id != 0 {
            os.write_int64(1, self.snapshot_id)?;
        }
        for v in &self.label_id {
            os.write_uint32(2, *v)?;
        };
        for v in &self.logical_compare {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.partition_ids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryCountRequest {
        QueryCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &QueryCountRequest| { &m.snapshot_id },
                    |m: &mut QueryCountRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label_id",
                    |m: &QueryCountRequest| { &m.label_id },
                    |m: &mut QueryCountRequest| { &mut m.label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare",
                    |m: &QueryCountRequest| { &m.logical_compare },
                    |m: &mut QueryCountRequest| { &mut m.logical_compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partition_ids",
                    |m: &QueryCountRequest| { &m.partition_ids },
                    |m: &mut QueryCountRequest| { &mut m.partition_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryCountRequest>(
                    "QueryCountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryCountRequest {
        static mut instance: ::protobuf::lazy::Lazy<QueryCountRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryCountRequest,
        };
        unsafe {
            instance.get(QueryCountRequest::new)
        }
    }
}

impl ::protobuf::Clear for QueryCountRequest {
    fn clear(&mut self) {
        self.clear_snapshot_id();
        self.clear_label_id();
        self.clear_logical_compare();
        self.clear_partition_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CountResponse {
    // message fields
    pub count_val: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CountResponse {
    pub fn new() -> CountResponse {
        ::std::default::Default::default()
    }

    // int64 count_val = 1;

    pub fn clear_count_val(&mut self) {
        self.count_val = 0;
    }

    // Param is passed by value, moved
    pub fn set_count_val(&mut self, v: i64) {
        self.count_val = v;
    }

    pub fn get_count_val(&self) -> i64 {
        self.count_val
    }
}

impl ::protobuf::Message for CountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count_val = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count_val != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count_val, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.count_val != 0 {
            os.write_int64(1, self.count_val)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountResponse {
        CountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "count_val",
                    |m: &CountResponse| { &m.count_val },
                    |m: &mut CountResponse| { &mut m.count_val },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CountResponse>(
                    "CountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CountResponse {
        static mut instance: ::protobuf::lazy::Lazy<CountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CountResponse,
        };
        unsafe {
            instance.get(CountResponse::new)
        }
    }
}

impl ::protobuf::Clear for CountResponse {
    fn clear(&mut self) {
        self.clear_count_val();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputCondition {
    // message fields
    pub dedup_prop_ids: ::std::vec::Vec<u32>,
    pub limit: u64,
    pub prop_flag: bool,
    pub prop_ids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OutputCondition {
    pub fn new() -> OutputCondition {
        ::std::default::Default::default()
    }

    // repeated uint32 dedup_prop_ids = 1;

    pub fn clear_dedup_prop_ids(&mut self) {
        self.dedup_prop_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_dedup_prop_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.dedup_prop_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dedup_prop_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.dedup_prop_ids
    }

    // Take field
    pub fn take_dedup_prop_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.dedup_prop_ids, ::std::vec::Vec::new())
    }

    pub fn get_dedup_prop_ids(&self) -> &[u32] {
        &self.dedup_prop_ids
    }

    // uint64 limit = 2;

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    pub fn get_limit(&self) -> u64 {
        self.limit
    }

    // bool prop_flag = 3;

    pub fn clear_prop_flag(&mut self) {
        self.prop_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_prop_flag(&mut self, v: bool) {
        self.prop_flag = v;
    }

    pub fn get_prop_flag(&self) -> bool {
        self.prop_flag
    }

    // repeated uint32 prop_ids = 4;

    pub fn clear_prop_ids(&mut self) {
        self.prop_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.prop_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_ids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.prop_ids
    }

    // Take field
    pub fn take_prop_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.prop_ids, ::std::vec::Vec::new())
    }

    pub fn get_prop_ids(&self) -> &[u32] {
        &self.prop_ids
    }
}

impl ::protobuf::Message for OutputCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.dedup_prop_ids)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.prop_flag = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.prop_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dedup_prop_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prop_flag != false {
            my_size += 2;
        }
        for value in &self.prop_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dedup_prop_ids {
            os.write_uint32(1, *v)?;
        };
        if self.limit != 0 {
            os.write_uint64(2, self.limit)?;
        }
        if self.prop_flag != false {
            os.write_bool(3, self.prop_flag)?;
        }
        for v in &self.prop_ids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputCondition {
        OutputCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dedup_prop_ids",
                    |m: &OutputCondition| { &m.dedup_prop_ids },
                    |m: &mut OutputCondition| { &mut m.dedup_prop_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &OutputCondition| { &m.limit },
                    |m: &mut OutputCondition| { &mut m.limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "prop_flag",
                    |m: &OutputCondition| { &m.prop_flag },
                    |m: &mut OutputCondition| { &mut m.prop_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "prop_ids",
                    |m: &OutputCondition| { &m.prop_ids },
                    |m: &mut OutputCondition| { &mut m.prop_ids },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OutputCondition>(
                    "OutputCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OutputCondition {
        static mut instance: ::protobuf::lazy::Lazy<OutputCondition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OutputCondition,
        };
        unsafe {
            instance.get(OutputCondition::new)
        }
    }
}

impl ::protobuf::Clear for OutputCondition {
    fn clear(&mut self) {
        self.clear_dedup_prop_ids();
        self.clear_limit();
        self.clear_prop_flag();
        self.clear_prop_ids();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeId {
    // message fields
    pub src_id: i64,
    pub dst_id: i64,
    pub inner_id: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeId {
    pub fn new() -> EdgeId {
        ::std::default::Default::default()
    }

    // int64 src_id = 1;

    pub fn clear_src_id(&mut self) {
        self.src_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: i64) {
        self.src_id = v;
    }

    pub fn get_src_id(&self) -> i64 {
        self.src_id
    }

    // int64 dst_id = 2;

    pub fn clear_dst_id(&mut self) {
        self.dst_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: i64) {
        self.dst_id = v;
    }

    pub fn get_dst_id(&self) -> i64 {
        self.dst_id
    }

    // int64 inner_id = 3;

    pub fn clear_inner_id(&mut self) {
        self.inner_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_inner_id(&mut self, v: i64) {
        self.inner_id = v;
    }

    pub fn get_inner_id(&self) -> i64 {
        self.inner_id
    }
}

impl ::protobuf::Message for EdgeId {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.src_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dst_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.inner_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.src_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.src_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dst_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.inner_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.inner_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.src_id != 0 {
            os.write_int64(1, self.src_id)?;
        }
        if self.dst_id != 0 {
            os.write_int64(2, self.dst_id)?;
        }
        if self.inner_id != 0 {
            os.write_int64(3, self.inner_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeId {
        EdgeId::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "src_id",
                    |m: &EdgeId| { &m.src_id },
                    |m: &mut EdgeId| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dst_id",
                    |m: &EdgeId| { &m.dst_id },
                    |m: &mut EdgeId| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "inner_id",
                    |m: &EdgeId| { &m.inner_id },
                    |m: &mut EdgeId| { &mut m.inner_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeId>(
                    "EdgeId",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeId {
        static mut instance: ::protobuf::lazy::Lazy<EdgeId> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeId,
        };
        unsafe {
            instance.get(EdgeId::new)
        }
    }
}

impl ::protobuf::Clear for EdgeId {
    fn clear(&mut self) {
        self.clear_src_id();
        self.clear_dst_id();
        self.clear_inner_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeId {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeType {
    // message fields
    pub label: u32,
    pub src_label: u32,
    pub dst_label: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeType {
    pub fn new() -> EdgeType {
        ::std::default::Default::default()
    }

    // uint32 label = 1;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // uint32 src_label = 2;

    pub fn clear_src_label(&mut self) {
        self.src_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_label(&mut self, v: u32) {
        self.src_label = v;
    }

    pub fn get_src_label(&self) -> u32 {
        self.src_label
    }

    // uint32 dst_label = 3;

    pub fn clear_dst_label(&mut self) {
        self.dst_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_label(&mut self, v: u32) {
        self.dst_label = v;
    }

    pub fn get_dst_label(&self) -> u32 {
        self.dst_label
    }
}

impl ::protobuf::Message for EdgeType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_label = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_label = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(1, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dst_label, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.label != 0 {
            os.write_uint32(1, self.label)?;
        }
        if self.src_label != 0 {
            os.write_uint32(2, self.src_label)?;
        }
        if self.dst_label != 0 {
            os.write_uint32(3, self.dst_label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeType {
        EdgeType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &EdgeType| { &m.label },
                    |m: &mut EdgeType| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "src_label",
                    |m: &EdgeType| { &m.src_label },
                    |m: &mut EdgeType| { &mut m.src_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dst_label",
                    |m: &EdgeType| { &m.dst_label },
                    |m: &mut EdgeType| { &mut m.dst_label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeType>(
                    "EdgeType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeType {
        static mut instance: ::protobuf::lazy::Lazy<EdgeType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeType,
        };
        unsafe {
            instance.get(EdgeType::new)
        }
    }
}

impl ::protobuf::Clear for EdgeType {
    fn clear(&mut self) {
        self.clear_label();
        self.clear_src_label();
        self.clear_dst_label();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10remote_api.proto\x12\ttinkerpop\x1a\x13gremlin_query.proto\x1a\x11\
    sdk/message.proto\x1a\x12meta_service.proto\x1a\x0fstore_api.proto\"\xbd\
    \x02\n\x19BatchVerticesEdgesRequest\x12\x1f\n\x0bsnapshot_id\x18\x01\x20\
    \x01(\x03R\nsnapshotId\x12\x1b\n\tvertex_id\x18\x02\x20\x03(\x03R\x08ver\
    texId\x12\x1d\n\nlabel_list\x18\x03\x20\x03(\rR\tlabelList\x12A\n\x0flog\
    ical_compare\x18\x04\x20\x03(\x0b2\x18.maxgraph.LogicalCompareR\x0elogic\
    alCompare\x12:\n\nconditions\x18\x05\x20\x01(\x0b2\x1a.tinkerpop.OutputC\
    onditionR\nconditions\x12\x1f\n\x0bvertex_flag\x18\x06\x20\x01(\x08R\nve\
    rtexFlag\x12#\n\rpartition_ids\x18\x07\x20\x03(\rR\x0cpartitionIds\"\xba\
    \x01\n\x1aBatchVerticesEdgesResponse\x12*\n\x06src_id\x18\x01\x20\x01(\
    \x0b2\x13.tinkerpop.VertexIdR\x05srcId\x12*\n\x06dst_id\x18\x02\x20\x01(\
    \x0b2\x13.tinkerpop.VertexIdR\x05dstId\x12\x17\n\x07edge_id\x18\x03\x20\
    \x01(\x03R\x06edgeId\x12\x17\n\x07type_id\x18\x04\x20\x01(\rR\x06typeId\
    \x12\x12\n\x04pros\x18\x05\x20\x01(\x0cR\x04pros\"K\n\x1aBatchVerticesCo\
    untResponse\x12\x10\n\x03vid\x18\x01\x20\x01(\x03R\x03vid\x12\x1b\n\tcou\
    nt_val\x18\x02\x20\x01(\x03R\x08countVal\"\x95\x01\n\x0fVerticesRequest\
    \x12\x1f\n\x0bsnapshot_id\x18\x01\x20\x01(\x03R\nsnapshotId\x12\x17\n\
    \x07type_id\x18\x02\x20\x01(\rR\x06typeId\x12\x10\n\x03ids\x18\x03\x20\
    \x03(\x03R\x03ids\x12\x19\n\x08prop_ids\x18\x04\x20\x03(\x05R\x07propIds\
    \x12\x1b\n\tprop_flag\x18\x05\x20\x01(\x08R\x08propFlag\"\xbf\x01\n\x11G\
    raphEdgesRequest\x12\x1f\n\x0bsnapshot_id\x18\x01\x20\x01(\x03R\nsnapsho\
    tId\x12,\n\x07type_id\x18\x02\x20\x01(\x0b2\x13.tinkerpop.EdgeTypeR\x06t\
    ypeId\x12#\n\x03ids\x18\x03\x20\x03(\x0b2\x11.tinkerpop.EdgeIdR\x03ids\
    \x12\x19\n\x08prop_ids\x18\x04\x20\x03(\x05R\x07propIds\x12\x1b\n\tprop_\
    flag\x18\x05\x20\x01(\x08R\x08propFlag\"\xee\x01\n\x0cQueryRequest\x12\
    \x1f\n\x0bsnapshot_id\x18\x01\x20\x01(\x03R\nsnapshotId\x12\x19\n\x08lab\
    el_id\x18\x02\x20\x03(\rR\x07labelId\x12A\n\x0flogical_compare\x18\x03\
    \x20\x03(\x0b2\x18.maxgraph.LogicalCompareR\x0elogicalCompare\x12:\n\nco\
    nditions\x18\x04\x20\x01(\x0b2\x1a.tinkerpop.OutputConditionR\ncondition\
    s\x12#\n\rpartition_ids\x18\x05\x20\x03(\rR\x0cpartitionIds\"\xb7\x01\n\
    \x11QueryCountRequest\x12\x1f\n\x0bsnapshot_id\x18\x01\x20\x01(\x03R\nsn\
    apshotId\x12\x19\n\x08label_id\x18\x02\x20\x03(\rR\x07labelId\x12A\n\x0f\
    logical_compare\x18\x03\x20\x03(\x0b2\x18.maxgraph.LogicalCompareR\x0elo\
    gicalCompare\x12#\n\rpartition_ids\x18\x04\x20\x03(\rR\x0cpartitionIds\"\
    ,\n\rCountResponse\x12\x1b\n\tcount_val\x18\x01\x20\x01(\x03R\x08countVa\
    l\"\x85\x01\n\x0fOutputCondition\x12$\n\x0ededup_prop_ids\x18\x01\x20\
    \x03(\rR\x0cdedupPropIds\x12\x14\n\x05limit\x18\x02\x20\x01(\x04R\x05lim\
    it\x12\x1b\n\tprop_flag\x18\x03\x20\x01(\x08R\x08propFlag\x12\x19\n\x08p\
    rop_ids\x18\x04\x20\x03(\rR\x07propIds\"Q\n\x06EdgeId\x12\x15\n\x06src_i\
    d\x18\x01\x20\x01(\x03R\x05srcId\x12\x15\n\x06dst_id\x18\x02\x20\x01(\
    \x03R\x05dstId\x12\x19\n\x08inner_id\x18\x03\x20\x01(\x03R\x07innerId\"Z\
    \n\x08EdgeType\x12\x14\n\x05label\x18\x01\x20\x01(\rR\x05label\x12\x1b\n\
    \tsrc_label\x18\x02\x20\x01(\rR\x08srcLabel\x12\x1b\n\tdst_label\x18\x03\
    \x20\x01(\rR\x08dstLabel2\xc3\x06\n\x12RemoteStoreService\x12\\\n\x0bget\
    BatchOut\x12$.tinkerpop.BatchVerticesEdgesRequest\x1a%.tinkerpop.BatchVe\
    rticesEdgesResponse0\x01\x12[\n\ngetBatchIn\x12$.tinkerpop.BatchVertices\
    EdgesRequest\x1a%.tinkerpop.BatchVerticesEdgesResponse0\x01\x12_\n\x0ege\
    tBatchOutCnt\x12$.tinkerpop.BatchVerticesEdgesRequest\x1a%.tinkerpop.Bat\
    chVerticesCountResponse0\x01\x12^\n\rgetBatchInCnt\x12$.tinkerpop.BatchV\
    erticesEdgesRequest\x1a%.tinkerpop.BatchVerticesCountResponse0\x01\x12F\
    \n\x0bgetVertices\x12\x1a.tinkerpop.VerticesRequest\x1a\x19.tinkerpop.Ve\
    rtexResponse0\x01\x12L\n\rgetGraphEdges\x12\x1c.tinkerpop.GraphEdgesRequ\
    est\x1a\x1b.tinkerpop.GraphEdgeReponse0\x01\x12F\n\x0equery_vertices\x12\
    \x17.tinkerpop.QueryRequest\x1a\x19.tinkerpop.VertexResponse0\x01\x12E\n\
    \x0bquery_edges\x12\x17.tinkerpop.QueryRequest\x1a\x1b.tinkerpop.GraphEd\
    geReponse0\x01\x12F\n\x0cvertex_count\x12\x1c.tinkerpop.QueryCountReques\
    t\x1a\x18.tinkerpop.CountResponse\x12D\n\nedge_count\x12\x1c.tinkerpop.Q\
    ueryCountRequest\x1a\x18.tinkerpop.CountResponseB\x1c\n\x1acom.alibaba.m\
    axgraph.protob\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
