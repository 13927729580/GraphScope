//
//! Copyright 2020 Alibaba Group Holding Limited.
//! 
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//! 
//!     http://www.apache.org/licenses/LICENSE-2.0
//! 
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct StoreTestProperty {
    // message fields
    pub id: i32,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StoreTestProperty {
    pub fn new() -> StoreTestProperty {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }

    // bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for StoreTestProperty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreTestProperty {
        StoreTestProperty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &StoreTestProperty| { &m.id },
                    |m: &mut StoreTestProperty| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &StoreTestProperty| { &m.data },
                    |m: &mut StoreTestProperty| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StoreTestProperty>(
                    "StoreTestProperty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StoreTestProperty {
        static mut instance: ::protobuf::lazy::Lazy<StoreTestProperty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoreTestProperty,
        };
        unsafe {
            instance.get(StoreTestProperty::new)
        }
    }
}

impl ::protobuf::Clear for StoreTestProperty {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoreTestProperty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreTestProperty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StoreTestVertex {
    // message fields
    pub vertex_id: i64,
    pub label: i32,
    pub properies: ::protobuf::RepeatedField<StoreTestProperty>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StoreTestVertex {
    pub fn new() -> StoreTestVertex {
        ::std::default::Default::default()
    }

    // int64 vertex_id = 1;

    pub fn clear_vertex_id(&mut self) {
        self.vertex_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_vertex_id(&mut self, v: i64) {
        self.vertex_id = v;
    }

    pub fn get_vertex_id(&self) -> i64 {
        self.vertex_id
    }

    // int32 label = 2;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: i32) {
        self.label = v;
    }

    pub fn get_label(&self) -> i32 {
        self.label
    }

    // repeated .StoreTestProperty properies = 3;

    pub fn clear_properies(&mut self) {
        self.properies.clear();
    }

    // Param is passed by value, moved
    pub fn set_properies(&mut self, v: ::protobuf::RepeatedField<StoreTestProperty>) {
        self.properies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properies(&mut self) -> &mut ::protobuf::RepeatedField<StoreTestProperty> {
        &mut self.properies
    }

    // Take field
    pub fn take_properies(&mut self) -> ::protobuf::RepeatedField<StoreTestProperty> {
        ::std::mem::replace(&mut self.properies, ::protobuf::RepeatedField::new())
    }

    pub fn get_properies(&self) -> &[StoreTestProperty] {
        &self.properies
    }
}

impl ::protobuf::Message for StoreTestVertex {
    fn is_initialized(&self) -> bool {
        for v in &self.properies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vertex_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.vertex_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.vertex_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.properies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.vertex_id != 0 {
            os.write_int64(1, self.vertex_id)?;
        }
        if self.label != 0 {
            os.write_int32(2, self.label)?;
        }
        for v in &self.properies {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreTestVertex {
        StoreTestVertex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vertex_id",
                    |m: &StoreTestVertex| { &m.vertex_id },
                    |m: &mut StoreTestVertex| { &mut m.vertex_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label",
                    |m: &StoreTestVertex| { &m.label },
                    |m: &mut StoreTestVertex| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StoreTestProperty>>(
                    "properies",
                    |m: &StoreTestVertex| { &m.properies },
                    |m: &mut StoreTestVertex| { &mut m.properies },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StoreTestVertex>(
                    "StoreTestVertex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StoreTestVertex {
        static mut instance: ::protobuf::lazy::Lazy<StoreTestVertex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoreTestVertex,
        };
        unsafe {
            instance.get(StoreTestVertex::new)
        }
    }
}

impl ::protobuf::Clear for StoreTestVertex {
    fn clear(&mut self) {
        self.clear_vertex_id();
        self.clear_label();
        self.clear_properies();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoreTestVertex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreTestVertex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyProto {
    // message fields
    pub id: u32,
    pub data: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PropertyProto {
    pub fn new() -> PropertyProto {
        ::std::default::Default::default()
    }

    // uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    pub fn get_id(&self) -> u32 {
        self.id
    }

    // bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for PropertyProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyProto {
        PropertyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &PropertyProto| { &m.id },
                    |m: &mut PropertyProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &PropertyProto| { &m.data },
                    |m: &mut PropertyProto| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PropertyProto>(
                    "PropertyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PropertyProto {
        static mut instance: ::protobuf::lazy::Lazy<PropertyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PropertyProto,
        };
        unsafe {
            instance.get(PropertyProto::new)
        }
    }
}

impl ::protobuf::Clear for PropertyProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetVertexRequest {
    // message fields
    pub id: ::std::vec::Vec<i64>,
    pub label: u32,
    pub snapshot_id: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetVertexRequest {
    pub fn new() -> GetVertexRequest {
        ::std::default::Default::default()
    }

    // repeated int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::vec::Vec<i64>) {
        self.id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.id, ::std::vec::Vec::new())
    }

    pub fn get_id(&self) -> &[i64] {
        &self.id
    }

    // uint32 label = 2;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // int64 snapshot_id = 3;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }
}

impl ::protobuf::Message for GetVertexRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.id {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.id {
            os.write_int64(1, *v)?;
        };
        if self.label != 0 {
            os.write_uint32(2, self.label)?;
        }
        if self.snapshot_id != 0 {
            os.write_int64(3, self.snapshot_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetVertexRequest {
        GetVertexRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &GetVertexRequest| { &m.id },
                    |m: &mut GetVertexRequest| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &GetVertexRequest| { &m.label },
                    |m: &mut GetVertexRequest| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetVertexRequest| { &m.snapshot_id },
                    |m: &mut GetVertexRequest| { &mut m.snapshot_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetVertexRequest>(
                    "GetVertexRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetVertexRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetVertexRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetVertexRequest,
        };
        unsafe {
            instance.get(GetVertexRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetVertexRequest {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_label();
        self.clear_snapshot_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetVertexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetVertexRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexProto {
    // message fields
    pub id: i64,
    pub label: u32,
    pub start_si: i64,
    pub end_si: i64,
    pub properties: ::protobuf::RepeatedField<PropertyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VertexProto {
    pub fn new() -> VertexProto {
        ::std::default::Default::default()
    }

    // int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }

    // uint32 label = 2;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // int64 start_si = 3;

    pub fn clear_start_si(&mut self) {
        self.start_si = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_si(&mut self, v: i64) {
        self.start_si = v;
    }

    pub fn get_start_si(&self) -> i64 {
        self.start_si
    }

    // int64 end_si = 4;

    pub fn clear_end_si(&mut self) {
        self.end_si = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_si(&mut self, v: i64) {
        self.end_si = v;
    }

    pub fn get_end_si(&self) -> i64 {
        self.end_si
    }

    // repeated .PropertyProto properties = 5;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<PropertyProto>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<PropertyProto> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<PropertyProto> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[PropertyProto] {
        &self.properties
    }
}

impl ::protobuf::Message for VertexProto {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_si = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_si = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.start_si != 0 {
            my_size += ::protobuf::rt::value_size(3, self.start_si, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_si != 0 {
            my_size += ::protobuf::rt::value_size(4, self.end_si, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if self.label != 0 {
            os.write_uint32(2, self.label)?;
        }
        if self.start_si != 0 {
            os.write_int64(3, self.start_si)?;
        }
        if self.end_si != 0 {
            os.write_int64(4, self.end_si)?;
        }
        for v in &self.properties {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexProto {
        VertexProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &VertexProto| { &m.id },
                    |m: &mut VertexProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &VertexProto| { &m.label },
                    |m: &mut VertexProto| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "start_si",
                    |m: &VertexProto| { &m.start_si },
                    |m: &mut VertexProto| { &mut m.start_si },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "end_si",
                    |m: &VertexProto| { &m.end_si },
                    |m: &mut VertexProto| { &mut m.end_si },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyProto>>(
                    "properties",
                    |m: &VertexProto| { &m.properties },
                    |m: &mut VertexProto| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VertexProto>(
                    "VertexProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexProto {
        static mut instance: ::protobuf::lazy::Lazy<VertexProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VertexProto,
        };
        unsafe {
            instance.get(VertexProto::new)
        }
    }
}

impl ::protobuf::Clear for VertexProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_label();
        self.clear_start_si();
        self.clear_end_si();
        self.clear_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelationProto {
    // message fields
    pub label: u32,
    pub src_label: u32,
    pub dst_label: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RelationProto {
    pub fn new() -> RelationProto {
        ::std::default::Default::default()
    }

    // uint32 label = 1;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // uint32 src_label = 2;

    pub fn clear_src_label(&mut self) {
        self.src_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_label(&mut self, v: u32) {
        self.src_label = v;
    }

    pub fn get_src_label(&self) -> u32 {
        self.src_label
    }

    // uint32 dst_label = 3;

    pub fn clear_dst_label(&mut self) {
        self.dst_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_label(&mut self, v: u32) {
        self.dst_label = v;
    }

    pub fn get_dst_label(&self) -> u32 {
        self.dst_label
    }
}

impl ::protobuf::Message for RelationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_label = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_label = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(1, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dst_label, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.label != 0 {
            os.write_uint32(1, self.label)?;
        }
        if self.src_label != 0 {
            os.write_uint32(2, self.src_label)?;
        }
        if self.dst_label != 0 {
            os.write_uint32(3, self.dst_label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelationProto {
        RelationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &RelationProto| { &m.label },
                    |m: &mut RelationProto| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "src_label",
                    |m: &RelationProto| { &m.src_label },
                    |m: &mut RelationProto| { &mut m.src_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dst_label",
                    |m: &RelationProto| { &m.dst_label },
                    |m: &mut RelationProto| { &mut m.dst_label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RelationProto>(
                    "RelationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RelationProto {
        static mut instance: ::protobuf::lazy::Lazy<RelationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RelationProto,
        };
        unsafe {
            instance.get(RelationProto::new)
        }
    }
}

impl ::protobuf::Clear for RelationProto {
    fn clear(&mut self) {
        self.clear_label();
        self.clear_src_label();
        self.clear_dst_label();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeProto {
    // message fields
    pub id: i64,
    pub src_id: i64,
    pub dst_id: i64,
    pub relation: ::protobuf::SingularPtrField<RelationProto>,
    pub start_si: i64,
    pub end_si: i64,
    pub properties: ::protobuf::RepeatedField<PropertyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeProto {
    pub fn new() -> EdgeProto {
        ::std::default::Default::default()
    }

    // int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }

    // int64 src_id = 2;

    pub fn clear_src_id(&mut self) {
        self.src_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: i64) {
        self.src_id = v;
    }

    pub fn get_src_id(&self) -> i64 {
        self.src_id
    }

    // int64 dst_id = 3;

    pub fn clear_dst_id(&mut self) {
        self.dst_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: i64) {
        self.dst_id = v;
    }

    pub fn get_dst_id(&self) -> i64 {
        self.dst_id
    }

    // .RelationProto relation = 4;

    pub fn clear_relation(&mut self) {
        self.relation.clear();
    }

    pub fn has_relation(&self) -> bool {
        self.relation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relation(&mut self, v: RelationProto) {
        self.relation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relation(&mut self) -> &mut RelationProto {
        if self.relation.is_none() {
            self.relation.set_default();
        }
        self.relation.as_mut().unwrap()
    }

    // Take field
    pub fn take_relation(&mut self) -> RelationProto {
        self.relation.take().unwrap_or_else(|| RelationProto::new())
    }

    pub fn get_relation(&self) -> &RelationProto {
        self.relation.as_ref().unwrap_or_else(|| RelationProto::default_instance())
    }

    // int64 start_si = 5;

    pub fn clear_start_si(&mut self) {
        self.start_si = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_si(&mut self, v: i64) {
        self.start_si = v;
    }

    pub fn get_start_si(&self) -> i64 {
        self.start_si
    }

    // int64 end_si = 6;

    pub fn clear_end_si(&mut self) {
        self.end_si = 0;
    }

    // Param is passed by value, moved
    pub fn set_end_si(&mut self, v: i64) {
        self.end_si = v;
    }

    pub fn get_end_si(&self) -> i64 {
        self.end_si
    }

    // repeated .PropertyProto properties = 7;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<PropertyProto>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<PropertyProto> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<PropertyProto> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[PropertyProto] {
        &self.properties
    }
}

impl ::protobuf::Message for EdgeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.relation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.src_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dst_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.relation)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start_si = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end_si = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dst_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.relation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.start_si != 0 {
            my_size += ::protobuf::rt::value_size(5, self.start_si, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.end_si != 0 {
            my_size += ::protobuf::rt::value_size(6, self.end_si, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if self.src_id != 0 {
            os.write_int64(2, self.src_id)?;
        }
        if self.dst_id != 0 {
            os.write_int64(3, self.dst_id)?;
        }
        if let Some(ref v) = self.relation.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.start_si != 0 {
            os.write_int64(5, self.start_si)?;
        }
        if self.end_si != 0 {
            os.write_int64(6, self.end_si)?;
        }
        for v in &self.properties {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeProto {
        EdgeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &EdgeProto| { &m.id },
                    |m: &mut EdgeProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "src_id",
                    |m: &EdgeProto| { &m.src_id },
                    |m: &mut EdgeProto| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dst_id",
                    |m: &EdgeProto| { &m.dst_id },
                    |m: &mut EdgeProto| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RelationProto>>(
                    "relation",
                    |m: &EdgeProto| { &m.relation },
                    |m: &mut EdgeProto| { &mut m.relation },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "start_si",
                    |m: &EdgeProto| { &m.start_si },
                    |m: &mut EdgeProto| { &mut m.start_si },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "end_si",
                    |m: &EdgeProto| { &m.end_si },
                    |m: &mut EdgeProto| { &mut m.end_si },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyProto>>(
                    "properties",
                    |m: &EdgeProto| { &m.properties },
                    |m: &mut EdgeProto| { &mut m.properties },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeProto>(
                    "EdgeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeProto {
        static mut instance: ::protobuf::lazy::Lazy<EdgeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeProto,
        };
        unsafe {
            instance.get(EdgeProto::new)
        }
    }
}

impl ::protobuf::Clear for EdgeProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_src_id();
        self.clear_dst_id();
        self.clear_relation();
        self.clear_start_si();
        self.clear_end_si();
        self.clear_properties();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOutEdgesRequest {
    // message fields
    pub src_id: i64,
    pub snapshot_id: i64,
    pub label: u32,
    pub limit: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetOutEdgesRequest {
    pub fn new() -> GetOutEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 src_id = 1;

    pub fn clear_src_id(&mut self) {
        self.src_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: i64) {
        self.src_id = v;
    }

    pub fn get_src_id(&self) -> i64 {
        self.src_id
    }

    // int64 snapshot_id = 2;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // uint32 label = 3;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // uint64 limit = 4;

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    pub fn get_limit(&self) -> u64 {
        self.limit
    }
}

impl ::protobuf::Message for GetOutEdgesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.src_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.src_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.src_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.src_id != 0 {
            os.write_int64(1, self.src_id)?;
        }
        if self.snapshot_id != 0 {
            os.write_int64(2, self.snapshot_id)?;
        }
        if self.label != 0 {
            os.write_uint32(3, self.label)?;
        }
        if self.limit != 0 {
            os.write_uint64(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOutEdgesRequest {
        GetOutEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "src_id",
                    |m: &GetOutEdgesRequest| { &m.src_id },
                    |m: &mut GetOutEdgesRequest| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetOutEdgesRequest| { &m.snapshot_id },
                    |m: &mut GetOutEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &GetOutEdgesRequest| { &m.label },
                    |m: &mut GetOutEdgesRequest| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &GetOutEdgesRequest| { &m.limit },
                    |m: &mut GetOutEdgesRequest| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetOutEdgesRequest>(
                    "GetOutEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetOutEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetOutEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetOutEdgesRequest,
        };
        unsafe {
            instance.get(GetOutEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetOutEdgesRequest {
    fn clear(&mut self) {
        self.clear_src_id();
        self.clear_snapshot_id();
        self.clear_label();
        self.clear_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOutEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOutEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInEdgesRequest {
    // message fields
    pub dst_id: i64,
    pub snapshot_id: i64,
    pub label: u32,
    pub limit: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetInEdgesRequest {
    pub fn new() -> GetInEdgesRequest {
        ::std::default::Default::default()
    }

    // int64 dst_id = 1;

    pub fn clear_dst_id(&mut self) {
        self.dst_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: i64) {
        self.dst_id = v;
    }

    pub fn get_dst_id(&self) -> i64 {
        self.dst_id
    }

    // int64 snapshot_id = 2;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // uint32 label = 3;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // uint64 limit = 4;

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    pub fn get_limit(&self) -> u64 {
        self.limit
    }
}

impl ::protobuf::Message for GetInEdgesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dst_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dst_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dst_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.dst_id != 0 {
            os.write_int64(1, self.dst_id)?;
        }
        if self.snapshot_id != 0 {
            os.write_int64(2, self.snapshot_id)?;
        }
        if self.label != 0 {
            os.write_uint32(3, self.label)?;
        }
        if self.limit != 0 {
            os.write_uint64(4, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInEdgesRequest {
        GetInEdgesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dst_id",
                    |m: &GetInEdgesRequest| { &m.dst_id },
                    |m: &mut GetInEdgesRequest| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &GetInEdgesRequest| { &m.snapshot_id },
                    |m: &mut GetInEdgesRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &GetInEdgesRequest| { &m.label },
                    |m: &mut GetInEdgesRequest| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &GetInEdgesRequest| { &m.limit },
                    |m: &mut GetInEdgesRequest| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInEdgesRequest>(
                    "GetInEdgesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInEdgesRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetInEdgesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInEdgesRequest,
        };
        unsafe {
            instance.get(GetInEdgesRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetInEdgesRequest {
    fn clear(&mut self) {
        self.clear_dst_id();
        self.clear_snapshot_id();
        self.clear_label();
        self.clear_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInEdgesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInEdgesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScanVertexRequest {
    // message fields
    pub label: u32,
    pub snapshot_id: i64,
    pub limit: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ScanVertexRequest {
    pub fn new() -> ScanVertexRequest {
        ::std::default::Default::default()
    }

    // uint32 label = 1;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // int64 snapshot_id = 2;

    pub fn clear_snapshot_id(&mut self) {
        self.snapshot_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot_id(&mut self, v: i64) {
        self.snapshot_id = v;
    }

    pub fn get_snapshot_id(&self) -> i64 {
        self.snapshot_id
    }

    // uint64 limit = 3;

    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u64) {
        self.limit = v;
    }

    pub fn get_limit(&self) -> u64 {
        self.limit
    }
}

impl ::protobuf::Message for ScanVertexRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(1, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.snapshot_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.snapshot_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.label != 0 {
            os.write_uint32(1, self.label)?;
        }
        if self.snapshot_id != 0 {
            os.write_int64(2, self.snapshot_id)?;
        }
        if self.limit != 0 {
            os.write_uint64(3, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScanVertexRequest {
        ScanVertexRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &ScanVertexRequest| { &m.label },
                    |m: &mut ScanVertexRequest| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot_id",
                    |m: &ScanVertexRequest| { &m.snapshot_id },
                    |m: &mut ScanVertexRequest| { &mut m.snapshot_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "limit",
                    |m: &ScanVertexRequest| { &m.limit },
                    |m: &mut ScanVertexRequest| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScanVertexRequest>(
                    "ScanVertexRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ScanVertexRequest {
        static mut instance: ::protobuf::lazy::Lazy<ScanVertexRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScanVertexRequest,
        };
        unsafe {
            instance.get(ScanVertexRequest::new)
        }
    }
}

impl ::protobuf::Clear for ScanVertexRequest {
    fn clear(&mut self) {
        self.clear_label();
        self.clear_snapshot_id();
        self.clear_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScanVertexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScanVertexRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetSchemaRequest {
    // message fields
    pub version: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GetSchemaRequest {
    pub fn new() -> GetSchemaRequest {
        ::std::default::Default::default()
    }

    // int32 version = 1;

    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    pub fn get_version(&self) -> i32 {
        self.version
    }
}

impl ::protobuf::Message for GetSchemaRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_int32(1, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetSchemaRequest {
        GetSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &GetSchemaRequest| { &m.version },
                    |m: &mut GetSchemaRequest| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetSchemaRequest>(
                    "GetSchemaRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetSchemaRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetSchemaRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetSchemaRequest,
        };
        unsafe {
            instance.get(GetSchemaRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetSchemaRequest {
    fn clear(&mut self) {
        self.clear_version();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StoreTestResponse {
    // message fields
    pub vertices: ::protobuf::RepeatedField<StoreTestVertex>,
    pub edges: ::protobuf::RepeatedField<StoreTestEdge>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StoreTestResponse {
    pub fn new() -> StoreTestResponse {
        ::std::default::Default::default()
    }

    // repeated .StoreTestVertex vertices = 1;

    pub fn clear_vertices(&mut self) {
        self.vertices.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertices(&mut self, v: ::protobuf::RepeatedField<StoreTestVertex>) {
        self.vertices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertices(&mut self) -> &mut ::protobuf::RepeatedField<StoreTestVertex> {
        &mut self.vertices
    }

    // Take field
    pub fn take_vertices(&mut self) -> ::protobuf::RepeatedField<StoreTestVertex> {
        ::std::mem::replace(&mut self.vertices, ::protobuf::RepeatedField::new())
    }

    pub fn get_vertices(&self) -> &[StoreTestVertex] {
        &self.vertices
    }

    // repeated .StoreTestEdge edges = 2;

    pub fn clear_edges(&mut self) {
        self.edges.clear();
    }

    // Param is passed by value, moved
    pub fn set_edges(&mut self, v: ::protobuf::RepeatedField<StoreTestEdge>) {
        self.edges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edges(&mut self) -> &mut ::protobuf::RepeatedField<StoreTestEdge> {
        &mut self.edges
    }

    // Take field
    pub fn take_edges(&mut self) -> ::protobuf::RepeatedField<StoreTestEdge> {
        ::std::mem::replace(&mut self.edges, ::protobuf::RepeatedField::new())
    }

    pub fn get_edges(&self) -> &[StoreTestEdge] {
        &self.edges
    }
}

impl ::protobuf::Message for StoreTestResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.vertices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vertices)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vertices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vertices {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreTestResponse {
        StoreTestResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StoreTestVertex>>(
                    "vertices",
                    |m: &StoreTestResponse| { &m.vertices },
                    |m: &mut StoreTestResponse| { &mut m.vertices },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StoreTestEdge>>(
                    "edges",
                    |m: &StoreTestResponse| { &m.edges },
                    |m: &mut StoreTestResponse| { &mut m.edges },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StoreTestResponse>(
                    "StoreTestResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StoreTestResponse {
        static mut instance: ::protobuf::lazy::Lazy<StoreTestResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoreTestResponse,
        };
        unsafe {
            instance.get(StoreTestResponse::new)
        }
    }
}

impl ::protobuf::Clear for StoreTestResponse {
    fn clear(&mut self) {
        self.clear_vertices();
        self.clear_edges();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoreTestResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreTestResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerInfo {
    // message fields
    pub work_id: u32,
    pub zk_url: ::std::string::String,
    pub graph_name: ::std::string::String,
    pub partition_num: u32,
    pub download_thread_count: u32,
    pub load_thread_count: u32,
    pub local_data_root: ::std::string::String,
    pub listened_port: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ServerInfo {
    pub fn new() -> ServerInfo {
        ::std::default::Default::default()
    }

    // uint32 work_id = 1;

    pub fn clear_work_id(&mut self) {
        self.work_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_work_id(&mut self, v: u32) {
        self.work_id = v;
    }

    pub fn get_work_id(&self) -> u32 {
        self.work_id
    }

    // string zk_url = 2;

    pub fn clear_zk_url(&mut self) {
        self.zk_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_zk_url(&mut self, v: ::std::string::String) {
        self.zk_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zk_url(&mut self) -> &mut ::std::string::String {
        &mut self.zk_url
    }

    // Take field
    pub fn take_zk_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zk_url, ::std::string::String::new())
    }

    pub fn get_zk_url(&self) -> &str {
        &self.zk_url
    }

    // string graph_name = 3;

    pub fn clear_graph_name(&mut self) {
        self.graph_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_name(&mut self, v: ::std::string::String) {
        self.graph_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_name(&mut self) -> &mut ::std::string::String {
        &mut self.graph_name
    }

    // Take field
    pub fn take_graph_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_name, ::std::string::String::new())
    }

    pub fn get_graph_name(&self) -> &str {
        &self.graph_name
    }

    // uint32 partition_num = 4;

    pub fn clear_partition_num(&mut self) {
        self.partition_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_partition_num(&mut self, v: u32) {
        self.partition_num = v;
    }

    pub fn get_partition_num(&self) -> u32 {
        self.partition_num
    }

    // uint32 download_thread_count = 5;

    pub fn clear_download_thread_count(&mut self) {
        self.download_thread_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_download_thread_count(&mut self, v: u32) {
        self.download_thread_count = v;
    }

    pub fn get_download_thread_count(&self) -> u32 {
        self.download_thread_count
    }

    // uint32 load_thread_count = 6;

    pub fn clear_load_thread_count(&mut self) {
        self.load_thread_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_load_thread_count(&mut self, v: u32) {
        self.load_thread_count = v;
    }

    pub fn get_load_thread_count(&self) -> u32 {
        self.load_thread_count
    }

    // string local_data_root = 7;

    pub fn clear_local_data_root(&mut self) {
        self.local_data_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_data_root(&mut self, v: ::std::string::String) {
        self.local_data_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_data_root(&mut self) -> &mut ::std::string::String {
        &mut self.local_data_root
    }

    // Take field
    pub fn take_local_data_root(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_data_root, ::std::string::String::new())
    }

    pub fn get_local_data_root(&self) -> &str {
        &self.local_data_root
    }

    // uint32 listened_port = 8;

    pub fn clear_listened_port(&mut self) {
        self.listened_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_listened_port(&mut self, v: u32) {
        self.listened_port = v;
    }

    pub fn get_listened_port(&self) -> u32 {
        self.listened_port
    }
}

impl ::protobuf::Message for ServerInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.work_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zk_url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partition_num = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.download_thread_count = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.load_thread_count = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_data_root)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.listened_port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.work_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.work_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.zk_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zk_url);
        }
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.graph_name);
        }
        if self.partition_num != 0 {
            my_size += ::protobuf::rt::value_size(4, self.partition_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.download_thread_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.download_thread_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.load_thread_count != 0 {
            my_size += ::protobuf::rt::value_size(6, self.load_thread_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.local_data_root.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.local_data_root);
        }
        if self.listened_port != 0 {
            my_size += ::protobuf::rt::value_size(8, self.listened_port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.work_id != 0 {
            os.write_uint32(1, self.work_id)?;
        }
        if !self.zk_url.is_empty() {
            os.write_string(2, &self.zk_url)?;
        }
        if !self.graph_name.is_empty() {
            os.write_string(3, &self.graph_name)?;
        }
        if self.partition_num != 0 {
            os.write_uint32(4, self.partition_num)?;
        }
        if self.download_thread_count != 0 {
            os.write_uint32(5, self.download_thread_count)?;
        }
        if self.load_thread_count != 0 {
            os.write_uint32(6, self.load_thread_count)?;
        }
        if !self.local_data_root.is_empty() {
            os.write_string(7, &self.local_data_root)?;
        }
        if self.listened_port != 0 {
            os.write_uint32(8, self.listened_port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerInfo {
        ServerInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "work_id",
                    |m: &ServerInfo| { &m.work_id },
                    |m: &mut ServerInfo| { &mut m.work_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "zk_url",
                    |m: &ServerInfo| { &m.zk_url },
                    |m: &mut ServerInfo| { &mut m.zk_url },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "graph_name",
                    |m: &ServerInfo| { &m.graph_name },
                    |m: &mut ServerInfo| { &mut m.graph_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partition_num",
                    |m: &ServerInfo| { &m.partition_num },
                    |m: &mut ServerInfo| { &mut m.partition_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "download_thread_count",
                    |m: &ServerInfo| { &m.download_thread_count },
                    |m: &mut ServerInfo| { &mut m.download_thread_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "load_thread_count",
                    |m: &ServerInfo| { &m.load_thread_count },
                    |m: &mut ServerInfo| { &mut m.load_thread_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "local_data_root",
                    |m: &ServerInfo| { &m.local_data_root },
                    |m: &mut ServerInfo| { &mut m.local_data_root },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "listened_port",
                    |m: &ServerInfo| { &m.listened_port },
                    |m: &mut ServerInfo| { &mut m.listened_port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerInfo>(
                    "ServerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ServerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerInfo,
        };
        unsafe {
            instance.get(ServerInfo::new)
        }
    }
}

impl ::protobuf::Clear for ServerInfo {
    fn clear(&mut self) {
        self.clear_work_id();
        self.clear_zk_url();
        self.clear_graph_name();
        self.clear_partition_num();
        self.clear_download_thread_count();
        self.clear_load_thread_count();
        self.clear_local_data_root();
        self.clear_listened_port();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StoreTestEdge {
    // message fields
    pub edge_id: i64,
    pub src_id: i64,
    pub dst_id: i64,
    pub label: i32,
    pub src_label: i32,
    pub dst_label: i32,
    pub properies: ::protobuf::RepeatedField<StoreTestProperty>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StoreTestEdge {
    pub fn new() -> StoreTestEdge {
        ::std::default::Default::default()
    }

    // int64 edge_id = 1;

    pub fn clear_edge_id(&mut self) {
        self.edge_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_id(&mut self, v: i64) {
        self.edge_id = v;
    }

    pub fn get_edge_id(&self) -> i64 {
        self.edge_id
    }

    // int64 src_id = 2;

    pub fn clear_src_id(&mut self) {
        self.src_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: i64) {
        self.src_id = v;
    }

    pub fn get_src_id(&self) -> i64 {
        self.src_id
    }

    // int64 dst_id = 3;

    pub fn clear_dst_id(&mut self) {
        self.dst_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: i64) {
        self.dst_id = v;
    }

    pub fn get_dst_id(&self) -> i64 {
        self.dst_id
    }

    // int32 label = 4;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: i32) {
        self.label = v;
    }

    pub fn get_label(&self) -> i32 {
        self.label
    }

    // int32 src_label = 5;

    pub fn clear_src_label(&mut self) {
        self.src_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_label(&mut self, v: i32) {
        self.src_label = v;
    }

    pub fn get_src_label(&self) -> i32 {
        self.src_label
    }

    // int32 dst_label = 6;

    pub fn clear_dst_label(&mut self) {
        self.dst_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_label(&mut self, v: i32) {
        self.dst_label = v;
    }

    pub fn get_dst_label(&self) -> i32 {
        self.dst_label
    }

    // repeated .StoreTestProperty properies = 7;

    pub fn clear_properies(&mut self) {
        self.properies.clear();
    }

    // Param is passed by value, moved
    pub fn set_properies(&mut self, v: ::protobuf::RepeatedField<StoreTestProperty>) {
        self.properies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properies(&mut self) -> &mut ::protobuf::RepeatedField<StoreTestProperty> {
        &mut self.properies
    }

    // Take field
    pub fn take_properies(&mut self) -> ::protobuf::RepeatedField<StoreTestProperty> {
        ::std::mem::replace(&mut self.properies, ::protobuf::RepeatedField::new())
    }

    pub fn get_properies(&self) -> &[StoreTestProperty] {
        &self.properies
    }
}

impl ::protobuf::Message for StoreTestEdge {
    fn is_initialized(&self) -> bool {
        for v in &self.properies {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.edge_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.src_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dst_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.src_label = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dst_label = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.edge_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.edge_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dst_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(4, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_label != 0 {
            my_size += ::protobuf::rt::value_size(5, self.src_label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_label != 0 {
            my_size += ::protobuf::rt::value_size(6, self.dst_label, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.properies {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.edge_id != 0 {
            os.write_int64(1, self.edge_id)?;
        }
        if self.src_id != 0 {
            os.write_int64(2, self.src_id)?;
        }
        if self.dst_id != 0 {
            os.write_int64(3, self.dst_id)?;
        }
        if self.label != 0 {
            os.write_int32(4, self.label)?;
        }
        if self.src_label != 0 {
            os.write_int32(5, self.src_label)?;
        }
        if self.dst_label != 0 {
            os.write_int32(6, self.dst_label)?;
        }
        for v in &self.properies {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StoreTestEdge {
        StoreTestEdge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "edge_id",
                    |m: &StoreTestEdge| { &m.edge_id },
                    |m: &mut StoreTestEdge| { &mut m.edge_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "src_id",
                    |m: &StoreTestEdge| { &m.src_id },
                    |m: &mut StoreTestEdge| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dst_id",
                    |m: &StoreTestEdge| { &m.dst_id },
                    |m: &mut StoreTestEdge| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label",
                    |m: &StoreTestEdge| { &m.label },
                    |m: &mut StoreTestEdge| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "src_label",
                    |m: &StoreTestEdge| { &m.src_label },
                    |m: &mut StoreTestEdge| { &mut m.src_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dst_label",
                    |m: &StoreTestEdge| { &m.dst_label },
                    |m: &mut StoreTestEdge| { &mut m.dst_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StoreTestProperty>>(
                    "properies",
                    |m: &StoreTestEdge| { &m.properies },
                    |m: &mut StoreTestEdge| { &mut m.properies },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StoreTestEdge>(
                    "StoreTestEdge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StoreTestEdge {
        static mut instance: ::protobuf::lazy::Lazy<StoreTestEdge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StoreTestEdge,
        };
        unsafe {
            instance.get(StoreTestEdge::new)
        }
    }
}

impl ::protobuf::Clear for StoreTestEdge {
    fn clear(&mut self) {
        self.clear_edge_id();
        self.clear_src_id();
        self.clear_dst_id();
        self.clear_label();
        self.clear_src_label();
        self.clear_dst_label();
        self.clear_properies();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StoreTestEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreTestEdge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GraphInfo {
    // message fields
    pub vertex_count: u64,
    pub edge_count: u64,
    pub active_partitions: ::std::vec::Vec<u32>,
    pub replicas: ::protobuf::RepeatedField<ReplicaInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl GraphInfo {
    pub fn new() -> GraphInfo {
        ::std::default::Default::default()
    }

    // uint64 vertex_count = 1;

    pub fn clear_vertex_count(&mut self) {
        self.vertex_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_vertex_count(&mut self, v: u64) {
        self.vertex_count = v;
    }

    pub fn get_vertex_count(&self) -> u64 {
        self.vertex_count
    }

    // uint64 edge_count = 2;

    pub fn clear_edge_count(&mut self) {
        self.edge_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_count(&mut self, v: u64) {
        self.edge_count = v;
    }

    pub fn get_edge_count(&self) -> u64 {
        self.edge_count
    }

    // repeated uint32 active_partitions = 3;

    pub fn clear_active_partitions(&mut self) {
        self.active_partitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_active_partitions(&mut self, v: ::std::vec::Vec<u32>) {
        self.active_partitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_active_partitions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.active_partitions
    }

    // Take field
    pub fn take_active_partitions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.active_partitions, ::std::vec::Vec::new())
    }

    pub fn get_active_partitions(&self) -> &[u32] {
        &self.active_partitions
    }

    // repeated .ReplicaInfo replicas = 4;

    pub fn clear_replicas(&mut self) {
        self.replicas.clear();
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: ::protobuf::RepeatedField<ReplicaInfo>) {
        self.replicas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replicas(&mut self) -> &mut ::protobuf::RepeatedField<ReplicaInfo> {
        &mut self.replicas
    }

    // Take field
    pub fn take_replicas(&mut self) -> ::protobuf::RepeatedField<ReplicaInfo> {
        ::std::mem::replace(&mut self.replicas, ::protobuf::RepeatedField::new())
    }

    pub fn get_replicas(&self) -> &[ReplicaInfo] {
        &self.replicas
    }
}

impl ::protobuf::Message for GraphInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.replicas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.vertex_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.edge_count = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.active_partitions)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.replicas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.vertex_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.vertex_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.edge_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.edge_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.active_partitions {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.replicas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.vertex_count != 0 {
            os.write_uint64(1, self.vertex_count)?;
        }
        if self.edge_count != 0 {
            os.write_uint64(2, self.edge_count)?;
        }
        for v in &self.active_partitions {
            os.write_uint32(3, *v)?;
        };
        for v in &self.replicas {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GraphInfo {
        GraphInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "vertex_count",
                    |m: &GraphInfo| { &m.vertex_count },
                    |m: &mut GraphInfo| { &mut m.vertex_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "edge_count",
                    |m: &GraphInfo| { &m.edge_count },
                    |m: &mut GraphInfo| { &mut m.edge_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active_partitions",
                    |m: &GraphInfo| { &m.active_partitions },
                    |m: &mut GraphInfo| { &mut m.active_partitions },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicaInfo>>(
                    "replicas",
                    |m: &GraphInfo| { &m.replicas },
                    |m: &mut GraphInfo| { &mut m.replicas },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GraphInfo>(
                    "GraphInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GraphInfo {
        static mut instance: ::protobuf::lazy::Lazy<GraphInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GraphInfo,
        };
        unsafe {
            instance.get(GraphInfo::new)
        }
    }
}

impl ::protobuf::Clear for GraphInfo {
    fn clear(&mut self) {
        self.clear_vertex_count();
        self.clear_edge_count();
        self.clear_active_partitions();
        self.clear_replicas();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GraphInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GraphInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicaInfo {
    // message fields
    pub partition_id: u32,
    pub label: u32,
    pub src_label: u32,
    pub dst_label: u32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ReplicaInfo {
    pub fn new() -> ReplicaInfo {
        ::std::default::Default::default()
    }

    // uint32 partition_id = 1;

    pub fn clear_partition_id(&mut self) {
        self.partition_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_partition_id(&mut self, v: u32) {
        self.partition_id = v;
    }

    pub fn get_partition_id(&self) -> u32 {
        self.partition_id
    }

    // uint32 label = 2;

    pub fn clear_label(&mut self) {
        self.label = 0;
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: u32) {
        self.label = v;
    }

    pub fn get_label(&self) -> u32 {
        self.label
    }

    // uint32 src_label = 3;

    pub fn clear_src_label(&mut self) {
        self.src_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_label(&mut self, v: u32) {
        self.src_label = v;
    }

    pub fn get_src_label(&self) -> u32 {
        self.src_label
    }

    // uint32 dst_label = 4;

    pub fn clear_dst_label(&mut self) {
        self.dst_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_label(&mut self, v: u32) {
        self.dst_label = v;
    }

    pub fn get_dst_label(&self) -> u32 {
        self.dst_label
    }
}

impl ::protobuf::Message for ReplicaInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.partition_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.label = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.src_label = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.dst_label = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.partition_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.partition_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.src_label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_label != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dst_label, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.partition_id != 0 {
            os.write_uint32(1, self.partition_id)?;
        }
        if self.label != 0 {
            os.write_uint32(2, self.label)?;
        }
        if self.src_label != 0 {
            os.write_uint32(3, self.src_label)?;
        }
        if self.dst_label != 0 {
            os.write_uint32(4, self.dst_label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicaInfo {
        ReplicaInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partition_id",
                    |m: &ReplicaInfo| { &m.partition_id },
                    |m: &mut ReplicaInfo| { &mut m.partition_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "label",
                    |m: &ReplicaInfo| { &m.label },
                    |m: &mut ReplicaInfo| { &mut m.label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "src_label",
                    |m: &ReplicaInfo| { &m.src_label },
                    |m: &mut ReplicaInfo| { &mut m.src_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "dst_label",
                    |m: &ReplicaInfo| { &m.dst_label },
                    |m: &mut ReplicaInfo| { &mut m.dst_label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplicaInfo>(
                    "ReplicaInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ReplicaInfo {
        static mut instance: ::protobuf::lazy::Lazy<ReplicaInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplicaInfo,
        };
        unsafe {
            instance.get(ReplicaInfo::new)
        }
    }
}

impl ::protobuf::Clear for ReplicaInfo {
    fn clear(&mut self) {
        self.clear_partition_id();
        self.clear_label();
        self.clear_src_label();
        self.clear_dst_label();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bdebug.proto\x1a\x10sdk/common.proto\x1a\x10sdk/schema.proto\"7\n\
    \x11StoreTestProperty\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\
    \x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"v\n\x0fStoreTestVertex\x12\
    \x1b\n\tvertex_id\x18\x01\x20\x01(\x03R\x08vertexId\x12\x14\n\x05label\
    \x18\x02\x20\x01(\x05R\x05label\x120\n\tproperies\x18\x03\x20\x03(\x0b2\
    \x12.StoreTestPropertyR\tproperies\"3\n\rPropertyProto\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04da\
    ta\"Y\n\x10GetVertexRequest\x12\x0e\n\x02id\x18\x01\x20\x03(\x03R\x02id\
    \x12\x14\n\x05label\x18\x02\x20\x01(\rR\x05label\x12\x1f\n\x0bsnapshot_i\
    d\x18\x03\x20\x01(\x03R\nsnapshotId\"\x95\x01\n\x0bVertexProto\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x03R\x02id\x12\x14\n\x05label\x18\x02\x20\x01(\r\
    R\x05label\x12\x19\n\x08start_si\x18\x03\x20\x01(\x03R\x07startSi\x12\
    \x15\n\x06end_si\x18\x04\x20\x01(\x03R\x05endSi\x12.\n\nproperties\x18\
    \x05\x20\x03(\x0b2\x0e.PropertyProtoR\nproperties\"_\n\rRelationProto\
    \x12\x14\n\x05label\x18\x01\x20\x01(\rR\x05label\x12\x1b\n\tsrc_label\
    \x18\x02\x20\x01(\rR\x08srcLabel\x12\x1b\n\tdst_label\x18\x03\x20\x01(\r\
    R\x08dstLabel\"\xd7\x01\n\tEdgeProto\x12\x0e\n\x02id\x18\x01\x20\x01(\
    \x03R\x02id\x12\x15\n\x06src_id\x18\x02\x20\x01(\x03R\x05srcId\x12\x15\n\
    \x06dst_id\x18\x03\x20\x01(\x03R\x05dstId\x12*\n\x08relation\x18\x04\x20\
    \x01(\x0b2\x0e.RelationProtoR\x08relation\x12\x19\n\x08start_si\x18\x05\
    \x20\x01(\x03R\x07startSi\x12\x15\n\x06end_si\x18\x06\x20\x01(\x03R\x05e\
    ndSi\x12.\n\nproperties\x18\x07\x20\x03(\x0b2\x0e.PropertyProtoR\nproper\
    ties\"x\n\x12GetOutEdgesRequest\x12\x15\n\x06src_id\x18\x01\x20\x01(\x03\
    R\x05srcId\x12\x1f\n\x0bsnapshot_id\x18\x02\x20\x01(\x03R\nsnapshotId\
    \x12\x14\n\x05label\x18\x03\x20\x01(\rR\x05label\x12\x14\n\x05limit\x18\
    \x04\x20\x01(\x04R\x05limit\"w\n\x11GetInEdgesRequest\x12\x15\n\x06dst_i\
    d\x18\x01\x20\x01(\x03R\x05dstId\x12\x1f\n\x0bsnapshot_id\x18\x02\x20\
    \x01(\x03R\nsnapshotId\x12\x14\n\x05label\x18\x03\x20\x01(\rR\x05label\
    \x12\x14\n\x05limit\x18\x04\x20\x01(\x04R\x05limit\"`\n\x11ScanVertexReq\
    uest\x12\x14\n\x05label\x18\x01\x20\x01(\rR\x05label\x12\x1f\n\x0bsnapsh\
    ot_id\x18\x02\x20\x01(\x03R\nsnapshotId\x12\x14\n\x05limit\x18\x03\x20\
    \x01(\x04R\x05limit\",\n\x10GetSchemaRequest\x12\x18\n\x07version\x18\
    \x01\x20\x01(\x05R\x07version\"g\n\x11StoreTestResponse\x12,\n\x08vertic\
    es\x18\x01\x20\x03(\x0b2\x10.StoreTestVertexR\x08vertices\x12$\n\x05edge\
    s\x18\x02\x20\x03(\x0b2\x0e.StoreTestEdgeR\x05edges\"\xad\x02\n\nServerI\
    nfo\x12\x17\n\x07work_id\x18\x01\x20\x01(\rR\x06workId\x12\x15\n\x06zk_u\
    rl\x18\x02\x20\x01(\tR\x05zkUrl\x12\x1d\n\ngraph_name\x18\x03\x20\x01(\t\
    R\tgraphName\x12#\n\rpartition_num\x18\x04\x20\x01(\rR\x0cpartitionNum\
    \x122\n\x15download_thread_count\x18\x05\x20\x01(\rR\x13downloadThreadCo\
    unt\x12*\n\x11load_thread_count\x18\x06\x20\x01(\rR\x0floadThreadCount\
    \x12&\n\x0flocal_data_root\x18\x07\x20\x01(\tR\rlocalDataRoot\x12#\n\rli\
    stened_port\x18\x08\x20\x01(\rR\x0clistenedPort\"\xd8\x01\n\rStoreTestEd\
    ge\x12\x17\n\x07edge_id\x18\x01\x20\x01(\x03R\x06edgeId\x12\x15\n\x06src\
    _id\x18\x02\x20\x01(\x03R\x05srcId\x12\x15\n\x06dst_id\x18\x03\x20\x01(\
    \x03R\x05dstId\x12\x14\n\x05label\x18\x04\x20\x01(\x05R\x05label\x12\x1b\
    \n\tsrc_label\x18\x05\x20\x01(\x05R\x08srcLabel\x12\x1b\n\tdst_label\x18\
    \x06\x20\x01(\x05R\x08dstLabel\x120\n\tproperies\x18\x07\x20\x03(\x0b2\
    \x12.StoreTestPropertyR\tproperies\"\xa4\x01\n\tGraphInfo\x12!\n\x0cvert\
    ex_count\x18\x01\x20\x01(\x04R\x0bvertexCount\x12\x1d\n\nedge_count\x18\
    \x02\x20\x01(\x04R\tedgeCount\x12+\n\x11active_partitions\x18\x03\x20\
    \x03(\rR\x10activePartitions\x12(\n\x08replicas\x18\x04\x20\x03(\x0b2\
    \x0c.ReplicaInfoR\x08replicas\"\x80\x01\n\x0bReplicaInfo\x12!\n\x0cparti\
    tion_id\x18\x01\x20\x01(\rR\x0bpartitionId\x12\x14\n\x05label\x18\x02\
    \x20\x01(\rR\x05label\x12\x1b\n\tsrc_label\x18\x03\x20\x01(\rR\x08srcLab\
    el\x12\x1b\n\tdst_label\x18\x04\x20\x01(\rR\x08dstLabel2\xcd\x02\n\x0fDe\
    bugServiceApi\x12$\n\rgetServerInfo\x12\x06.Empty\x1a\x0b.ServerInfo\x12\
    \"\n\x0cgetGraphInfo\x12\x06.Empty\x1a\n.GraphInfo\x12.\n\tgetVertex\x12\
    \x11.GetVertexRequest\x1a\x0c.VertexProto0\x01\x120\n\nscanVertex\x12\
    \x12.ScanVertexRequest\x1a\x0c.VertexProto0\x01\x120\n\x0bgetOutEdges\
    \x12\x13.GetOutEdgesRequest\x1a\n.EdgeProto0\x01\x12.\n\ngetInEdges\x12\
    \x12.GetInEdgesRequest\x1a\n.EdgeProto0\x01\x12,\n\tgetSchema\x12\x11.Ge\
    tSchemaRequest\x1a\x0c.SchemaProto2\xa4\x01\n\x10StoreTestService\x12$\n\
    \rgetServerInfo\x12\x06.Empty\x1a\x0b.ServerInfo\x122\n\tgetVertex\x12\
    \x11.GetVertexRequest\x1a\x12.StoreTestResponse\x126\n\x0bgetOutEdges\
    \x12\x13.GetOutEdgesRequest\x1a\x12.StoreTestResponseB\x1e\n\x1acom.alib\
    aba.maxgraph.protoP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
