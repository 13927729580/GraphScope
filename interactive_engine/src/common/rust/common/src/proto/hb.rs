//
//! Copyright 2020 Alibaba Group Holding Limited.
//! 
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//! 
//!     http://www.apache.org/licenses/LICENSE-2.0
//! 
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct EndpointsProto {
    // message fields
    pub addrs: ::protobuf::RepeatedField<super::common::EndpointProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EndpointsProto {
    pub fn new() -> EndpointsProto {
        ::std::default::Default::default()
    }

    // repeated .EndpointProto addrs = 1;

    pub fn clear_addrs(&mut self) {
        self.addrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_addrs(&mut self, v: ::protobuf::RepeatedField<super::common::EndpointProto>) {
        self.addrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addrs(&mut self) -> &mut ::protobuf::RepeatedField<super::common::EndpointProto> {
        &mut self.addrs
    }

    // Take field
    pub fn take_addrs(&mut self) -> ::protobuf::RepeatedField<super::common::EndpointProto> {
        ::std::mem::replace(&mut self.addrs, ::protobuf::RepeatedField::new())
    }

    pub fn get_addrs(&self) -> &[super::common::EndpointProto] {
        &self.addrs
    }
}

impl ::protobuf::Message for EndpointsProto {
    fn is_initialized(&self) -> bool {
        for v in &self.addrs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addrs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addrs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointsProto {
        EndpointsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EndpointProto>>(
                    "addrs",
                    |m: &EndpointsProto| { &m.addrs },
                    |m: &mut EndpointsProto| { &mut m.addrs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EndpointsProto>(
                    "EndpointsProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EndpointsProto {
        static mut instance: ::protobuf::lazy::Lazy<EndpointsProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EndpointsProto,
        };
        unsafe {
            instance.get(EndpointsProto::new)
        }
    }
}

impl ::protobuf::Clear for EndpointsProto {
    fn clear(&mut self) {
        self.clear_addrs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statistics {
    // message fields
    pub metrics: ::std::collections::HashMap<::std::string::String, f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Statistics {
    pub fn new() -> Statistics {
        ::std::default::Default::default()
    }

    // repeated .Statistics.MetricsEntry metrics = 1;

    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.metrics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.metrics
    }

    // Take field
    pub fn take_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.metrics, ::std::collections::HashMap::new())
    }

    pub fn get_metrics(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.metrics
    }
}

impl ::protobuf::Message for Statistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.metrics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.metrics);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.metrics, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statistics {
        Statistics::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "metrics",
                    |m: &Statistics| { &m.metrics },
                    |m: &mut Statistics| { &mut m.metrics },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Statistics>(
                    "Statistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Statistics {
        static mut instance: ::protobuf::lazy::Lazy<Statistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Statistics,
        };
        unsafe {
            instance.get(Statistics::new)
        }
    }
}

impl ::protobuf::Clear for Statistics {
    fn clear(&mut self) {
        self.clear_metrics();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statistics {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeHBReq {
    // message fields
    pub serverStatus: RuntimeHBReq_RuntimeStatus,
    pub runtimePort: i32,
    pub worker_num_per_process: u32,
    pub process_partition_list: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeHBReq {
    pub fn new() -> RuntimeHBReq {
        ::std::default::Default::default()
    }

    // .RuntimeHBReq.RuntimeStatus serverStatus = 1;

    pub fn clear_serverStatus(&mut self) {
        self.serverStatus = RuntimeHBReq_RuntimeStatus::DOWN;
    }

    // Param is passed by value, moved
    pub fn set_serverStatus(&mut self, v: RuntimeHBReq_RuntimeStatus) {
        self.serverStatus = v;
    }

    pub fn get_serverStatus(&self) -> RuntimeHBReq_RuntimeStatus {
        self.serverStatus
    }

    // int32 runtimePort = 2;

    pub fn clear_runtimePort(&mut self) {
        self.runtimePort = 0;
    }

    // Param is passed by value, moved
    pub fn set_runtimePort(&mut self, v: i32) {
        self.runtimePort = v;
    }

    pub fn get_runtimePort(&self) -> i32 {
        self.runtimePort
    }

    // uint32 worker_num_per_process = 3;

    pub fn clear_worker_num_per_process(&mut self) {
        self.worker_num_per_process = 0;
    }

    // Param is passed by value, moved
    pub fn set_worker_num_per_process(&mut self, v: u32) {
        self.worker_num_per_process = v;
    }

    pub fn get_worker_num_per_process(&self) -> u32 {
        self.worker_num_per_process
    }

    // repeated uint32 process_partition_list = 4;

    pub fn clear_process_partition_list(&mut self) {
        self.process_partition_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_process_partition_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.process_partition_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_process_partition_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.process_partition_list
    }

    // Take field
    pub fn take_process_partition_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.process_partition_list, ::std::vec::Vec::new())
    }

    pub fn get_process_partition_list(&self) -> &[u32] {
        &self.process_partition_list
    }
}

impl ::protobuf::Message for RuntimeHBReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.serverStatus, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.runtimePort = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.worker_num_per_process = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.process_partition_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.serverStatus != RuntimeHBReq_RuntimeStatus::DOWN {
            my_size += ::protobuf::rt::enum_size(1, self.serverStatus);
        }
        if self.runtimePort != 0 {
            my_size += ::protobuf::rt::value_size(2, self.runtimePort, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.worker_num_per_process != 0 {
            my_size += ::protobuf::rt::value_size(3, self.worker_num_per_process, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.process_partition_list {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.serverStatus != RuntimeHBReq_RuntimeStatus::DOWN {
            os.write_enum(1, self.serverStatus.value())?;
        }
        if self.runtimePort != 0 {
            os.write_int32(2, self.runtimePort)?;
        }
        if self.worker_num_per_process != 0 {
            os.write_uint32(3, self.worker_num_per_process)?;
        }
        for v in &self.process_partition_list {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeHBReq {
        RuntimeHBReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RuntimeHBReq_RuntimeStatus>>(
                    "serverStatus",
                    |m: &RuntimeHBReq| { &m.serverStatus },
                    |m: &mut RuntimeHBReq| { &mut m.serverStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "runtimePort",
                    |m: &RuntimeHBReq| { &m.runtimePort },
                    |m: &mut RuntimeHBReq| { &mut m.runtimePort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "worker_num_per_process",
                    |m: &RuntimeHBReq| { &m.worker_num_per_process },
                    |m: &mut RuntimeHBReq| { &mut m.worker_num_per_process },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "process_partition_list",
                    |m: &RuntimeHBReq| { &m.process_partition_list },
                    |m: &mut RuntimeHBReq| { &mut m.process_partition_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeHBReq>(
                    "RuntimeHBReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeHBReq {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeHBReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeHBReq,
        };
        unsafe {
            instance.get(RuntimeHBReq::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeHBReq {
    fn clear(&mut self) {
        self.clear_serverStatus();
        self.clear_runtimePort();
        self.clear_worker_num_per_process();
        self.clear_process_partition_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeHBReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeHBReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RuntimeHBReq_RuntimeStatus {
    DOWN = 0,
    STARTING = 1,
    RUNNING = 2,
}

impl ::protobuf::ProtobufEnum for RuntimeHBReq_RuntimeStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RuntimeHBReq_RuntimeStatus> {
        match value {
            0 => ::std::option::Option::Some(RuntimeHBReq_RuntimeStatus::DOWN),
            1 => ::std::option::Option::Some(RuntimeHBReq_RuntimeStatus::STARTING),
            2 => ::std::option::Option::Some(RuntimeHBReq_RuntimeStatus::RUNNING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RuntimeHBReq_RuntimeStatus] = &[
            RuntimeHBReq_RuntimeStatus::DOWN,
            RuntimeHBReq_RuntimeStatus::STARTING,
            RuntimeHBReq_RuntimeStatus::RUNNING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RuntimeHBReq_RuntimeStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RuntimeHBReq_RuntimeStatus {
}

impl ::std::default::Default for RuntimeHBReq_RuntimeStatus {
    fn default() -> Self {
        RuntimeHBReq_RuntimeStatus::DOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeHBReq_RuntimeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeHBResp {
    // message fields
    pub version: i64,
    pub workerId: u32,
    pub addresses: ::protobuf::RepeatedField<RuntimeAddressProto>,
    pub groupId: u32,
    pub task_partition_list: ::protobuf::RepeatedField<RuntimeTaskPartitionProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeHBResp {
    pub fn new() -> RuntimeHBResp {
        ::std::default::Default::default()
    }

    // int64 version = 1;

    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i64) {
        self.version = v;
    }

    pub fn get_version(&self) -> i64 {
        self.version
    }

    // uint32 workerId = 2;

    pub fn clear_workerId(&mut self) {
        self.workerId = 0;
    }

    // Param is passed by value, moved
    pub fn set_workerId(&mut self, v: u32) {
        self.workerId = v;
    }

    pub fn get_workerId(&self) -> u32 {
        self.workerId
    }

    // repeated .RuntimeAddressProto addresses = 3;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<RuntimeAddressProto>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeAddressProto> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<RuntimeAddressProto> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[RuntimeAddressProto] {
        &self.addresses
    }

    // uint32 groupId = 4;

    pub fn clear_groupId(&mut self) {
        self.groupId = 0;
    }

    // Param is passed by value, moved
    pub fn set_groupId(&mut self, v: u32) {
        self.groupId = v;
    }

    pub fn get_groupId(&self) -> u32 {
        self.groupId
    }

    // repeated .RuntimeTaskPartitionProto task_partition_list = 5;

    pub fn clear_task_partition_list(&mut self) {
        self.task_partition_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_partition_list(&mut self, v: ::protobuf::RepeatedField<RuntimeTaskPartitionProto>) {
        self.task_partition_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_task_partition_list(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeTaskPartitionProto> {
        &mut self.task_partition_list
    }

    // Take field
    pub fn take_task_partition_list(&mut self) -> ::protobuf::RepeatedField<RuntimeTaskPartitionProto> {
        ::std::mem::replace(&mut self.task_partition_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_task_partition_list(&self) -> &[RuntimeTaskPartitionProto] {
        &self.task_partition_list
    }
}

impl ::protobuf::Message for RuntimeHBResp {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.task_partition_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.version = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.workerId = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.groupId = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.task_partition_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.workerId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.workerId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.groupId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.groupId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.task_partition_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_int64(1, self.version)?;
        }
        if self.workerId != 0 {
            os.write_uint32(2, self.workerId)?;
        }
        for v in &self.addresses {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.groupId != 0 {
            os.write_uint32(4, self.groupId)?;
        }
        for v in &self.task_partition_list {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeHBResp {
        RuntimeHBResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "version",
                    |m: &RuntimeHBResp| { &m.version },
                    |m: &mut RuntimeHBResp| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "workerId",
                    |m: &RuntimeHBResp| { &m.workerId },
                    |m: &mut RuntimeHBResp| { &mut m.workerId },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeAddressProto>>(
                    "addresses",
                    |m: &RuntimeHBResp| { &m.addresses },
                    |m: &mut RuntimeHBResp| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "groupId",
                    |m: &RuntimeHBResp| { &m.groupId },
                    |m: &mut RuntimeHBResp| { &mut m.groupId },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeTaskPartitionProto>>(
                    "task_partition_list",
                    |m: &RuntimeHBResp| { &m.task_partition_list },
                    |m: &mut RuntimeHBResp| { &mut m.task_partition_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeHBResp>(
                    "RuntimeHBResp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeHBResp {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeHBResp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeHBResp,
        };
        unsafe {
            instance.get(RuntimeHBResp::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeHBResp {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_workerId();
        self.clear_addresses();
        self.clear_groupId();
        self.clear_task_partition_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeHBResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeHBResp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeTaskPartitionProto {
    // message fields
    pub task_index: u32,
    pub process_index: u32,
    pub partition_list: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeTaskPartitionProto {
    pub fn new() -> RuntimeTaskPartitionProto {
        ::std::default::Default::default()
    }

    // uint32 task_index = 1;

    pub fn clear_task_index(&mut self) {
        self.task_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_task_index(&mut self, v: u32) {
        self.task_index = v;
    }

    pub fn get_task_index(&self) -> u32 {
        self.task_index
    }

    // uint32 process_index = 2;

    pub fn clear_process_index(&mut self) {
        self.process_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_process_index(&mut self, v: u32) {
        self.process_index = v;
    }

    pub fn get_process_index(&self) -> u32 {
        self.process_index
    }

    // repeated uint32 partition_list = 3;

    pub fn clear_partition_list(&mut self) {
        self.partition_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_list(&mut self, v: ::std::vec::Vec<u32>) {
        self.partition_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_list(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.partition_list
    }

    // Take field
    pub fn take_partition_list(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.partition_list, ::std::vec::Vec::new())
    }

    pub fn get_partition_list(&self) -> &[u32] {
        &self.partition_list
    }
}

impl ::protobuf::Message for RuntimeTaskPartitionProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.task_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.process_index = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.partition_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.task_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.task_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.process_index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.process_index, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.partition_list {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.task_index != 0 {
            os.write_uint32(1, self.task_index)?;
        }
        if self.process_index != 0 {
            os.write_uint32(2, self.process_index)?;
        }
        for v in &self.partition_list {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeTaskPartitionProto {
        RuntimeTaskPartitionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "task_index",
                    |m: &RuntimeTaskPartitionProto| { &m.task_index },
                    |m: &mut RuntimeTaskPartitionProto| { &mut m.task_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "process_index",
                    |m: &RuntimeTaskPartitionProto| { &m.process_index },
                    |m: &mut RuntimeTaskPartitionProto| { &mut m.process_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partition_list",
                    |m: &RuntimeTaskPartitionProto| { &m.partition_list },
                    |m: &mut RuntimeTaskPartitionProto| { &mut m.partition_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeTaskPartitionProto>(
                    "RuntimeTaskPartitionProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeTaskPartitionProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeTaskPartitionProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeTaskPartitionProto,
        };
        unsafe {
            instance.get(RuntimeTaskPartitionProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeTaskPartitionProto {
    fn clear(&mut self) {
        self.clear_task_index();
        self.clear_process_index();
        self.clear_partition_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeTaskPartitionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeTaskPartitionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeAddressProto {
    // message fields
    pub ip: ::std::string::String,
    pub store_port: i32,
    pub runtime_port: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeAddressProto {
    pub fn new() -> RuntimeAddressProto {
        ::std::default::Default::default()
    }

    // string ip = 1;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip, ::std::string::String::new())
    }

    pub fn get_ip(&self) -> &str {
        &self.ip
    }

    // int32 store_port = 2;

    pub fn clear_store_port(&mut self) {
        self.store_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_store_port(&mut self, v: i32) {
        self.store_port = v;
    }

    pub fn get_store_port(&self) -> i32 {
        self.store_port
    }

    // int32 runtime_port = 3;

    pub fn clear_runtime_port(&mut self) {
        self.runtime_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_runtime_port(&mut self, v: i32) {
        self.runtime_port = v;
    }

    pub fn get_runtime_port(&self) -> i32 {
        self.runtime_port
    }
}

impl ::protobuf::Message for RuntimeAddressProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.store_port = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.runtime_port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ip);
        }
        if self.store_port != 0 {
            my_size += ::protobuf::rt::value_size(2, self.store_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.runtime_port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.runtime_port, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ip.is_empty() {
            os.write_string(1, &self.ip)?;
        }
        if self.store_port != 0 {
            os.write_int32(2, self.store_port)?;
        }
        if self.runtime_port != 0 {
            os.write_int32(3, self.runtime_port)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeAddressProto {
        RuntimeAddressProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    |m: &RuntimeAddressProto| { &m.ip },
                    |m: &mut RuntimeAddressProto| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "store_port",
                    |m: &RuntimeAddressProto| { &m.store_port },
                    |m: &mut RuntimeAddressProto| { &mut m.store_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "runtime_port",
                    |m: &RuntimeAddressProto| { &m.runtime_port },
                    |m: &mut RuntimeAddressProto| { &mut m.runtime_port },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeAddressProto>(
                    "RuntimeAddressProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeAddressProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeAddressProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeAddressProto,
        };
        unsafe {
            instance.get(RuntimeAddressProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeAddressProto {
    fn clear(&mut self) {
        self.clear_ip();
        self.clear_store_port();
        self.clear_runtime_port();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeAddressProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeAddressProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerHBReq {
    // message fields
    pub id: u32,
    pub endpoint: ::protobuf::SingularPtrField<super::common::EndpointProto>,
    pub heartbeatTime: i64,
    pub statistics: ::protobuf::SingularPtrField<Statistics>,
    pub runtimeReq: ::protobuf::SingularPtrField<RuntimeHBReq>,
    pub aliveId: u64,
    pub status: StoreStatus,
    pub infoProto: ::protobuf::SingularPtrField<super::common::MetricInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ServerHBReq {
    pub fn new() -> ServerHBReq {
        ::std::default::Default::default()
    }

    // uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    pub fn get_id(&self) -> u32 {
        self.id
    }

    // .EndpointProto endpoint = 2;

    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    pub fn has_endpoint(&self) -> bool {
        self.endpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: super::common::EndpointProto) {
        self.endpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut super::common::EndpointProto {
        if self.endpoint.is_none() {
            self.endpoint.set_default();
        }
        self.endpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoint(&mut self) -> super::common::EndpointProto {
        self.endpoint.take().unwrap_or_else(|| super::common::EndpointProto::new())
    }

    pub fn get_endpoint(&self) -> &super::common::EndpointProto {
        self.endpoint.as_ref().unwrap_or_else(|| super::common::EndpointProto::default_instance())
    }

    // int64 heartbeatTime = 8;

    pub fn clear_heartbeatTime(&mut self) {
        self.heartbeatTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_heartbeatTime(&mut self, v: i64) {
        self.heartbeatTime = v;
    }

    pub fn get_heartbeatTime(&self) -> i64 {
        self.heartbeatTime
    }

    // .Statistics statistics = 9;

    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: Statistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics(&mut self) -> &mut Statistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        }
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> Statistics {
        self.statistics.take().unwrap_or_else(|| Statistics::new())
    }

    pub fn get_statistics(&self) -> &Statistics {
        self.statistics.as_ref().unwrap_or_else(|| Statistics::default_instance())
    }

    // .RuntimeHBReq runtimeReq = 10;

    pub fn clear_runtimeReq(&mut self) {
        self.runtimeReq.clear();
    }

    pub fn has_runtimeReq(&self) -> bool {
        self.runtimeReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtimeReq(&mut self, v: RuntimeHBReq) {
        self.runtimeReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtimeReq(&mut self) -> &mut RuntimeHBReq {
        if self.runtimeReq.is_none() {
            self.runtimeReq.set_default();
        }
        self.runtimeReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtimeReq(&mut self) -> RuntimeHBReq {
        self.runtimeReq.take().unwrap_or_else(|| RuntimeHBReq::new())
    }

    pub fn get_runtimeReq(&self) -> &RuntimeHBReq {
        self.runtimeReq.as_ref().unwrap_or_else(|| RuntimeHBReq::default_instance())
    }

    // uint64 aliveId = 11;

    pub fn clear_aliveId(&mut self) {
        self.aliveId = 0;
    }

    // Param is passed by value, moved
    pub fn set_aliveId(&mut self, v: u64) {
        self.aliveId = v;
    }

    pub fn get_aliveId(&self) -> u64 {
        self.aliveId
    }

    // .StoreStatus status = 12;

    pub fn clear_status(&mut self) {
        self.status = StoreStatus::INITIALING;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: StoreStatus) {
        self.status = v;
    }

    pub fn get_status(&self) -> StoreStatus {
        self.status
    }

    // .MetricInfoProto infoProto = 13;

    pub fn clear_infoProto(&mut self) {
        self.infoProto.clear();
    }

    pub fn has_infoProto(&self) -> bool {
        self.infoProto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infoProto(&mut self, v: super::common::MetricInfoProto) {
        self.infoProto = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_infoProto(&mut self) -> &mut super::common::MetricInfoProto {
        if self.infoProto.is_none() {
            self.infoProto.set_default();
        }
        self.infoProto.as_mut().unwrap()
    }

    // Take field
    pub fn take_infoProto(&mut self) -> super::common::MetricInfoProto {
        self.infoProto.take().unwrap_or_else(|| super::common::MetricInfoProto::new())
    }

    pub fn get_infoProto(&self) -> &super::common::MetricInfoProto {
        self.infoProto.as_ref().unwrap_or_else(|| super::common::MetricInfoProto::default_instance())
    }
}

impl ::protobuf::Message for ServerHBReq {
    fn is_initialized(&self) -> bool {
        for v in &self.endpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtimeReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.infoProto {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endpoint)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.heartbeatTime = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statistics)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtimeReq)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.aliveId = tmp;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.infoProto)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.heartbeatTime != 0 {
            my_size += ::protobuf::rt::value_size(8, self.heartbeatTime, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.statistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.runtimeReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.aliveId != 0 {
            my_size += ::protobuf::rt::value_size(11, self.aliveId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.status != StoreStatus::INITIALING {
            my_size += ::protobuf::rt::enum_size(12, self.status);
        }
        if let Some(ref v) = self.infoProto.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.heartbeatTime != 0 {
            os.write_int64(8, self.heartbeatTime)?;
        }
        if let Some(ref v) = self.statistics.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.runtimeReq.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.aliveId != 0 {
            os.write_uint64(11, self.aliveId)?;
        }
        if self.status != StoreStatus::INITIALING {
            os.write_enum(12, self.status.value())?;
        }
        if let Some(ref v) = self.infoProto.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerHBReq {
        ServerHBReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &ServerHBReq| { &m.id },
                    |m: &mut ServerHBReq| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EndpointProto>>(
                    "endpoint",
                    |m: &ServerHBReq| { &m.endpoint },
                    |m: &mut ServerHBReq| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "heartbeatTime",
                    |m: &ServerHBReq| { &m.heartbeatTime },
                    |m: &mut ServerHBReq| { &mut m.heartbeatTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statistics>>(
                    "statistics",
                    |m: &ServerHBReq| { &m.statistics },
                    |m: &mut ServerHBReq| { &mut m.statistics },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeHBReq>>(
                    "runtimeReq",
                    |m: &ServerHBReq| { &m.runtimeReq },
                    |m: &mut ServerHBReq| { &mut m.runtimeReq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "aliveId",
                    |m: &ServerHBReq| { &m.aliveId },
                    |m: &mut ServerHBReq| { &mut m.aliveId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StoreStatus>>(
                    "status",
                    |m: &ServerHBReq| { &m.status },
                    |m: &mut ServerHBReq| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::MetricInfoProto>>(
                    "infoProto",
                    |m: &ServerHBReq| { &m.infoProto },
                    |m: &mut ServerHBReq| { &mut m.infoProto },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerHBReq>(
                    "ServerHBReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerHBReq {
        static mut instance: ::protobuf::lazy::Lazy<ServerHBReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerHBReq,
        };
        unsafe {
            instance.get(ServerHBReq::new)
        }
    }
}

impl ::protobuf::Clear for ServerHBReq {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_endpoint();
        self.clear_heartbeatTime();
        self.clear_statistics();
        self.clear_runtimeReq();
        self.clear_aliveId();
        self.clear_status();
        self.clear_infoProto();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerHBReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHBReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SimpleServerHBReq {
    // message fields
    pub id: u32,
    pub endpoint: ::protobuf::SingularPtrField<super::common::EndpointProto>,
    pub roleType: super::cluster::RoleType,
    pub statistics: ::protobuf::SingularPtrField<Statistics>,
    pub logDir: ::std::string::String,
    pub aliveId: u64,
    pub nodeId: i32,
    pub infoProto: ::protobuf::SingularPtrField<super::common::MetricInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SimpleServerHBReq {
    pub fn new() -> SimpleServerHBReq {
        ::std::default::Default::default()
    }

    // uint32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = v;
    }

    pub fn get_id(&self) -> u32 {
        self.id
    }

    // .EndpointProto endpoint = 2;

    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    pub fn has_endpoint(&self) -> bool {
        self.endpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: super::common::EndpointProto) {
        self.endpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut super::common::EndpointProto {
        if self.endpoint.is_none() {
            self.endpoint.set_default();
        }
        self.endpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoint(&mut self) -> super::common::EndpointProto {
        self.endpoint.take().unwrap_or_else(|| super::common::EndpointProto::new())
    }

    pub fn get_endpoint(&self) -> &super::common::EndpointProto {
        self.endpoint.as_ref().unwrap_or_else(|| super::common::EndpointProto::default_instance())
    }

    // .RoleType roleType = 3;

    pub fn clear_roleType(&mut self) {
        self.roleType = super::cluster::RoleType::AM;
    }

    // Param is passed by value, moved
    pub fn set_roleType(&mut self, v: super::cluster::RoleType) {
        self.roleType = v;
    }

    pub fn get_roleType(&self) -> super::cluster::RoleType {
        self.roleType
    }

    // .Statistics statistics = 4;

    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: Statistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics(&mut self) -> &mut Statistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        }
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> Statistics {
        self.statistics.take().unwrap_or_else(|| Statistics::new())
    }

    pub fn get_statistics(&self) -> &Statistics {
        self.statistics.as_ref().unwrap_or_else(|| Statistics::default_instance())
    }

    // string logDir = 5;

    pub fn clear_logDir(&mut self) {
        self.logDir.clear();
    }

    // Param is passed by value, moved
    pub fn set_logDir(&mut self, v: ::std::string::String) {
        self.logDir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logDir(&mut self) -> &mut ::std::string::String {
        &mut self.logDir
    }

    // Take field
    pub fn take_logDir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logDir, ::std::string::String::new())
    }

    pub fn get_logDir(&self) -> &str {
        &self.logDir
    }

    // uint64 aliveId = 6;

    pub fn clear_aliveId(&mut self) {
        self.aliveId = 0;
    }

    // Param is passed by value, moved
    pub fn set_aliveId(&mut self, v: u64) {
        self.aliveId = v;
    }

    pub fn get_aliveId(&self) -> u64 {
        self.aliveId
    }

    // int32 nodeId = 7;

    pub fn clear_nodeId(&mut self) {
        self.nodeId = 0;
    }

    // Param is passed by value, moved
    pub fn set_nodeId(&mut self, v: i32) {
        self.nodeId = v;
    }

    pub fn get_nodeId(&self) -> i32 {
        self.nodeId
    }

    // .MetricInfoProto infoProto = 8;

    pub fn clear_infoProto(&mut self) {
        self.infoProto.clear();
    }

    pub fn has_infoProto(&self) -> bool {
        self.infoProto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infoProto(&mut self, v: super::common::MetricInfoProto) {
        self.infoProto = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_infoProto(&mut self) -> &mut super::common::MetricInfoProto {
        if self.infoProto.is_none() {
            self.infoProto.set_default();
        }
        self.infoProto.as_mut().unwrap()
    }

    // Take field
    pub fn take_infoProto(&mut self) -> super::common::MetricInfoProto {
        self.infoProto.take().unwrap_or_else(|| super::common::MetricInfoProto::new())
    }

    pub fn get_infoProto(&self) -> &super::common::MetricInfoProto {
        self.infoProto.as_ref().unwrap_or_else(|| super::common::MetricInfoProto::default_instance())
    }
}

impl ::protobuf::Message for SimpleServerHBReq {
    fn is_initialized(&self) -> bool {
        for v in &self.endpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statistics {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.infoProto {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endpoint)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.roleType, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statistics)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logDir)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.aliveId = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nodeId = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.infoProto)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.roleType != super::cluster::RoleType::AM {
            my_size += ::protobuf::rt::enum_size(3, self.roleType);
        }
        if let Some(ref v) = self.statistics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.logDir.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.logDir);
        }
        if self.aliveId != 0 {
            my_size += ::protobuf::rt::value_size(6, self.aliveId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nodeId != 0 {
            my_size += ::protobuf::rt::value_size(7, self.nodeId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.infoProto.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint32(1, self.id)?;
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.roleType != super::cluster::RoleType::AM {
            os.write_enum(3, self.roleType.value())?;
        }
        if let Some(ref v) = self.statistics.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.logDir.is_empty() {
            os.write_string(5, &self.logDir)?;
        }
        if self.aliveId != 0 {
            os.write_uint64(6, self.aliveId)?;
        }
        if self.nodeId != 0 {
            os.write_int32(7, self.nodeId)?;
        }
        if let Some(ref v) = self.infoProto.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SimpleServerHBReq {
        SimpleServerHBReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "id",
                    |m: &SimpleServerHBReq| { &m.id },
                    |m: &mut SimpleServerHBReq| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EndpointProto>>(
                    "endpoint",
                    |m: &SimpleServerHBReq| { &m.endpoint },
                    |m: &mut SimpleServerHBReq| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::cluster::RoleType>>(
                    "roleType",
                    |m: &SimpleServerHBReq| { &m.roleType },
                    |m: &mut SimpleServerHBReq| { &mut m.roleType },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statistics>>(
                    "statistics",
                    |m: &SimpleServerHBReq| { &m.statistics },
                    |m: &mut SimpleServerHBReq| { &mut m.statistics },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "logDir",
                    |m: &SimpleServerHBReq| { &m.logDir },
                    |m: &mut SimpleServerHBReq| { &mut m.logDir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "aliveId",
                    |m: &SimpleServerHBReq| { &m.aliveId },
                    |m: &mut SimpleServerHBReq| { &mut m.aliveId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nodeId",
                    |m: &SimpleServerHBReq| { &m.nodeId },
                    |m: &mut SimpleServerHBReq| { &mut m.nodeId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::MetricInfoProto>>(
                    "infoProto",
                    |m: &SimpleServerHBReq| { &m.infoProto },
                    |m: &mut SimpleServerHBReq| { &mut m.infoProto },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SimpleServerHBReq>(
                    "SimpleServerHBReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SimpleServerHBReq {
        static mut instance: ::protobuf::lazy::Lazy<SimpleServerHBReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SimpleServerHBReq,
        };
        unsafe {
            instance.get(SimpleServerHBReq::new)
        }
    }
}

impl ::protobuf::Clear for SimpleServerHBReq {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_endpoint();
        self.clear_roleType();
        self.clear_statistics();
        self.clear_logDir();
        self.clear_aliveId();
        self.clear_nodeId();
        self.clear_infoProto();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SimpleServerHBReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimpleServerHBReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerHBResp {
    // message fields
    pub resp: ::protobuf::SingularPtrField<super::common::Response>,
    pub partitions: ::std::vec::Vec<u32>,
    pub runtimeResp: ::protobuf::SingularPtrField<RuntimeHBResp>,
    pub isLegal: bool,
    pub targetStatus: StoreStatus,
    pub aliveId: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ServerHBResp {
    pub fn new() -> ServerHBResp {
        ::std::default::Default::default()
    }

    // .Response resp = 1;

    pub fn clear_resp(&mut self) {
        self.resp.clear();
    }

    pub fn has_resp(&self) -> bool {
        self.resp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resp(&mut self, v: super::common::Response) {
        self.resp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resp(&mut self) -> &mut super::common::Response {
        if self.resp.is_none() {
            self.resp.set_default();
        }
        self.resp.as_mut().unwrap()
    }

    // Take field
    pub fn take_resp(&mut self) -> super::common::Response {
        self.resp.take().unwrap_or_else(|| super::common::Response::new())
    }

    pub fn get_resp(&self) -> &super::common::Response {
        self.resp.as_ref().unwrap_or_else(|| super::common::Response::default_instance())
    }

    // repeated uint32 partitions = 4;

    pub fn clear_partitions(&mut self) {
        self.partitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_partitions(&mut self, v: ::std::vec::Vec<u32>) {
        self.partitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partitions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.partitions
    }

    // Take field
    pub fn take_partitions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.partitions, ::std::vec::Vec::new())
    }

    pub fn get_partitions(&self) -> &[u32] {
        &self.partitions
    }

    // .RuntimeHBResp runtimeResp = 6;

    pub fn clear_runtimeResp(&mut self) {
        self.runtimeResp.clear();
    }

    pub fn has_runtimeResp(&self) -> bool {
        self.runtimeResp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtimeResp(&mut self, v: RuntimeHBResp) {
        self.runtimeResp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtimeResp(&mut self) -> &mut RuntimeHBResp {
        if self.runtimeResp.is_none() {
            self.runtimeResp.set_default();
        }
        self.runtimeResp.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtimeResp(&mut self) -> RuntimeHBResp {
        self.runtimeResp.take().unwrap_or_else(|| RuntimeHBResp::new())
    }

    pub fn get_runtimeResp(&self) -> &RuntimeHBResp {
        self.runtimeResp.as_ref().unwrap_or_else(|| RuntimeHBResp::default_instance())
    }

    // bool isLegal = 7;

    pub fn clear_isLegal(&mut self) {
        self.isLegal = false;
    }

    // Param is passed by value, moved
    pub fn set_isLegal(&mut self, v: bool) {
        self.isLegal = v;
    }

    pub fn get_isLegal(&self) -> bool {
        self.isLegal
    }

    // .StoreStatus targetStatus = 10;

    pub fn clear_targetStatus(&mut self) {
        self.targetStatus = StoreStatus::INITIALING;
    }

    // Param is passed by value, moved
    pub fn set_targetStatus(&mut self, v: StoreStatus) {
        self.targetStatus = v;
    }

    pub fn get_targetStatus(&self) -> StoreStatus {
        self.targetStatus
    }

    // uint64 aliveId = 11;

    pub fn clear_aliveId(&mut self) {
        self.aliveId = 0;
    }

    // Param is passed by value, moved
    pub fn set_aliveId(&mut self, v: u64) {
        self.aliveId = v;
    }

    pub fn get_aliveId(&self) -> u64 {
        self.aliveId
    }
}

impl ::protobuf::Message for ServerHBResp {
    fn is_initialized(&self) -> bool {
        for v in &self.resp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtimeResp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resp)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.partitions)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtimeResp)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLegal = tmp;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.targetStatus, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.aliveId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.partitions {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.runtimeResp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.isLegal != false {
            my_size += 2;
        }
        if self.targetStatus != StoreStatus::INITIALING {
            my_size += ::protobuf::rt::enum_size(10, self.targetStatus);
        }
        if self.aliveId != 0 {
            my_size += ::protobuf::rt::value_size(11, self.aliveId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.partitions {
            os.write_uint32(4, *v)?;
        };
        if let Some(ref v) = self.runtimeResp.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.isLegal != false {
            os.write_bool(7, self.isLegal)?;
        }
        if self.targetStatus != StoreStatus::INITIALING {
            os.write_enum(10, self.targetStatus.value())?;
        }
        if self.aliveId != 0 {
            os.write_uint64(11, self.aliveId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerHBResp {
        ServerHBResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Response>>(
                    "resp",
                    |m: &ServerHBResp| { &m.resp },
                    |m: &mut ServerHBResp| { &mut m.resp },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partitions",
                    |m: &ServerHBResp| { &m.partitions },
                    |m: &mut ServerHBResp| { &mut m.partitions },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeHBResp>>(
                    "runtimeResp",
                    |m: &ServerHBResp| { &m.runtimeResp },
                    |m: &mut ServerHBResp| { &mut m.runtimeResp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isLegal",
                    |m: &ServerHBResp| { &m.isLegal },
                    |m: &mut ServerHBResp| { &mut m.isLegal },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StoreStatus>>(
                    "targetStatus",
                    |m: &ServerHBResp| { &m.targetStatus },
                    |m: &mut ServerHBResp| { &mut m.targetStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "aliveId",
                    |m: &ServerHBResp| { &m.aliveId },
                    |m: &mut ServerHBResp| { &mut m.aliveId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServerHBResp>(
                    "ServerHBResp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServerHBResp {
        static mut instance: ::protobuf::lazy::Lazy<ServerHBResp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServerHBResp,
        };
        unsafe {
            instance.get(ServerHBResp::new)
        }
    }
}

impl ::protobuf::Clear for ServerHBResp {
    fn clear(&mut self) {
        self.clear_resp();
        self.clear_partitions();
        self.clear_runtimeResp();
        self.clear_isLegal();
        self.clear_targetStatus();
        self.clear_aliveId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerHBResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHBResp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SimpleServerHBResponse {
    // message fields
    pub resp: ::protobuf::SingularPtrField<super::common::Response>,
    pub workerInfoProtos: ::protobuf::SingularPtrField<WorkerInfoProtos>,
    pub isLegal: bool,
    pub snapshotId: i64,
    pub servingServerId: ::std::vec::Vec<i32>,
    pub aliveId: u64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SimpleServerHBResponse {
    pub fn new() -> SimpleServerHBResponse {
        ::std::default::Default::default()
    }

    // .Response resp = 1;

    pub fn clear_resp(&mut self) {
        self.resp.clear();
    }

    pub fn has_resp(&self) -> bool {
        self.resp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resp(&mut self, v: super::common::Response) {
        self.resp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resp(&mut self) -> &mut super::common::Response {
        if self.resp.is_none() {
            self.resp.set_default();
        }
        self.resp.as_mut().unwrap()
    }

    // Take field
    pub fn take_resp(&mut self) -> super::common::Response {
        self.resp.take().unwrap_or_else(|| super::common::Response::new())
    }

    pub fn get_resp(&self) -> &super::common::Response {
        self.resp.as_ref().unwrap_or_else(|| super::common::Response::default_instance())
    }

    // .WorkerInfoProtos workerInfoProtos = 2;

    pub fn clear_workerInfoProtos(&mut self) {
        self.workerInfoProtos.clear();
    }

    pub fn has_workerInfoProtos(&self) -> bool {
        self.workerInfoProtos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workerInfoProtos(&mut self, v: WorkerInfoProtos) {
        self.workerInfoProtos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workerInfoProtos(&mut self) -> &mut WorkerInfoProtos {
        if self.workerInfoProtos.is_none() {
            self.workerInfoProtos.set_default();
        }
        self.workerInfoProtos.as_mut().unwrap()
    }

    // Take field
    pub fn take_workerInfoProtos(&mut self) -> WorkerInfoProtos {
        self.workerInfoProtos.take().unwrap_or_else(|| WorkerInfoProtos::new())
    }

    pub fn get_workerInfoProtos(&self) -> &WorkerInfoProtos {
        self.workerInfoProtos.as_ref().unwrap_or_else(|| WorkerInfoProtos::default_instance())
    }

    // bool isLegal = 3;

    pub fn clear_isLegal(&mut self) {
        self.isLegal = false;
    }

    // Param is passed by value, moved
    pub fn set_isLegal(&mut self, v: bool) {
        self.isLegal = v;
    }

    pub fn get_isLegal(&self) -> bool {
        self.isLegal
    }

    // int64 snapshotId = 4;

    pub fn clear_snapshotId(&mut self) {
        self.snapshotId = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshotId(&mut self, v: i64) {
        self.snapshotId = v;
    }

    pub fn get_snapshotId(&self) -> i64 {
        self.snapshotId
    }

    // repeated int32 servingServerId = 5;

    pub fn clear_servingServerId(&mut self) {
        self.servingServerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_servingServerId(&mut self, v: ::std::vec::Vec<i32>) {
        self.servingServerId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servingServerId(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.servingServerId
    }

    // Take field
    pub fn take_servingServerId(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.servingServerId, ::std::vec::Vec::new())
    }

    pub fn get_servingServerId(&self) -> &[i32] {
        &self.servingServerId
    }

    // uint64 aliveId = 6;

    pub fn clear_aliveId(&mut self) {
        self.aliveId = 0;
    }

    // Param is passed by value, moved
    pub fn set_aliveId(&mut self, v: u64) {
        self.aliveId = v;
    }

    pub fn get_aliveId(&self) -> u64 {
        self.aliveId
    }
}

impl ::protobuf::Message for SimpleServerHBResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.resp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workerInfoProtos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resp)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workerInfoProtos)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isLegal = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshotId = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.servingServerId)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.aliveId = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workerInfoProtos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.isLegal != false {
            my_size += 2;
        }
        if self.snapshotId != 0 {
            my_size += ::protobuf::rt::value_size(4, self.snapshotId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.servingServerId {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.aliveId != 0 {
            my_size += ::protobuf::rt::value_size(6, self.aliveId, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workerInfoProtos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.isLegal != false {
            os.write_bool(3, self.isLegal)?;
        }
        if self.snapshotId != 0 {
            os.write_int64(4, self.snapshotId)?;
        }
        for v in &self.servingServerId {
            os.write_int32(5, *v)?;
        };
        if self.aliveId != 0 {
            os.write_uint64(6, self.aliveId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SimpleServerHBResponse {
        SimpleServerHBResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Response>>(
                    "resp",
                    |m: &SimpleServerHBResponse| { &m.resp },
                    |m: &mut SimpleServerHBResponse| { &mut m.resp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorkerInfoProtos>>(
                    "workerInfoProtos",
                    |m: &SimpleServerHBResponse| { &m.workerInfoProtos },
                    |m: &mut SimpleServerHBResponse| { &mut m.workerInfoProtos },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isLegal",
                    |m: &SimpleServerHBResponse| { &m.isLegal },
                    |m: &mut SimpleServerHBResponse| { &mut m.isLegal },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshotId",
                    |m: &SimpleServerHBResponse| { &m.snapshotId },
                    |m: &mut SimpleServerHBResponse| { &mut m.snapshotId },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "servingServerId",
                    |m: &SimpleServerHBResponse| { &m.servingServerId },
                    |m: &mut SimpleServerHBResponse| { &mut m.servingServerId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "aliveId",
                    |m: &SimpleServerHBResponse| { &m.aliveId },
                    |m: &mut SimpleServerHBResponse| { &mut m.aliveId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SimpleServerHBResponse>(
                    "SimpleServerHBResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SimpleServerHBResponse {
        static mut instance: ::protobuf::lazy::Lazy<SimpleServerHBResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SimpleServerHBResponse,
        };
        unsafe {
            instance.get(SimpleServerHBResponse::new)
        }
    }
}

impl ::protobuf::Clear for SimpleServerHBResponse {
    fn clear(&mut self) {
        self.clear_resp();
        self.clear_workerInfoProtos();
        self.clear_isLegal();
        self.clear_snapshotId();
        self.clear_servingServerId();
        self.clear_aliveId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SimpleServerHBResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SimpleServerHBResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerInfoProto {
    // message fields
    pub id: i32,
    pub address: ::protobuf::SingularPtrField<super::common::EndpointProto>,
    pub partitions: ::std::vec::Vec<u32>,
    pub roleType: super::cluster::RoleType,
    pub workerStatus: WorkerStatus,
    pub serverHBReq: ::protobuf::SingularPtrField<ServerHBReq>,
    pub logDir: ::std::string::String,
    pub lastReportTime: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerInfoProto {
    pub fn new() -> WorkerInfoProto {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }

    // .EndpointProto address = 2;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: super::common::EndpointProto) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut super::common::EndpointProto {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> super::common::EndpointProto {
        self.address.take().unwrap_or_else(|| super::common::EndpointProto::new())
    }

    pub fn get_address(&self) -> &super::common::EndpointProto {
        self.address.as_ref().unwrap_or_else(|| super::common::EndpointProto::default_instance())
    }

    // repeated uint32 partitions = 3;

    pub fn clear_partitions(&mut self) {
        self.partitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_partitions(&mut self, v: ::std::vec::Vec<u32>) {
        self.partitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partitions(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.partitions
    }

    // Take field
    pub fn take_partitions(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.partitions, ::std::vec::Vec::new())
    }

    pub fn get_partitions(&self) -> &[u32] {
        &self.partitions
    }

    // .RoleType roleType = 4;

    pub fn clear_roleType(&mut self) {
        self.roleType = super::cluster::RoleType::AM;
    }

    // Param is passed by value, moved
    pub fn set_roleType(&mut self, v: super::cluster::RoleType) {
        self.roleType = v;
    }

    pub fn get_roleType(&self) -> super::cluster::RoleType {
        self.roleType
    }

    // .WorkerStatus workerStatus = 5;

    pub fn clear_workerStatus(&mut self) {
        self.workerStatus = WorkerStatus::RUNNING;
    }

    // Param is passed by value, moved
    pub fn set_workerStatus(&mut self, v: WorkerStatus) {
        self.workerStatus = v;
    }

    pub fn get_workerStatus(&self) -> WorkerStatus {
        self.workerStatus
    }

    // .ServerHBReq serverHBReq = 6;

    pub fn clear_serverHBReq(&mut self) {
        self.serverHBReq.clear();
    }

    pub fn has_serverHBReq(&self) -> bool {
        self.serverHBReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverHBReq(&mut self, v: ServerHBReq) {
        self.serverHBReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverHBReq(&mut self) -> &mut ServerHBReq {
        if self.serverHBReq.is_none() {
            self.serverHBReq.set_default();
        }
        self.serverHBReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverHBReq(&mut self) -> ServerHBReq {
        self.serverHBReq.take().unwrap_or_else(|| ServerHBReq::new())
    }

    pub fn get_serverHBReq(&self) -> &ServerHBReq {
        self.serverHBReq.as_ref().unwrap_or_else(|| ServerHBReq::default_instance())
    }

    // string logDir = 7;

    pub fn clear_logDir(&mut self) {
        self.logDir.clear();
    }

    // Param is passed by value, moved
    pub fn set_logDir(&mut self, v: ::std::string::String) {
        self.logDir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logDir(&mut self) -> &mut ::std::string::String {
        &mut self.logDir
    }

    // Take field
    pub fn take_logDir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logDir, ::std::string::String::new())
    }

    pub fn get_logDir(&self) -> &str {
        &self.logDir
    }

    // int64 lastReportTime = 8;

    pub fn clear_lastReportTime(&mut self) {
        self.lastReportTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_lastReportTime(&mut self, v: i64) {
        self.lastReportTime = v;
    }

    pub fn get_lastReportTime(&self) -> i64 {
        self.lastReportTime
    }
}

impl ::protobuf::Message for WorkerInfoProto {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverHBReq {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.partitions)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.roleType, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.workerStatus, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serverHBReq)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logDir)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lastReportTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.partitions {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.roleType != super::cluster::RoleType::AM {
            my_size += ::protobuf::rt::enum_size(4, self.roleType);
        }
        if self.workerStatus != WorkerStatus::RUNNING {
            my_size += ::protobuf::rt::enum_size(5, self.workerStatus);
        }
        if let Some(ref v) = self.serverHBReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.logDir.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.logDir);
        }
        if self.lastReportTime != 0 {
            my_size += ::protobuf::rt::value_size(8, self.lastReportTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.partitions {
            os.write_uint32(3, *v)?;
        };
        if self.roleType != super::cluster::RoleType::AM {
            os.write_enum(4, self.roleType.value())?;
        }
        if self.workerStatus != WorkerStatus::RUNNING {
            os.write_enum(5, self.workerStatus.value())?;
        }
        if let Some(ref v) = self.serverHBReq.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.logDir.is_empty() {
            os.write_string(7, &self.logDir)?;
        }
        if self.lastReportTime != 0 {
            os.write_int64(8, self.lastReportTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerInfoProto {
        WorkerInfoProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &WorkerInfoProto| { &m.id },
                    |m: &mut WorkerInfoProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::EndpointProto>>(
                    "address",
                    |m: &WorkerInfoProto| { &m.address },
                    |m: &mut WorkerInfoProto| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "partitions",
                    |m: &WorkerInfoProto| { &m.partitions },
                    |m: &mut WorkerInfoProto| { &mut m.partitions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::cluster::RoleType>>(
                    "roleType",
                    |m: &WorkerInfoProto| { &m.roleType },
                    |m: &mut WorkerInfoProto| { &mut m.roleType },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WorkerStatus>>(
                    "workerStatus",
                    |m: &WorkerInfoProto| { &m.workerStatus },
                    |m: &mut WorkerInfoProto| { &mut m.workerStatus },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerHBReq>>(
                    "serverHBReq",
                    |m: &WorkerInfoProto| { &m.serverHBReq },
                    |m: &mut WorkerInfoProto| { &mut m.serverHBReq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "logDir",
                    |m: &WorkerInfoProto| { &m.logDir },
                    |m: &mut WorkerInfoProto| { &mut m.logDir },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lastReportTime",
                    |m: &WorkerInfoProto| { &m.lastReportTime },
                    |m: &mut WorkerInfoProto| { &mut m.lastReportTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerInfoProto>(
                    "WorkerInfoProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerInfoProto {
        static mut instance: ::protobuf::lazy::Lazy<WorkerInfoProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerInfoProto,
        };
        unsafe {
            instance.get(WorkerInfoProto::new)
        }
    }
}

impl ::protobuf::Clear for WorkerInfoProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_address();
        self.clear_partitions();
        self.clear_roleType();
        self.clear_workerStatus();
        self.clear_serverHBReq();
        self.clear_logDir();
        self.clear_lastReportTime();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerInfoProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInfoProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingServerInfoResp {
    // message fields
    pub resp: ::protobuf::SingularPtrField<super::common::Response>,
    pub workerInfoProtos: ::protobuf::SingularPtrField<WorkerInfoProtos>,
    pub servingServerId: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RoutingServerInfoResp {
    pub fn new() -> RoutingServerInfoResp {
        ::std::default::Default::default()
    }

    // .Response resp = 1;

    pub fn clear_resp(&mut self) {
        self.resp.clear();
    }

    pub fn has_resp(&self) -> bool {
        self.resp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resp(&mut self, v: super::common::Response) {
        self.resp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resp(&mut self) -> &mut super::common::Response {
        if self.resp.is_none() {
            self.resp.set_default();
        }
        self.resp.as_mut().unwrap()
    }

    // Take field
    pub fn take_resp(&mut self) -> super::common::Response {
        self.resp.take().unwrap_or_else(|| super::common::Response::new())
    }

    pub fn get_resp(&self) -> &super::common::Response {
        self.resp.as_ref().unwrap_or_else(|| super::common::Response::default_instance())
    }

    // .WorkerInfoProtos workerInfoProtos = 2;

    pub fn clear_workerInfoProtos(&mut self) {
        self.workerInfoProtos.clear();
    }

    pub fn has_workerInfoProtos(&self) -> bool {
        self.workerInfoProtos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workerInfoProtos(&mut self, v: WorkerInfoProtos) {
        self.workerInfoProtos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workerInfoProtos(&mut self) -> &mut WorkerInfoProtos {
        if self.workerInfoProtos.is_none() {
            self.workerInfoProtos.set_default();
        }
        self.workerInfoProtos.as_mut().unwrap()
    }

    // Take field
    pub fn take_workerInfoProtos(&mut self) -> WorkerInfoProtos {
        self.workerInfoProtos.take().unwrap_or_else(|| WorkerInfoProtos::new())
    }

    pub fn get_workerInfoProtos(&self) -> &WorkerInfoProtos {
        self.workerInfoProtos.as_ref().unwrap_or_else(|| WorkerInfoProtos::default_instance())
    }

    // repeated int32 servingServerId = 3;

    pub fn clear_servingServerId(&mut self) {
        self.servingServerId.clear();
    }

    // Param is passed by value, moved
    pub fn set_servingServerId(&mut self, v: ::std::vec::Vec<i32>) {
        self.servingServerId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servingServerId(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.servingServerId
    }

    // Take field
    pub fn take_servingServerId(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.servingServerId, ::std::vec::Vec::new())
    }

    pub fn get_servingServerId(&self) -> &[i32] {
        &self.servingServerId
    }
}

impl ::protobuf::Message for RoutingServerInfoResp {
    fn is_initialized(&self) -> bool {
        for v in &self.resp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.workerInfoProtos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resp)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.workerInfoProtos)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.servingServerId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.workerInfoProtos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.servingServerId {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.workerInfoProtos.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.servingServerId {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingServerInfoResp {
        RoutingServerInfoResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Response>>(
                    "resp",
                    |m: &RoutingServerInfoResp| { &m.resp },
                    |m: &mut RoutingServerInfoResp| { &mut m.resp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorkerInfoProtos>>(
                    "workerInfoProtos",
                    |m: &RoutingServerInfoResp| { &m.workerInfoProtos },
                    |m: &mut RoutingServerInfoResp| { &mut m.workerInfoProtos },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "servingServerId",
                    |m: &RoutingServerInfoResp| { &m.servingServerId },
                    |m: &mut RoutingServerInfoResp| { &mut m.servingServerId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RoutingServerInfoResp>(
                    "RoutingServerInfoResp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RoutingServerInfoResp {
        static mut instance: ::protobuf::lazy::Lazy<RoutingServerInfoResp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RoutingServerInfoResp,
        };
        unsafe {
            instance.get(RoutingServerInfoResp::new)
        }
    }
}

impl ::protobuf::Clear for RoutingServerInfoResp {
    fn clear(&mut self) {
        self.clear_resp();
        self.clear_workerInfoProtos();
        self.clear_servingServerId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingServerInfoResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingServerInfoResp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WorkerInfoProtos {
    // message fields
    pub infos: ::protobuf::RepeatedField<WorkerInfoProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WorkerInfoProtos {
    pub fn new() -> WorkerInfoProtos {
        ::std::default::Default::default()
    }

    // repeated .WorkerInfoProto infos = 1;

    pub fn clear_infos(&mut self) {
        self.infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_infos(&mut self, v: ::protobuf::RepeatedField<WorkerInfoProto>) {
        self.infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_infos(&mut self) -> &mut ::protobuf::RepeatedField<WorkerInfoProto> {
        &mut self.infos
    }

    // Take field
    pub fn take_infos(&mut self) -> ::protobuf::RepeatedField<WorkerInfoProto> {
        ::std::mem::replace(&mut self.infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_infos(&self) -> &[WorkerInfoProto] {
        &self.infos
    }
}

impl ::protobuf::Message for WorkerInfoProtos {
    fn is_initialized(&self) -> bool {
        for v in &self.infos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.infos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.infos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WorkerInfoProtos {
        WorkerInfoProtos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WorkerInfoProto>>(
                    "infos",
                    |m: &WorkerInfoProtos| { &m.infos },
                    |m: &mut WorkerInfoProtos| { &mut m.infos },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WorkerInfoProtos>(
                    "WorkerInfoProtos",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WorkerInfoProtos {
        static mut instance: ::protobuf::lazy::Lazy<WorkerInfoProtos> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WorkerInfoProtos,
        };
        unsafe {
            instance.get(WorkerInfoProtos::new)
        }
    }
}

impl ::protobuf::Clear for WorkerInfoProtos {
    fn clear(&mut self) {
        self.clear_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WorkerInfoProtos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerInfoProtos {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartitionProtos {
    // message fields
    pub partitionId: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PartitionProtos {
    pub fn new() -> PartitionProtos {
        ::std::default::Default::default()
    }

    // repeated int32 partitionId = 1;

    pub fn clear_partitionId(&mut self) {
        self.partitionId.clear();
    }

    // Param is passed by value, moved
    pub fn set_partitionId(&mut self, v: ::std::vec::Vec<i32>) {
        self.partitionId = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partitionId(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.partitionId
    }

    // Take field
    pub fn take_partitionId(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.partitionId, ::std::vec::Vec::new())
    }

    pub fn get_partitionId(&self) -> &[i32] {
        &self.partitionId
    }
}

impl ::protobuf::Message for PartitionProtos {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.partitionId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.partitionId {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.partitionId {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartitionProtos {
        PartitionProtos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partitionId",
                    |m: &PartitionProtos| { &m.partitionId },
                    |m: &mut PartitionProtos| { &mut m.partitionId },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PartitionProtos>(
                    "PartitionProtos",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PartitionProtos {
        static mut instance: ::protobuf::lazy::Lazy<PartitionProtos> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PartitionProtos,
        };
        unsafe {
            instance.get(PartitionProtos::new)
        }
    }
}

impl ::protobuf::Clear for PartitionProtos {
    fn clear(&mut self) {
        self.clear_partitionId();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartitionProtos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionProtos {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimestampRequest {
    // message fields
    pub timestamp: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TimestampRequest {
    pub fn new() -> TimestampRequest {
        ::std::default::Default::default()
    }

    // int64 timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
}

impl ::protobuf::Message for TimestampRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(1, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.timestamp != 0 {
            os.write_int64(1, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimestampRequest {
        TimestampRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &TimestampRequest| { &m.timestamp },
                    |m: &mut TimestampRequest| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimestampRequest>(
                    "TimestampRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimestampRequest {
        static mut instance: ::protobuf::lazy::Lazy<TimestampRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimestampRequest,
        };
        unsafe {
            instance.get(TimestampRequest::new)
        }
    }
}

impl ::protobuf::Clear for TimestampRequest {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimestampRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimestampRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StoreStatus {
    INITIALING = 0,
    RECOVERED = 1,
    STARTED = 2,
}

impl ::protobuf::ProtobufEnum for StoreStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StoreStatus> {
        match value {
            0 => ::std::option::Option::Some(StoreStatus::INITIALING),
            1 => ::std::option::Option::Some(StoreStatus::RECOVERED),
            2 => ::std::option::Option::Some(StoreStatus::STARTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StoreStatus] = &[
            StoreStatus::INITIALING,
            StoreStatus::RECOVERED,
            StoreStatus::STARTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StoreStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StoreStatus {
}

impl ::std::default::Default for StoreStatus {
    fn default() -> Self {
        StoreStatus::INITIALING
    }
}

impl ::protobuf::reflect::ProtobufValue for StoreStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WorkerStatus {
    RUNNING = 0,
    LOST = 1,
    RESTARTING = 2,
    STARTING = 3,
}

impl ::protobuf::ProtobufEnum for WorkerStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WorkerStatus> {
        match value {
            0 => ::std::option::Option::Some(WorkerStatus::RUNNING),
            1 => ::std::option::Option::Some(WorkerStatus::LOST),
            2 => ::std::option::Option::Some(WorkerStatus::RESTARTING),
            3 => ::std::option::Option::Some(WorkerStatus::STARTING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WorkerStatus] = &[
            WorkerStatus::RUNNING,
            WorkerStatus::LOST,
            WorkerStatus::RESTARTING,
            WorkerStatus::STARTING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("WorkerStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for WorkerStatus {
}

impl ::std::default::Default for WorkerStatus {
    fn default() -> Self {
        WorkerStatus::RUNNING
    }
}

impl ::protobuf::reflect::ProtobufValue for WorkerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08hb.proto\x1a\x10sdk/common.proto\x1a\x10sdk/schema.proto\x1a\rclus\
    ter.proto\"6\n\x0eEndpointsProto\x12$\n\x05addrs\x18\x01\x20\x03(\x0b2\
    \x0e.EndpointProtoR\x05addrs\"|\n\nStatistics\x122\n\x07metrics\x18\x01\
    \x20\x03(\x0b2\x18.Statistics.MetricsEntryR\x07metrics\x1a:\n\x0cMetrics\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x01R\x05value:\x028\x01\"\x92\x02\n\x0cRuntimeHBReq\x12?\n\
    \x0cserverStatus\x18\x01\x20\x01(\x0e2\x1b.RuntimeHBReq.RuntimeStatusR\
    \x0cserverStatus\x12\x20\n\x0bruntimePort\x18\x02\x20\x01(\x05R\x0brunti\
    mePort\x123\n\x16worker_num_per_process\x18\x03\x20\x01(\rR\x13workerNum\
    PerProcess\x124\n\x16process_partition_list\x18\x04\x20\x03(\rR\x14proce\
    ssPartitionList\"4\n\rRuntimeStatus\x12\x08\n\x04DOWN\x10\0\x12\x0c\n\
    \x08STARTING\x10\x01\x12\x0b\n\x07RUNNING\x10\x02\"\xdf\x01\n\rRuntimeHB\
    Resp\x12\x18\n\x07version\x18\x01\x20\x01(\x03R\x07version\x12\x1a\n\x08\
    workerId\x18\x02\x20\x01(\rR\x08workerId\x122\n\taddresses\x18\x03\x20\
    \x03(\x0b2\x14.RuntimeAddressProtoR\taddresses\x12\x18\n\x07groupId\x18\
    \x04\x20\x01(\rR\x07groupId\x12J\n\x13task_partition_list\x18\x05\x20\
    \x03(\x0b2\x1a.RuntimeTaskPartitionProtoR\x11taskPartitionList\"\x86\x01\
    \n\x19RuntimeTaskPartitionProto\x12\x1d\n\ntask_index\x18\x01\x20\x01(\r\
    R\ttaskIndex\x12#\n\rprocess_index\x18\x02\x20\x01(\rR\x0cprocessIndex\
    \x12%\n\x0epartition_list\x18\x03\x20\x03(\rR\rpartitionList\"g\n\x13Run\
    timeAddressProto\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1d\n\nst\
    ore_port\x18\x02\x20\x01(\x05R\tstorePort\x12!\n\x0cruntime_port\x18\x03\
    \x20\x01(\x05R\x0bruntimePort\"\xbb\x02\n\x0bServerHBReq\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\rR\x02id\x12*\n\x08endpoint\x18\x02\x20\x01(\x0b2\x0e.\
    EndpointProtoR\x08endpoint\x12$\n\rheartbeatTime\x18\x08\x20\x01(\x03R\r\
    heartbeatTime\x12+\n\nstatistics\x18\t\x20\x01(\x0b2\x0b.StatisticsR\nst\
    atistics\x12-\n\nruntimeReq\x18\n\x20\x01(\x0b2\r.RuntimeHBReqR\nruntime\
    Req\x12\x18\n\x07aliveId\x18\x0b\x20\x01(\x04R\x07aliveId\x12$\n\x06stat\
    us\x18\x0c\x20\x01(\x0e2\x0c.StoreStatusR\x06status\x12.\n\tinfoProto\
    \x18\r\x20\x01(\x0b2\x10.MetricInfoProtoR\tinfoProto\"\x9d\x02\n\x11Simp\
    leServerHBReq\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12*\n\x08endpoi\
    nt\x18\x02\x20\x01(\x0b2\x0e.EndpointProtoR\x08endpoint\x12%\n\x08roleTy\
    pe\x18\x03\x20\x01(\x0e2\t.RoleTypeR\x08roleType\x12+\n\nstatistics\x18\
    \x04\x20\x01(\x0b2\x0b.StatisticsR\nstatistics\x12\x16\n\x06logDir\x18\
    \x05\x20\x01(\tR\x06logDir\x12\x18\n\x07aliveId\x18\x06\x20\x01(\x04R\
    \x07aliveId\x12\x16\n\x06nodeId\x18\x07\x20\x01(\x05R\x06nodeId\x12.\n\t\
    infoProto\x18\x08\x20\x01(\x0b2\x10.MetricInfoProtoR\tinfoProto\"\xe5\
    \x01\n\x0cServerHBResp\x12\x1d\n\x04resp\x18\x01\x20\x01(\x0b2\t.Respons\
    eR\x04resp\x12\x1e\n\npartitions\x18\x04\x20\x03(\rR\npartitions\x120\n\
    \x0bruntimeResp\x18\x06\x20\x01(\x0b2\x0e.RuntimeHBRespR\x0bruntimeResp\
    \x12\x18\n\x07isLegal\x18\x07\x20\x01(\x08R\x07isLegal\x120\n\x0ctargetS\
    tatus\x18\n\x20\x01(\x0e2\x0c.StoreStatusR\x0ctargetStatus\x12\x18\n\x07\
    aliveId\x18\x0b\x20\x01(\x04R\x07aliveId\"\xf4\x01\n\x16SimpleServerHBRe\
    sponse\x12\x1d\n\x04resp\x18\x01\x20\x01(\x0b2\t.ResponseR\x04resp\x12=\
    \n\x10workerInfoProtos\x18\x02\x20\x01(\x0b2\x11.WorkerInfoProtosR\x10wo\
    rkerInfoProtos\x12\x18\n\x07isLegal\x18\x03\x20\x01(\x08R\x07isLegal\x12\
    \x1e\n\nsnapshotId\x18\x04\x20\x01(\x03R\nsnapshotId\x12(\n\x0fservingSe\
    rverId\x18\x05\x20\x03(\x05R\x0fservingServerId\x12\x18\n\x07aliveId\x18\
    \x06\x20\x01(\x04R\x07aliveId\"\xb5\x02\n\x0fWorkerInfoProto\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x05R\x02id\x12(\n\x07address\x18\x02\x20\x01(\
    \x0b2\x0e.EndpointProtoR\x07address\x12\x1e\n\npartitions\x18\x03\x20\
    \x03(\rR\npartitions\x12%\n\x08roleType\x18\x04\x20\x01(\x0e2\t.RoleType\
    R\x08roleType\x121\n\x0cworkerStatus\x18\x05\x20\x01(\x0e2\r.WorkerStatu\
    sR\x0cworkerStatus\x12.\n\x0bserverHBReq\x18\x06\x20\x01(\x0b2\x0c.Serve\
    rHBReqR\x0bserverHBReq\x12\x16\n\x06logDir\x18\x07\x20\x01(\tR\x06logDir\
    \x12&\n\x0elastReportTime\x18\x08\x20\x01(\x03R\x0elastReportTime\"\x9f\
    \x01\n\x15RoutingServerInfoResp\x12\x1d\n\x04resp\x18\x01\x20\x01(\x0b2\
    \t.ResponseR\x04resp\x12=\n\x10workerInfoProtos\x18\x02\x20\x01(\x0b2\
    \x11.WorkerInfoProtosR\x10workerInfoProtos\x12(\n\x0fservingServerId\x18\
    \x03\x20\x03(\x05R\x0fservingServerId\":\n\x10WorkerInfoProtos\x12&\n\
    \x05infos\x18\x01\x20\x03(\x0b2\x10.WorkerInfoProtoR\x05infos\"3\n\x0fPa\
    rtitionProtos\x12\x20\n\x0bpartitionId\x18\x01\x20\x03(\x05R\x0bpartitio\
    nId\"0\n\x10TimestampRequest\x12\x1c\n\ttimestamp\x18\x01\x20\x01(\x03R\
    \ttimestamp*9\n\x0bStoreStatus\x12\x0e\n\nINITIALING\x10\0\x12\r\n\tRECO\
    VERED\x10\x01\x12\x0b\n\x07STARTED\x10\x02*C\n\x0cWorkerStatus\x12\x0b\n\
    \x07RUNNING\x10\0\x12\x08\n\x04LOST\x10\x01\x12\x0e\n\nRESTARTING\x10\
    \x02\x12\x0c\n\x08STARTING\x10\x03B!\n\x1acom.alibaba.maxgraph.protoP\
    \x01\xa0\x01\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
