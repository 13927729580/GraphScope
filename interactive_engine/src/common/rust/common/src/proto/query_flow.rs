//
//! Copyright 2020 Alibaba Group Holding Limited.
//! 
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//! 
//!     http://www.apache.org/licenses/LICENSE-2.0
//! 
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct QueryFlow {
    // message fields
    pub query_id: ::std::string::String,
    pub query_plan: ::protobuf::SingularPtrField<QueryPlan>,
    pub sink_op: ::protobuf::SingularPtrField<SinkOperator>,
    pub config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub graph_name: ::std::string::String,
    pub parallelism: i32,
    pub host_ip: ::protobuf::RepeatedField<::std::string::String>,
    pub snapshot: i64,
    pub script: ::std::string::String,
    pub timeout_ms: u64,
    pub global_stop_op_list: ::std::vec::Vec<i32>,
    pub scop_stop_op_list: ::std::collections::HashMap<::std::string::String, super::message::ListInt>,
    pub input_batch_level: InputBatchLevel,
    pub debug_log_flag: bool,
    pub start_timestamp_ms: u64,
    pub front_id: u32,
    pub exec_local_flag: bool,
    pub lambda_existed: bool,
    pub bytecode: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryFlow {
    pub fn new() -> QueryFlow {
        ::std::default::Default::default()
    }

    // string query_id = 1;

    pub fn clear_query_id(&mut self) {
        self.query_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_id(&mut self, v: ::std::string::String) {
        self.query_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_id(&mut self) -> &mut ::std::string::String {
        &mut self.query_id
    }

    // Take field
    pub fn take_query_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query_id, ::std::string::String::new())
    }

    pub fn get_query_id(&self) -> &str {
        &self.query_id
    }

    // .maxgraph.QueryPlan query_plan = 2;

    pub fn clear_query_plan(&mut self) {
        self.query_plan.clear();
    }

    pub fn has_query_plan(&self) -> bool {
        self.query_plan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_plan(&mut self, v: QueryPlan) {
        self.query_plan = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_plan(&mut self) -> &mut QueryPlan {
        if self.query_plan.is_none() {
            self.query_plan.set_default();
        }
        self.query_plan.as_mut().unwrap()
    }

    // Take field
    pub fn take_query_plan(&mut self) -> QueryPlan {
        self.query_plan.take().unwrap_or_else(|| QueryPlan::new())
    }

    pub fn get_query_plan(&self) -> &QueryPlan {
        self.query_plan.as_ref().unwrap_or_else(|| QueryPlan::default_instance())
    }

    // .maxgraph.SinkOperator sink_op = 3;

    pub fn clear_sink_op(&mut self) {
        self.sink_op.clear();
    }

    pub fn has_sink_op(&self) -> bool {
        self.sink_op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sink_op(&mut self, v: SinkOperator) {
        self.sink_op = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sink_op(&mut self) -> &mut SinkOperator {
        if self.sink_op.is_none() {
            self.sink_op.set_default();
        }
        self.sink_op.as_mut().unwrap()
    }

    // Take field
    pub fn take_sink_op(&mut self) -> SinkOperator {
        self.sink_op.take().unwrap_or_else(|| SinkOperator::new())
    }

    pub fn get_sink_op(&self) -> &SinkOperator {
        self.sink_op.as_ref().unwrap_or_else(|| SinkOperator::default_instance())
    }

    // repeated .maxgraph.QueryFlow.ConfigEntry config = 4;

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.config
    }

    // Take field
    pub fn take_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.config, ::std::collections::HashMap::new())
    }

    pub fn get_config(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.config
    }

    // string graph_name = 5;

    pub fn clear_graph_name(&mut self) {
        self.graph_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_name(&mut self, v: ::std::string::String) {
        self.graph_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_name(&mut self) -> &mut ::std::string::String {
        &mut self.graph_name
    }

    // Take field
    pub fn take_graph_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_name, ::std::string::String::new())
    }

    pub fn get_graph_name(&self) -> &str {
        &self.graph_name
    }

    // int32 parallelism = 6;

    pub fn clear_parallelism(&mut self) {
        self.parallelism = 0;
    }

    // Param is passed by value, moved
    pub fn set_parallelism(&mut self, v: i32) {
        self.parallelism = v;
    }

    pub fn get_parallelism(&self) -> i32 {
        self.parallelism
    }

    // repeated string host_ip = 7;

    pub fn clear_host_ip(&mut self) {
        self.host_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_ip(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.host_ip = v;
    }

    // Mutable pointer to the field.
    pub fn mut_host_ip(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.host_ip
    }

    // Take field
    pub fn take_host_ip(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.host_ip, ::protobuf::RepeatedField::new())
    }

    pub fn get_host_ip(&self) -> &[::std::string::String] {
        &self.host_ip
    }

    // int64 snapshot = 8;

    pub fn clear_snapshot(&mut self) {
        self.snapshot = 0;
    }

    // Param is passed by value, moved
    pub fn set_snapshot(&mut self, v: i64) {
        self.snapshot = v;
    }

    pub fn get_snapshot(&self) -> i64 {
        self.snapshot
    }

    // string script = 9;

    pub fn clear_script(&mut self) {
        self.script.clear();
    }

    // Param is passed by value, moved
    pub fn set_script(&mut self, v: ::std::string::String) {
        self.script = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_script(&mut self) -> &mut ::std::string::String {
        &mut self.script
    }

    // Take field
    pub fn take_script(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.script, ::std::string::String::new())
    }

    pub fn get_script(&self) -> &str {
        &self.script
    }

    // uint64 timeout_ms = 10;

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: u64) {
        self.timeout_ms = v;
    }

    pub fn get_timeout_ms(&self) -> u64 {
        self.timeout_ms
    }

    // repeated int32 global_stop_op_list = 11;

    pub fn clear_global_stop_op_list(&mut self) {
        self.global_stop_op_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_global_stop_op_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.global_stop_op_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_global_stop_op_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.global_stop_op_list
    }

    // Take field
    pub fn take_global_stop_op_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.global_stop_op_list, ::std::vec::Vec::new())
    }

    pub fn get_global_stop_op_list(&self) -> &[i32] {
        &self.global_stop_op_list
    }

    // repeated .maxgraph.QueryFlow.ScopStopOpListEntry scop_stop_op_list = 12;

    pub fn clear_scop_stop_op_list(&mut self) {
        self.scop_stop_op_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_scop_stop_op_list(&mut self, v: ::std::collections::HashMap<::std::string::String, super::message::ListInt>) {
        self.scop_stop_op_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scop_stop_op_list(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::message::ListInt> {
        &mut self.scop_stop_op_list
    }

    // Take field
    pub fn take_scop_stop_op_list(&mut self) -> ::std::collections::HashMap<::std::string::String, super::message::ListInt> {
        ::std::mem::replace(&mut self.scop_stop_op_list, ::std::collections::HashMap::new())
    }

    pub fn get_scop_stop_op_list(&self) -> &::std::collections::HashMap<::std::string::String, super::message::ListInt> {
        &self.scop_stop_op_list
    }

    // .maxgraph.InputBatchLevel input_batch_level = 13;

    pub fn clear_input_batch_level(&mut self) {
        self.input_batch_level = InputBatchLevel::Medium;
    }

    // Param is passed by value, moved
    pub fn set_input_batch_level(&mut self, v: InputBatchLevel) {
        self.input_batch_level = v;
    }

    pub fn get_input_batch_level(&self) -> InputBatchLevel {
        self.input_batch_level
    }

    // bool debug_log_flag = 14;

    pub fn clear_debug_log_flag(&mut self) {
        self.debug_log_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_debug_log_flag(&mut self, v: bool) {
        self.debug_log_flag = v;
    }

    pub fn get_debug_log_flag(&self) -> bool {
        self.debug_log_flag
    }

    // uint64 start_timestamp_ms = 15;

    pub fn clear_start_timestamp_ms(&mut self) {
        self.start_timestamp_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_start_timestamp_ms(&mut self, v: u64) {
        self.start_timestamp_ms = v;
    }

    pub fn get_start_timestamp_ms(&self) -> u64 {
        self.start_timestamp_ms
    }

    // uint32 front_id = 16;

    pub fn clear_front_id(&mut self) {
        self.front_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_front_id(&mut self, v: u32) {
        self.front_id = v;
    }

    pub fn get_front_id(&self) -> u32 {
        self.front_id
    }

    // bool exec_local_flag = 17;

    pub fn clear_exec_local_flag(&mut self) {
        self.exec_local_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_exec_local_flag(&mut self, v: bool) {
        self.exec_local_flag = v;
    }

    pub fn get_exec_local_flag(&self) -> bool {
        self.exec_local_flag
    }

    // bool lambda_existed = 18;

    pub fn clear_lambda_existed(&mut self) {
        self.lambda_existed = false;
    }

    // Param is passed by value, moved
    pub fn set_lambda_existed(&mut self, v: bool) {
        self.lambda_existed = v;
    }

    pub fn get_lambda_existed(&self) -> bool {
        self.lambda_existed
    }

    // bytes bytecode = 20;

    pub fn clear_bytecode(&mut self) {
        self.bytecode.clear();
    }

    // Param is passed by value, moved
    pub fn set_bytecode(&mut self, v: ::std::vec::Vec<u8>) {
        self.bytecode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytecode(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bytecode
    }

    // Take field
    pub fn take_bytecode(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bytecode, ::std::vec::Vec::new())
    }

    pub fn get_bytecode(&self) -> &[u8] {
        &self.bytecode
    }
}

impl ::protobuf::Message for QueryFlow {
    fn is_initialized(&self) -> bool {
        for v in &self.query_plan {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sink_op {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.query_plan)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sink_op)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.parallelism = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.host_ip)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.snapshot = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.script)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeout_ms = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.global_stop_op_list)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::message::ListInt>>(wire_type, is, &mut self.scop_stop_op_list)?;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.input_batch_level, 13, &mut self.unknown_fields)?
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.debug_log_flag = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.start_timestamp_ms = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.front_id = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exec_local_flag = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lambda_existed = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bytecode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query_id);
        }
        if let Some(ref v) = self.query_plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sink_op.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.config);
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.graph_name);
        }
        if self.parallelism != 0 {
            my_size += ::protobuf::rt::value_size(6, self.parallelism, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.host_ip {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if self.snapshot != 0 {
            my_size += ::protobuf::rt::value_size(8, self.snapshot, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.script.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.script);
        }
        if self.timeout_ms != 0 {
            my_size += ::protobuf::rt::value_size(10, self.timeout_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.global_stop_op_list {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::message::ListInt>>(12, &self.scop_stop_op_list);
        if self.input_batch_level != InputBatchLevel::Medium {
            my_size += ::protobuf::rt::enum_size(13, self.input_batch_level);
        }
        if self.debug_log_flag != false {
            my_size += 2;
        }
        if self.start_timestamp_ms != 0 {
            my_size += ::protobuf::rt::value_size(15, self.start_timestamp_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.front_id != 0 {
            my_size += ::protobuf::rt::value_size(16, self.front_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.exec_local_flag != false {
            my_size += 3;
        }
        if self.lambda_existed != false {
            my_size += 3;
        }
        if !self.bytecode.is_empty() {
            my_size += ::protobuf::rt::bytes_size(20, &self.bytecode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.query_id.is_empty() {
            os.write_string(1, &self.query_id)?;
        }
        if let Some(ref v) = self.query_plan.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sink_op.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.config, os)?;
        if !self.graph_name.is_empty() {
            os.write_string(5, &self.graph_name)?;
        }
        if self.parallelism != 0 {
            os.write_int32(6, self.parallelism)?;
        }
        for v in &self.host_ip {
            os.write_string(7, &v)?;
        };
        if self.snapshot != 0 {
            os.write_int64(8, self.snapshot)?;
        }
        if !self.script.is_empty() {
            os.write_string(9, &self.script)?;
        }
        if self.timeout_ms != 0 {
            os.write_uint64(10, self.timeout_ms)?;
        }
        for v in &self.global_stop_op_list {
            os.write_int32(11, *v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::message::ListInt>>(12, &self.scop_stop_op_list, os)?;
        if self.input_batch_level != InputBatchLevel::Medium {
            os.write_enum(13, self.input_batch_level.value())?;
        }
        if self.debug_log_flag != false {
            os.write_bool(14, self.debug_log_flag)?;
        }
        if self.start_timestamp_ms != 0 {
            os.write_uint64(15, self.start_timestamp_ms)?;
        }
        if self.front_id != 0 {
            os.write_uint32(16, self.front_id)?;
        }
        if self.exec_local_flag != false {
            os.write_bool(17, self.exec_local_flag)?;
        }
        if self.lambda_existed != false {
            os.write_bool(18, self.lambda_existed)?;
        }
        if !self.bytecode.is_empty() {
            os.write_bytes(20, &self.bytecode)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryFlow {
        QueryFlow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query_id",
                    |m: &QueryFlow| { &m.query_id },
                    |m: &mut QueryFlow| { &mut m.query_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryPlan>>(
                    "query_plan",
                    |m: &QueryFlow| { &m.query_plan },
                    |m: &mut QueryFlow| { &mut m.query_plan },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SinkOperator>>(
                    "sink_op",
                    |m: &QueryFlow| { &m.sink_op },
                    |m: &mut QueryFlow| { &mut m.sink_op },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "config",
                    |m: &QueryFlow| { &m.config },
                    |m: &mut QueryFlow| { &mut m.config },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "graph_name",
                    |m: &QueryFlow| { &m.graph_name },
                    |m: &mut QueryFlow| { &mut m.graph_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "parallelism",
                    |m: &QueryFlow| { &m.parallelism },
                    |m: &mut QueryFlow| { &mut m.parallelism },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host_ip",
                    |m: &QueryFlow| { &m.host_ip },
                    |m: &mut QueryFlow| { &mut m.host_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "snapshot",
                    |m: &QueryFlow| { &m.snapshot },
                    |m: &mut QueryFlow| { &mut m.snapshot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "script",
                    |m: &QueryFlow| { &m.script },
                    |m: &mut QueryFlow| { &mut m.script },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timeout_ms",
                    |m: &QueryFlow| { &m.timeout_ms },
                    |m: &mut QueryFlow| { &mut m.timeout_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "global_stop_op_list",
                    |m: &QueryFlow| { &m.global_stop_op_list },
                    |m: &mut QueryFlow| { &mut m.global_stop_op_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::message::ListInt>>(
                    "scop_stop_op_list",
                    |m: &QueryFlow| { &m.scop_stop_op_list },
                    |m: &mut QueryFlow| { &mut m.scop_stop_op_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InputBatchLevel>>(
                    "input_batch_level",
                    |m: &QueryFlow| { &m.input_batch_level },
                    |m: &mut QueryFlow| { &mut m.input_batch_level },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "debug_log_flag",
                    |m: &QueryFlow| { &m.debug_log_flag },
                    |m: &mut QueryFlow| { &mut m.debug_log_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "start_timestamp_ms",
                    |m: &QueryFlow| { &m.start_timestamp_ms },
                    |m: &mut QueryFlow| { &mut m.start_timestamp_ms },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "front_id",
                    |m: &QueryFlow| { &m.front_id },
                    |m: &mut QueryFlow| { &mut m.front_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "exec_local_flag",
                    |m: &QueryFlow| { &m.exec_local_flag },
                    |m: &mut QueryFlow| { &mut m.exec_local_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "lambda_existed",
                    |m: &QueryFlow| { &m.lambda_existed },
                    |m: &mut QueryFlow| { &mut m.lambda_existed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "bytecode",
                    |m: &QueryFlow| { &m.bytecode },
                    |m: &mut QueryFlow| { &mut m.bytecode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryFlow>(
                    "QueryFlow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryFlow {
        static mut instance: ::protobuf::lazy::Lazy<QueryFlow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryFlow,
        };
        unsafe {
            instance.get(QueryFlow::new)
        }
    }
}

impl ::protobuf::Clear for QueryFlow {
    fn clear(&mut self) {
        self.clear_query_id();
        self.clear_query_plan();
        self.clear_sink_op();
        self.clear_config();
        self.clear_graph_name();
        self.clear_parallelism();
        self.clear_host_ip();
        self.clear_snapshot();
        self.clear_script();
        self.clear_timeout_ms();
        self.clear_global_stop_op_list();
        self.clear_scop_stop_op_list();
        self.clear_input_batch_level();
        self.clear_debug_log_flag();
        self.clear_start_timestamp_ms();
        self.clear_front_id();
        self.clear_exec_local_flag();
        self.clear_lambda_existed();
        self.clear_bytecode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryFlow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryFlow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryPlan {
    // message fields
    pub source_op: ::protobuf::SingularPtrField<SourceOperator>,
    pub unary_op: ::protobuf::RepeatedField<UnaryOperator>,
    pub binary_op: ::protobuf::RepeatedField<BinaryOperator>,
    pub operator_id_list: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryPlan {
    pub fn new() -> QueryPlan {
        ::std::default::Default::default()
    }

    // .maxgraph.SourceOperator source_op = 1;

    pub fn clear_source_op(&mut self) {
        self.source_op.clear();
    }

    pub fn has_source_op(&self) -> bool {
        self.source_op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_op(&mut self, v: SourceOperator) {
        self.source_op = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_op(&mut self) -> &mut SourceOperator {
        if self.source_op.is_none() {
            self.source_op.set_default();
        }
        self.source_op.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_op(&mut self) -> SourceOperator {
        self.source_op.take().unwrap_or_else(|| SourceOperator::new())
    }

    pub fn get_source_op(&self) -> &SourceOperator {
        self.source_op.as_ref().unwrap_or_else(|| SourceOperator::default_instance())
    }

    // repeated .maxgraph.UnaryOperator unary_op = 2;

    pub fn clear_unary_op(&mut self) {
        self.unary_op.clear();
    }

    // Param is passed by value, moved
    pub fn set_unary_op(&mut self, v: ::protobuf::RepeatedField<UnaryOperator>) {
        self.unary_op = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unary_op(&mut self) -> &mut ::protobuf::RepeatedField<UnaryOperator> {
        &mut self.unary_op
    }

    // Take field
    pub fn take_unary_op(&mut self) -> ::protobuf::RepeatedField<UnaryOperator> {
        ::std::mem::replace(&mut self.unary_op, ::protobuf::RepeatedField::new())
    }

    pub fn get_unary_op(&self) -> &[UnaryOperator] {
        &self.unary_op
    }

    // repeated .maxgraph.BinaryOperator binary_op = 3;

    pub fn clear_binary_op(&mut self) {
        self.binary_op.clear();
    }

    // Param is passed by value, moved
    pub fn set_binary_op(&mut self, v: ::protobuf::RepeatedField<BinaryOperator>) {
        self.binary_op = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binary_op(&mut self) -> &mut ::protobuf::RepeatedField<BinaryOperator> {
        &mut self.binary_op
    }

    // Take field
    pub fn take_binary_op(&mut self) -> ::protobuf::RepeatedField<BinaryOperator> {
        ::std::mem::replace(&mut self.binary_op, ::protobuf::RepeatedField::new())
    }

    pub fn get_binary_op(&self) -> &[BinaryOperator] {
        &self.binary_op
    }

    // repeated int32 operator_id_list = 4;

    pub fn clear_operator_id_list(&mut self) {
        self.operator_id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_operator_id_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.operator_id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operator_id_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.operator_id_list
    }

    // Take field
    pub fn take_operator_id_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.operator_id_list, ::std::vec::Vec::new())
    }

    pub fn get_operator_id_list(&self) -> &[i32] {
        &self.operator_id_list
    }
}

impl ::protobuf::Message for QueryPlan {
    fn is_initialized(&self) -> bool {
        for v in &self.source_op {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unary_op {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_op {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_op)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.unary_op)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.binary_op)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.operator_id_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.source_op.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.unary_op {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.binary_op {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.operator_id_list {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.source_op.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.unary_op {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.binary_op {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.operator_id_list {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryPlan {
        QueryPlan::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SourceOperator>>(
                    "source_op",
                    |m: &QueryPlan| { &m.source_op },
                    |m: &mut QueryPlan| { &mut m.source_op },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UnaryOperator>>(
                    "unary_op",
                    |m: &QueryPlan| { &m.unary_op },
                    |m: &mut QueryPlan| { &mut m.unary_op },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryOperator>>(
                    "binary_op",
                    |m: &QueryPlan| { &m.binary_op },
                    |m: &mut QueryPlan| { &mut m.binary_op },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "operator_id_list",
                    |m: &QueryPlan| { &m.operator_id_list },
                    |m: &mut QueryPlan| { &mut m.operator_id_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryPlan>(
                    "QueryPlan",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryPlan {
        static mut instance: ::protobuf::lazy::Lazy<QueryPlan> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryPlan,
        };
        unsafe {
            instance.get(QueryPlan::new)
        }
    }
}

impl ::protobuf::Clear for QueryPlan {
    fn clear(&mut self) {
        self.clear_source_op();
        self.clear_unary_op();
        self.clear_binary_op();
        self.clear_operator_id_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryPlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryPlan {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequirementValue {
    // message fields
    pub req_type: RequirementType,
    pub req_argument: ::protobuf::SingularPtrField<super::message::Value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RequirementValue {
    pub fn new() -> RequirementValue {
        ::std::default::Default::default()
    }

    // .maxgraph.RequirementType req_type = 1;

    pub fn clear_req_type(&mut self) {
        self.req_type = RequirementType::LABEL_START;
    }

    // Param is passed by value, moved
    pub fn set_req_type(&mut self, v: RequirementType) {
        self.req_type = v;
    }

    pub fn get_req_type(&self) -> RequirementType {
        self.req_type
    }

    // .maxgraph.Value req_argument = 2;

    pub fn clear_req_argument(&mut self) {
        self.req_argument.clear();
    }

    pub fn has_req_argument(&self) -> bool {
        self.req_argument.is_some()
    }

    // Param is passed by value, moved
    pub fn set_req_argument(&mut self, v: super::message::Value) {
        self.req_argument = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_req_argument(&mut self) -> &mut super::message::Value {
        if self.req_argument.is_none() {
            self.req_argument.set_default();
        }
        self.req_argument.as_mut().unwrap()
    }

    // Take field
    pub fn take_req_argument(&mut self) -> super::message::Value {
        self.req_argument.take().unwrap_or_else(|| super::message::Value::new())
    }

    pub fn get_req_argument(&self) -> &super::message::Value {
        self.req_argument.as_ref().unwrap_or_else(|| super::message::Value::default_instance())
    }
}

impl ::protobuf::Message for RequirementValue {
    fn is_initialized(&self) -> bool {
        for v in &self.req_argument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.req_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.req_argument)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.req_type != RequirementType::LABEL_START {
            my_size += ::protobuf::rt::enum_size(1, self.req_type);
        }
        if let Some(ref v) = self.req_argument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.req_type != RequirementType::LABEL_START {
            os.write_enum(1, self.req_type.value())?;
        }
        if let Some(ref v) = self.req_argument.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequirementValue {
        RequirementValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequirementType>>(
                    "req_type",
                    |m: &RequirementValue| { &m.req_type },
                    |m: &mut RequirementValue| { &mut m.req_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Value>>(
                    "req_argument",
                    |m: &RequirementValue| { &m.req_argument },
                    |m: &mut RequirementValue| { &mut m.req_argument },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RequirementValue>(
                    "RequirementValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RequirementValue {
        static mut instance: ::protobuf::lazy::Lazy<RequirementValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RequirementValue,
        };
        unsafe {
            instance.get(RequirementValue::new)
        }
    }
}

impl ::protobuf::Clear for RequirementValue {
    fn clear(&mut self) {
        self.clear_req_type();
        self.clear_req_argument();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequirementValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequirementValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeLimit {
    // message fields
    pub range_start: i64,
    pub range_end: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RangeLimit {
    pub fn new() -> RangeLimit {
        ::std::default::Default::default()
    }

    // int64 range_start = 1;

    pub fn clear_range_start(&mut self) {
        self.range_start = 0;
    }

    // Param is passed by value, moved
    pub fn set_range_start(&mut self, v: i64) {
        self.range_start = v;
    }

    pub fn get_range_start(&self) -> i64 {
        self.range_start
    }

    // int64 range_end = 2;

    pub fn clear_range_end(&mut self) {
        self.range_end = 0;
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: i64) {
        self.range_end = v;
    }

    pub fn get_range_end(&self) -> i64 {
        self.range_end
    }
}

impl ::protobuf::Message for RangeLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.range_start = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.range_end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.range_start != 0 {
            my_size += ::protobuf::rt::value_size(1, self.range_start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.range_end != 0 {
            my_size += ::protobuf::rt::value_size(2, self.range_end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.range_start != 0 {
            os.write_int64(1, self.range_start)?;
        }
        if self.range_end != 0 {
            os.write_int64(2, self.range_end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RangeLimit {
        RangeLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "range_start",
                    |m: &RangeLimit| { &m.range_start },
                    |m: &mut RangeLimit| { &mut m.range_start },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "range_end",
                    |m: &RangeLimit| { &m.range_end },
                    |m: &mut RangeLimit| { &mut m.range_end },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RangeLimit>(
                    "RangeLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RangeLimit {
        static mut instance: ::protobuf::lazy::Lazy<RangeLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RangeLimit,
        };
        unsafe {
            instance.get(RangeLimit::new)
        }
    }
}

impl ::protobuf::Clear for RangeLimit {
    fn clear(&mut self) {
        self.clear_range_start();
        self.clear_range_end();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperatorBase {
    // message fields
    pub id: i32,
    pub operator_type: OperatorType,
    pub argument: ::protobuf::SingularPtrField<super::message::Value>,
    pub assign_hint: AssignHint,
    pub loop_type: ::std::vec::Vec<LoopType>,
    pub loop_limit: i32,
    pub logical_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    pub chained_function: ::protobuf::RepeatedField<OperatorBase>,
    pub range_limit: ::protobuf::SingularPtrField<RangeLimit>,
    pub before_requirement: ::protobuf::RepeatedField<RequirementValue>,
    pub after_requirement: ::protobuf::RepeatedField<RequirementValue>,
    pub early_stop_argument: ::protobuf::SingularPtrField<EarlyStopArgument>,
    pub early_scope_list: ::std::vec::Vec<i32>,
    pub argument_payload: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OperatorBase {
    pub fn new() -> OperatorBase {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }

    // .maxgraph.OperatorType operator_type = 2;

    pub fn clear_operator_type(&mut self) {
        self.operator_type = OperatorType::V;
    }

    // Param is passed by value, moved
    pub fn set_operator_type(&mut self, v: OperatorType) {
        self.operator_type = v;
    }

    pub fn get_operator_type(&self) -> OperatorType {
        self.operator_type
    }

    // .maxgraph.Value argument = 3;

    pub fn clear_argument(&mut self) {
        self.argument.clear();
    }

    pub fn has_argument(&self) -> bool {
        self.argument.is_some()
    }

    // Param is passed by value, moved
    pub fn set_argument(&mut self, v: super::message::Value) {
        self.argument = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_argument(&mut self) -> &mut super::message::Value {
        if self.argument.is_none() {
            self.argument.set_default();
        }
        self.argument.as_mut().unwrap()
    }

    // Take field
    pub fn take_argument(&mut self) -> super::message::Value {
        self.argument.take().unwrap_or_else(|| super::message::Value::new())
    }

    pub fn get_argument(&self) -> &super::message::Value {
        self.argument.as_ref().unwrap_or_else(|| super::message::Value::default_instance())
    }

    // .maxgraph.AssignHint assign_hint = 4;

    pub fn clear_assign_hint(&mut self) {
        self.assign_hint = AssignHint::VERTEX_HASH;
    }

    // Param is passed by value, moved
    pub fn set_assign_hint(&mut self, v: AssignHint) {
        self.assign_hint = v;
    }

    pub fn get_assign_hint(&self) -> AssignHint {
        self.assign_hint
    }

    // repeated .maxgraph.LoopType loop_type = 5;

    pub fn clear_loop_type(&mut self) {
        self.loop_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_loop_type(&mut self, v: ::std::vec::Vec<LoopType>) {
        self.loop_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loop_type(&mut self) -> &mut ::std::vec::Vec<LoopType> {
        &mut self.loop_type
    }

    // Take field
    pub fn take_loop_type(&mut self) -> ::std::vec::Vec<LoopType> {
        ::std::mem::replace(&mut self.loop_type, ::std::vec::Vec::new())
    }

    pub fn get_loop_type(&self) -> &[LoopType] {
        &self.loop_type
    }

    // int32 loop_limit = 6;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // repeated .maxgraph.LogicalCompare logical_compare = 7;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare
    }

    // repeated .maxgraph.OperatorBase chained_function = 8;

    pub fn clear_chained_function(&mut self) {
        self.chained_function.clear();
    }

    // Param is passed by value, moved
    pub fn set_chained_function(&mut self, v: ::protobuf::RepeatedField<OperatorBase>) {
        self.chained_function = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chained_function(&mut self) -> &mut ::protobuf::RepeatedField<OperatorBase> {
        &mut self.chained_function
    }

    // Take field
    pub fn take_chained_function(&mut self) -> ::protobuf::RepeatedField<OperatorBase> {
        ::std::mem::replace(&mut self.chained_function, ::protobuf::RepeatedField::new())
    }

    pub fn get_chained_function(&self) -> &[OperatorBase] {
        &self.chained_function
    }

    // .maxgraph.RangeLimit range_limit = 9;

    pub fn clear_range_limit(&mut self) {
        self.range_limit.clear();
    }

    pub fn has_range_limit(&self) -> bool {
        self.range_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_limit(&mut self, v: RangeLimit) {
        self.range_limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_limit(&mut self) -> &mut RangeLimit {
        if self.range_limit.is_none() {
            self.range_limit.set_default();
        }
        self.range_limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_range_limit(&mut self) -> RangeLimit {
        self.range_limit.take().unwrap_or_else(|| RangeLimit::new())
    }

    pub fn get_range_limit(&self) -> &RangeLimit {
        self.range_limit.as_ref().unwrap_or_else(|| RangeLimit::default_instance())
    }

    // repeated .maxgraph.RequirementValue before_requirement = 10;

    pub fn clear_before_requirement(&mut self) {
        self.before_requirement.clear();
    }

    // Param is passed by value, moved
    pub fn set_before_requirement(&mut self, v: ::protobuf::RepeatedField<RequirementValue>) {
        self.before_requirement = v;
    }

    // Mutable pointer to the field.
    pub fn mut_before_requirement(&mut self) -> &mut ::protobuf::RepeatedField<RequirementValue> {
        &mut self.before_requirement
    }

    // Take field
    pub fn take_before_requirement(&mut self) -> ::protobuf::RepeatedField<RequirementValue> {
        ::std::mem::replace(&mut self.before_requirement, ::protobuf::RepeatedField::new())
    }

    pub fn get_before_requirement(&self) -> &[RequirementValue] {
        &self.before_requirement
    }

    // repeated .maxgraph.RequirementValue after_requirement = 11;

    pub fn clear_after_requirement(&mut self) {
        self.after_requirement.clear();
    }

    // Param is passed by value, moved
    pub fn set_after_requirement(&mut self, v: ::protobuf::RepeatedField<RequirementValue>) {
        self.after_requirement = v;
    }

    // Mutable pointer to the field.
    pub fn mut_after_requirement(&mut self) -> &mut ::protobuf::RepeatedField<RequirementValue> {
        &mut self.after_requirement
    }

    // Take field
    pub fn take_after_requirement(&mut self) -> ::protobuf::RepeatedField<RequirementValue> {
        ::std::mem::replace(&mut self.after_requirement, ::protobuf::RepeatedField::new())
    }

    pub fn get_after_requirement(&self) -> &[RequirementValue] {
        &self.after_requirement
    }

    // .maxgraph.EarlyStopArgument early_stop_argument = 12;

    pub fn clear_early_stop_argument(&mut self) {
        self.early_stop_argument.clear();
    }

    pub fn has_early_stop_argument(&self) -> bool {
        self.early_stop_argument.is_some()
    }

    // Param is passed by value, moved
    pub fn set_early_stop_argument(&mut self, v: EarlyStopArgument) {
        self.early_stop_argument = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_early_stop_argument(&mut self) -> &mut EarlyStopArgument {
        if self.early_stop_argument.is_none() {
            self.early_stop_argument.set_default();
        }
        self.early_stop_argument.as_mut().unwrap()
    }

    // Take field
    pub fn take_early_stop_argument(&mut self) -> EarlyStopArgument {
        self.early_stop_argument.take().unwrap_or_else(|| EarlyStopArgument::new())
    }

    pub fn get_early_stop_argument(&self) -> &EarlyStopArgument {
        self.early_stop_argument.as_ref().unwrap_or_else(|| EarlyStopArgument::default_instance())
    }

    // repeated int32 early_scope_list = 13;

    pub fn clear_early_scope_list(&mut self) {
        self.early_scope_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_early_scope_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.early_scope_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_early_scope_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.early_scope_list
    }

    // Take field
    pub fn take_early_scope_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.early_scope_list, ::std::vec::Vec::new())
    }

    pub fn get_early_scope_list(&self) -> &[i32] {
        &self.early_scope_list
    }

    // bytes argument_payload = 14;

    pub fn clear_argument_payload(&mut self) {
        self.argument_payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_argument_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.argument_payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_argument_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.argument_payload
    }

    // Take field
    pub fn take_argument_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.argument_payload, ::std::vec::Vec::new())
    }

    pub fn get_argument_payload(&self) -> &[u8] {
        &self.argument_payload
    }
}

impl ::protobuf::Message for OperatorBase {
    fn is_initialized(&self) -> bool {
        for v in &self.argument {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.chained_function {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.range_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.before_requirement {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.after_requirement {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.early_stop_argument {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.operator_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.argument)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.assign_hint, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.loop_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.chained_function)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.range_limit)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.before_requirement)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.after_requirement)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.early_stop_argument)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.early_scope_list)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.argument_payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.operator_type != OperatorType::V {
            my_size += ::protobuf::rt::enum_size(2, self.operator_type);
        }
        if let Some(ref v) = self.argument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.assign_hint != AssignHint::VERTEX_HASH {
            my_size += ::protobuf::rt::enum_size(4, self.assign_hint);
        }
        for value in &self.loop_type {
            my_size += ::protobuf::rt::enum_size(5, *value);
        };
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(6, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.chained_function {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.range_limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.before_requirement {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.after_requirement {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.early_stop_argument.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.early_scope_list {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.argument_payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.argument_payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.operator_type != OperatorType::V {
            os.write_enum(2, self.operator_type.value())?;
        }
        if let Some(ref v) = self.argument.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.assign_hint != AssignHint::VERTEX_HASH {
            os.write_enum(4, self.assign_hint.value())?;
        }
        for v in &self.loop_type {
            os.write_enum(5, v.value())?;
        };
        if self.loop_limit != 0 {
            os.write_int32(6, self.loop_limit)?;
        }
        for v in &self.logical_compare {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.chained_function {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.range_limit.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.before_requirement {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.after_requirement {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.early_stop_argument.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.early_scope_list {
            os.write_int32(13, *v)?;
        };
        if !self.argument_payload.is_empty() {
            os.write_bytes(14, &self.argument_payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperatorBase {
        OperatorBase::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &OperatorBase| { &m.id },
                    |m: &mut OperatorBase| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OperatorType>>(
                    "operator_type",
                    |m: &OperatorBase| { &m.operator_type },
                    |m: &mut OperatorBase| { &mut m.operator_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Value>>(
                    "argument",
                    |m: &OperatorBase| { &m.argument },
                    |m: &mut OperatorBase| { &mut m.argument },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AssignHint>>(
                    "assign_hint",
                    |m: &OperatorBase| { &m.assign_hint },
                    |m: &mut OperatorBase| { &mut m.assign_hint },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LoopType>>(
                    "loop_type",
                    |m: &OperatorBase| { &m.loop_type },
                    |m: &mut OperatorBase| { &mut m.loop_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &OperatorBase| { &m.loop_limit },
                    |m: &mut OperatorBase| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare",
                    |m: &OperatorBase| { &m.logical_compare },
                    |m: &mut OperatorBase| { &mut m.logical_compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorBase>>(
                    "chained_function",
                    |m: &OperatorBase| { &m.chained_function },
                    |m: &mut OperatorBase| { &mut m.chained_function },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RangeLimit>>(
                    "range_limit",
                    |m: &OperatorBase| { &m.range_limit },
                    |m: &mut OperatorBase| { &mut m.range_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequirementValue>>(
                    "before_requirement",
                    |m: &OperatorBase| { &m.before_requirement },
                    |m: &mut OperatorBase| { &mut m.before_requirement },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequirementValue>>(
                    "after_requirement",
                    |m: &OperatorBase| { &m.after_requirement },
                    |m: &mut OperatorBase| { &mut m.after_requirement },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EarlyStopArgument>>(
                    "early_stop_argument",
                    |m: &OperatorBase| { &m.early_stop_argument },
                    |m: &mut OperatorBase| { &mut m.early_stop_argument },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "early_scope_list",
                    |m: &OperatorBase| { &m.early_scope_list },
                    |m: &mut OperatorBase| { &mut m.early_scope_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "argument_payload",
                    |m: &OperatorBase| { &m.argument_payload },
                    |m: &mut OperatorBase| { &mut m.argument_payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperatorBase>(
                    "OperatorBase",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperatorBase {
        static mut instance: ::protobuf::lazy::Lazy<OperatorBase> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperatorBase,
        };
        unsafe {
            instance.get(OperatorBase::new)
        }
    }
}

impl ::protobuf::Clear for OperatorBase {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_operator_type();
        self.clear_argument();
        self.clear_assign_hint();
        self.clear_loop_type();
        self.clear_loop_limit();
        self.clear_logical_compare();
        self.clear_chained_function();
        self.clear_range_limit();
        self.clear_before_requirement();
        self.clear_after_requirement();
        self.clear_early_stop_argument();
        self.clear_early_scope_list();
        self.clear_argument_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperatorBase {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorBase {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EarlyStopArgument {
    // message fields
    pub global_stop_flag: bool,
    pub global_filter_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EarlyStopArgument {
    pub fn new() -> EarlyStopArgument {
        ::std::default::Default::default()
    }

    // bool global_stop_flag = 1;

    pub fn clear_global_stop_flag(&mut self) {
        self.global_stop_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_global_stop_flag(&mut self, v: bool) {
        self.global_stop_flag = v;
    }

    pub fn get_global_stop_flag(&self) -> bool {
        self.global_stop_flag
    }

    // bool global_filter_flag = 2;

    pub fn clear_global_filter_flag(&mut self) {
        self.global_filter_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_global_filter_flag(&mut self, v: bool) {
        self.global_filter_flag = v;
    }

    pub fn get_global_filter_flag(&self) -> bool {
        self.global_filter_flag
    }
}

impl ::protobuf::Message for EarlyStopArgument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.global_stop_flag = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.global_filter_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.global_stop_flag != false {
            my_size += 2;
        }
        if self.global_filter_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.global_stop_flag != false {
            os.write_bool(1, self.global_stop_flag)?;
        }
        if self.global_filter_flag != false {
            os.write_bool(2, self.global_filter_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EarlyStopArgument {
        EarlyStopArgument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "global_stop_flag",
                    |m: &EarlyStopArgument| { &m.global_stop_flag },
                    |m: &mut EarlyStopArgument| { &mut m.global_stop_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "global_filter_flag",
                    |m: &EarlyStopArgument| { &m.global_filter_flag },
                    |m: &mut EarlyStopArgument| { &mut m.global_filter_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EarlyStopArgument>(
                    "EarlyStopArgument",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EarlyStopArgument {
        static mut instance: ::protobuf::lazy::Lazy<EarlyStopArgument> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EarlyStopArgument,
        };
        unsafe {
            instance.get(EarlyStopArgument::new)
        }
    }
}

impl ::protobuf::Clear for EarlyStopArgument {
    fn clear(&mut self) {
        self.clear_global_stop_flag();
        self.clear_global_filter_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EarlyStopArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EarlyStopArgument {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SourceOperator {
    // message fields
    pub base: ::protobuf::SingularPtrField<OperatorBase>,
    pub distribute_pattern: DistributionPattern,
    pub odps_input: ::protobuf::SingularPtrField<OdpsQueryInput>,
    pub source_type: SourceType,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SourceOperator {
    pub fn new() -> SourceOperator {
        ::std::default::Default::default()
    }

    // .maxgraph.OperatorBase base = 1;

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: OperatorBase) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut OperatorBase {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> OperatorBase {
        self.base.take().unwrap_or_else(|| OperatorBase::new())
    }

    pub fn get_base(&self) -> &OperatorBase {
        self.base.as_ref().unwrap_or_else(|| OperatorBase::default_instance())
    }

    // .maxgraph.DistributionPattern distribute_pattern = 2;

    pub fn clear_distribute_pattern(&mut self) {
        self.distribute_pattern = DistributionPattern::ALL_TO_ALL;
    }

    // Param is passed by value, moved
    pub fn set_distribute_pattern(&mut self, v: DistributionPattern) {
        self.distribute_pattern = v;
    }

    pub fn get_distribute_pattern(&self) -> DistributionPattern {
        self.distribute_pattern
    }

    // .maxgraph.OdpsQueryInput odps_input = 3;

    pub fn clear_odps_input(&mut self) {
        self.odps_input.clear();
    }

    pub fn has_odps_input(&self) -> bool {
        self.odps_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odps_input(&mut self, v: OdpsQueryInput) {
        self.odps_input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_odps_input(&mut self) -> &mut OdpsQueryInput {
        if self.odps_input.is_none() {
            self.odps_input.set_default();
        }
        self.odps_input.as_mut().unwrap()
    }

    // Take field
    pub fn take_odps_input(&mut self) -> OdpsQueryInput {
        self.odps_input.take().unwrap_or_else(|| OdpsQueryInput::new())
    }

    pub fn get_odps_input(&self) -> &OdpsQueryInput {
        self.odps_input.as_ref().unwrap_or_else(|| OdpsQueryInput::default_instance())
    }

    // .maxgraph.SourceType source_type = 4;

    pub fn clear_source_type(&mut self) {
        self.source_type = SourceType::GRAPH;
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: SourceType) {
        self.source_type = v;
    }

    pub fn get_source_type(&self) -> SourceType {
        self.source_type
    }
}

impl ::protobuf::Message for SourceOperator {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.odps_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.distribute_pattern, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.odps_input)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.source_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.distribute_pattern != DistributionPattern::ALL_TO_ALL {
            my_size += ::protobuf::rt::enum_size(2, self.distribute_pattern);
        }
        if let Some(ref v) = self.odps_input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.source_type != SourceType::GRAPH {
            my_size += ::protobuf::rt::enum_size(4, self.source_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.distribute_pattern != DistributionPattern::ALL_TO_ALL {
            os.write_enum(2, self.distribute_pattern.value())?;
        }
        if let Some(ref v) = self.odps_input.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.source_type != SourceType::GRAPH {
            os.write_enum(4, self.source_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourceOperator {
        SourceOperator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorBase>>(
                    "base",
                    |m: &SourceOperator| { &m.base },
                    |m: &mut SourceOperator| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DistributionPattern>>(
                    "distribute_pattern",
                    |m: &SourceOperator| { &m.distribute_pattern },
                    |m: &mut SourceOperator| { &mut m.distribute_pattern },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OdpsQueryInput>>(
                    "odps_input",
                    |m: &SourceOperator| { &m.odps_input },
                    |m: &mut SourceOperator| { &mut m.odps_input },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SourceType>>(
                    "source_type",
                    |m: &SourceOperator| { &m.source_type },
                    |m: &mut SourceOperator| { &mut m.source_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SourceOperator>(
                    "SourceOperator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SourceOperator {
        static mut instance: ::protobuf::lazy::Lazy<SourceOperator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SourceOperator,
        };
        unsafe {
            instance.get(SourceOperator::new)
        }
    }
}

impl ::protobuf::Clear for SourceOperator {
    fn clear(&mut self) {
        self.clear_base();
        self.clear_distribute_pattern();
        self.clear_odps_input();
        self.clear_source_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SourceOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceOperator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InputEdgeShuffle {
    // message fields
    pub shuffle_type: InputShuffleType,
    pub shuffle_value: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl InputEdgeShuffle {
    pub fn new() -> InputEdgeShuffle {
        ::std::default::Default::default()
    }

    // .maxgraph.InputShuffleType shuffle_type = 1;

    pub fn clear_shuffle_type(&mut self) {
        self.shuffle_type = InputShuffleType::FORWARD_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_shuffle_type(&mut self, v: InputShuffleType) {
        self.shuffle_type = v;
    }

    pub fn get_shuffle_type(&self) -> InputShuffleType {
        self.shuffle_type
    }

    // int32 shuffle_value = 2;

    pub fn clear_shuffle_value(&mut self) {
        self.shuffle_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_shuffle_value(&mut self, v: i32) {
        self.shuffle_value = v;
    }

    pub fn get_shuffle_value(&self) -> i32 {
        self.shuffle_value
    }
}

impl ::protobuf::Message for InputEdgeShuffle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.shuffle_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.shuffle_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shuffle_type != InputShuffleType::FORWARD_TYPE {
            my_size += ::protobuf::rt::enum_size(1, self.shuffle_type);
        }
        if self.shuffle_value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.shuffle_value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shuffle_type != InputShuffleType::FORWARD_TYPE {
            os.write_enum(1, self.shuffle_type.value())?;
        }
        if self.shuffle_value != 0 {
            os.write_int32(2, self.shuffle_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InputEdgeShuffle {
        InputEdgeShuffle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InputShuffleType>>(
                    "shuffle_type",
                    |m: &InputEdgeShuffle| { &m.shuffle_type },
                    |m: &mut InputEdgeShuffle| { &mut m.shuffle_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "shuffle_value",
                    |m: &InputEdgeShuffle| { &m.shuffle_value },
                    |m: &mut InputEdgeShuffle| { &mut m.shuffle_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InputEdgeShuffle>(
                    "InputEdgeShuffle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InputEdgeShuffle {
        static mut instance: ::protobuf::lazy::Lazy<InputEdgeShuffle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InputEdgeShuffle,
        };
        unsafe {
            instance.get(InputEdgeShuffle::new)
        }
    }
}

impl ::protobuf::Clear for InputEdgeShuffle {
    fn clear(&mut self) {
        self.clear_shuffle_type();
        self.clear_shuffle_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InputEdgeShuffle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputEdgeShuffle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnaryOperator {
    // message fields
    pub base: ::protobuf::SingularPtrField<OperatorBase>,
    pub input_operator_id: i32,
    pub distribute_pattern: DistributionPattern,
    pub shuffle_type: InputShuffleType,
    pub input_shuffle: ::protobuf::SingularPtrField<InputEdgeShuffle>,
    pub input_stream_index: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl UnaryOperator {
    pub fn new() -> UnaryOperator {
        ::std::default::Default::default()
    }

    // .maxgraph.OperatorBase base = 1;

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: OperatorBase) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut OperatorBase {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> OperatorBase {
        self.base.take().unwrap_or_else(|| OperatorBase::new())
    }

    pub fn get_base(&self) -> &OperatorBase {
        self.base.as_ref().unwrap_or_else(|| OperatorBase::default_instance())
    }

    // int32 input_operator_id = 2;

    pub fn clear_input_operator_id(&mut self) {
        self.input_operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_operator_id(&mut self, v: i32) {
        self.input_operator_id = v;
    }

    pub fn get_input_operator_id(&self) -> i32 {
        self.input_operator_id
    }

    // .maxgraph.DistributionPattern distribute_pattern = 3;

    pub fn clear_distribute_pattern(&mut self) {
        self.distribute_pattern = DistributionPattern::ALL_TO_ALL;
    }

    // Param is passed by value, moved
    pub fn set_distribute_pattern(&mut self, v: DistributionPattern) {
        self.distribute_pattern = v;
    }

    pub fn get_distribute_pattern(&self) -> DistributionPattern {
        self.distribute_pattern
    }

    // .maxgraph.InputShuffleType shuffle_type = 4;

    pub fn clear_shuffle_type(&mut self) {
        self.shuffle_type = InputShuffleType::FORWARD_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_shuffle_type(&mut self, v: InputShuffleType) {
        self.shuffle_type = v;
    }

    pub fn get_shuffle_type(&self) -> InputShuffleType {
        self.shuffle_type
    }

    // .maxgraph.InputEdgeShuffle input_shuffle = 5;

    pub fn clear_input_shuffle(&mut self) {
        self.input_shuffle.clear();
    }

    pub fn has_input_shuffle(&self) -> bool {
        self.input_shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_shuffle(&mut self, v: InputEdgeShuffle) {
        self.input_shuffle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_shuffle(&mut self) -> &mut InputEdgeShuffle {
        if self.input_shuffle.is_none() {
            self.input_shuffle.set_default();
        }
        self.input_shuffle.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_shuffle(&mut self) -> InputEdgeShuffle {
        self.input_shuffle.take().unwrap_or_else(|| InputEdgeShuffle::new())
    }

    pub fn get_input_shuffle(&self) -> &InputEdgeShuffle {
        self.input_shuffle.as_ref().unwrap_or_else(|| InputEdgeShuffle::default_instance())
    }

    // int32 input_stream_index = 6;

    pub fn clear_input_stream_index(&mut self) {
        self.input_stream_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_stream_index(&mut self, v: i32) {
        self.input_stream_index = v;
    }

    pub fn get_input_stream_index(&self) -> i32 {
        self.input_stream_index
    }
}

impl ::protobuf::Message for UnaryOperator {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_shuffle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.input_operator_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.distribute_pattern, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.shuffle_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_shuffle)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.input_stream_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.input_operator_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.input_operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.distribute_pattern != DistributionPattern::ALL_TO_ALL {
            my_size += ::protobuf::rt::enum_size(3, self.distribute_pattern);
        }
        if self.shuffle_type != InputShuffleType::FORWARD_TYPE {
            my_size += ::protobuf::rt::enum_size(4, self.shuffle_type);
        }
        if let Some(ref v) = self.input_shuffle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.input_stream_index != 0 {
            my_size += ::protobuf::rt::value_size(6, self.input_stream_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.input_operator_id != 0 {
            os.write_int32(2, self.input_operator_id)?;
        }
        if self.distribute_pattern != DistributionPattern::ALL_TO_ALL {
            os.write_enum(3, self.distribute_pattern.value())?;
        }
        if self.shuffle_type != InputShuffleType::FORWARD_TYPE {
            os.write_enum(4, self.shuffle_type.value())?;
        }
        if let Some(ref v) = self.input_shuffle.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.input_stream_index != 0 {
            os.write_int32(6, self.input_stream_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnaryOperator {
        UnaryOperator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorBase>>(
                    "base",
                    |m: &UnaryOperator| { &m.base },
                    |m: &mut UnaryOperator| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "input_operator_id",
                    |m: &UnaryOperator| { &m.input_operator_id },
                    |m: &mut UnaryOperator| { &mut m.input_operator_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DistributionPattern>>(
                    "distribute_pattern",
                    |m: &UnaryOperator| { &m.distribute_pattern },
                    |m: &mut UnaryOperator| { &mut m.distribute_pattern },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InputShuffleType>>(
                    "shuffle_type",
                    |m: &UnaryOperator| { &m.shuffle_type },
                    |m: &mut UnaryOperator| { &mut m.shuffle_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputEdgeShuffle>>(
                    "input_shuffle",
                    |m: &UnaryOperator| { &m.input_shuffle },
                    |m: &mut UnaryOperator| { &mut m.input_shuffle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "input_stream_index",
                    |m: &UnaryOperator| { &m.input_stream_index },
                    |m: &mut UnaryOperator| { &mut m.input_stream_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UnaryOperator>(
                    "UnaryOperator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UnaryOperator {
        static mut instance: ::protobuf::lazy::Lazy<UnaryOperator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UnaryOperator,
        };
        unsafe {
            instance.get(UnaryOperator::new)
        }
    }
}

impl ::protobuf::Clear for UnaryOperator {
    fn clear(&mut self) {
        self.clear_base();
        self.clear_input_operator_id();
        self.clear_distribute_pattern();
        self.clear_shuffle_type();
        self.clear_input_shuffle();
        self.clear_input_stream_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnaryOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnaryOperator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinaryOperator {
    // message fields
    pub base: ::protobuf::SingularPtrField<OperatorBase>,
    pub left_input_operator_id: i32,
    pub right_input_operator_id: i32,
    pub distribute_pattern: DistributionPattern,
    pub left_shuffle_type: InputShuffleType,
    pub left_input_shuffle: ::protobuf::SingularPtrField<InputEdgeShuffle>,
    pub right_shuffle_type: InputShuffleType,
    pub right_input_shuffle: ::protobuf::SingularPtrField<InputEdgeShuffle>,
    pub left_stream_index: i32,
    pub right_stream_index: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BinaryOperator {
    pub fn new() -> BinaryOperator {
        ::std::default::Default::default()
    }

    // .maxgraph.OperatorBase base = 1;

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: OperatorBase) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut OperatorBase {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> OperatorBase {
        self.base.take().unwrap_or_else(|| OperatorBase::new())
    }

    pub fn get_base(&self) -> &OperatorBase {
        self.base.as_ref().unwrap_or_else(|| OperatorBase::default_instance())
    }

    // int32 left_input_operator_id = 2;

    pub fn clear_left_input_operator_id(&mut self) {
        self.left_input_operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_left_input_operator_id(&mut self, v: i32) {
        self.left_input_operator_id = v;
    }

    pub fn get_left_input_operator_id(&self) -> i32 {
        self.left_input_operator_id
    }

    // int32 right_input_operator_id = 3;

    pub fn clear_right_input_operator_id(&mut self) {
        self.right_input_operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_right_input_operator_id(&mut self, v: i32) {
        self.right_input_operator_id = v;
    }

    pub fn get_right_input_operator_id(&self) -> i32 {
        self.right_input_operator_id
    }

    // .maxgraph.DistributionPattern distribute_pattern = 4;

    pub fn clear_distribute_pattern(&mut self) {
        self.distribute_pattern = DistributionPattern::ALL_TO_ALL;
    }

    // Param is passed by value, moved
    pub fn set_distribute_pattern(&mut self, v: DistributionPattern) {
        self.distribute_pattern = v;
    }

    pub fn get_distribute_pattern(&self) -> DistributionPattern {
        self.distribute_pattern
    }

    // .maxgraph.InputShuffleType left_shuffle_type = 5;

    pub fn clear_left_shuffle_type(&mut self) {
        self.left_shuffle_type = InputShuffleType::FORWARD_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_left_shuffle_type(&mut self, v: InputShuffleType) {
        self.left_shuffle_type = v;
    }

    pub fn get_left_shuffle_type(&self) -> InputShuffleType {
        self.left_shuffle_type
    }

    // .maxgraph.InputEdgeShuffle left_input_shuffle = 6;

    pub fn clear_left_input_shuffle(&mut self) {
        self.left_input_shuffle.clear();
    }

    pub fn has_left_input_shuffle(&self) -> bool {
        self.left_input_shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_left_input_shuffle(&mut self, v: InputEdgeShuffle) {
        self.left_input_shuffle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_left_input_shuffle(&mut self) -> &mut InputEdgeShuffle {
        if self.left_input_shuffle.is_none() {
            self.left_input_shuffle.set_default();
        }
        self.left_input_shuffle.as_mut().unwrap()
    }

    // Take field
    pub fn take_left_input_shuffle(&mut self) -> InputEdgeShuffle {
        self.left_input_shuffle.take().unwrap_or_else(|| InputEdgeShuffle::new())
    }

    pub fn get_left_input_shuffle(&self) -> &InputEdgeShuffle {
        self.left_input_shuffle.as_ref().unwrap_or_else(|| InputEdgeShuffle::default_instance())
    }

    // .maxgraph.InputShuffleType right_shuffle_type = 7;

    pub fn clear_right_shuffle_type(&mut self) {
        self.right_shuffle_type = InputShuffleType::FORWARD_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_right_shuffle_type(&mut self, v: InputShuffleType) {
        self.right_shuffle_type = v;
    }

    pub fn get_right_shuffle_type(&self) -> InputShuffleType {
        self.right_shuffle_type
    }

    // .maxgraph.InputEdgeShuffle right_input_shuffle = 8;

    pub fn clear_right_input_shuffle(&mut self) {
        self.right_input_shuffle.clear();
    }

    pub fn has_right_input_shuffle(&self) -> bool {
        self.right_input_shuffle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_right_input_shuffle(&mut self, v: InputEdgeShuffle) {
        self.right_input_shuffle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_right_input_shuffle(&mut self) -> &mut InputEdgeShuffle {
        if self.right_input_shuffle.is_none() {
            self.right_input_shuffle.set_default();
        }
        self.right_input_shuffle.as_mut().unwrap()
    }

    // Take field
    pub fn take_right_input_shuffle(&mut self) -> InputEdgeShuffle {
        self.right_input_shuffle.take().unwrap_or_else(|| InputEdgeShuffle::new())
    }

    pub fn get_right_input_shuffle(&self) -> &InputEdgeShuffle {
        self.right_input_shuffle.as_ref().unwrap_or_else(|| InputEdgeShuffle::default_instance())
    }

    // int32 left_stream_index = 9;

    pub fn clear_left_stream_index(&mut self) {
        self.left_stream_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_left_stream_index(&mut self, v: i32) {
        self.left_stream_index = v;
    }

    pub fn get_left_stream_index(&self) -> i32 {
        self.left_stream_index
    }

    // int32 right_stream_index = 10;

    pub fn clear_right_stream_index(&mut self) {
        self.right_stream_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_right_stream_index(&mut self, v: i32) {
        self.right_stream_index = v;
    }

    pub fn get_right_stream_index(&self) -> i32 {
        self.right_stream_index
    }
}

impl ::protobuf::Message for BinaryOperator {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.left_input_shuffle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.right_input_shuffle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.left_input_operator_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.right_input_operator_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.distribute_pattern, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.left_shuffle_type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.left_input_shuffle)?;
                },
                7 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.right_shuffle_type, 7, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.right_input_shuffle)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.left_stream_index = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.right_stream_index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.left_input_operator_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.left_input_operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right_input_operator_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.right_input_operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.distribute_pattern != DistributionPattern::ALL_TO_ALL {
            my_size += ::protobuf::rt::enum_size(4, self.distribute_pattern);
        }
        if self.left_shuffle_type != InputShuffleType::FORWARD_TYPE {
            my_size += ::protobuf::rt::enum_size(5, self.left_shuffle_type);
        }
        if let Some(ref v) = self.left_input_shuffle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.right_shuffle_type != InputShuffleType::FORWARD_TYPE {
            my_size += ::protobuf::rt::enum_size(7, self.right_shuffle_type);
        }
        if let Some(ref v) = self.right_input_shuffle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.left_stream_index != 0 {
            my_size += ::protobuf::rt::value_size(9, self.left_stream_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right_stream_index != 0 {
            my_size += ::protobuf::rt::value_size(10, self.right_stream_index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.left_input_operator_id != 0 {
            os.write_int32(2, self.left_input_operator_id)?;
        }
        if self.right_input_operator_id != 0 {
            os.write_int32(3, self.right_input_operator_id)?;
        }
        if self.distribute_pattern != DistributionPattern::ALL_TO_ALL {
            os.write_enum(4, self.distribute_pattern.value())?;
        }
        if self.left_shuffle_type != InputShuffleType::FORWARD_TYPE {
            os.write_enum(5, self.left_shuffle_type.value())?;
        }
        if let Some(ref v) = self.left_input_shuffle.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.right_shuffle_type != InputShuffleType::FORWARD_TYPE {
            os.write_enum(7, self.right_shuffle_type.value())?;
        }
        if let Some(ref v) = self.right_input_shuffle.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.left_stream_index != 0 {
            os.write_int32(9, self.left_stream_index)?;
        }
        if self.right_stream_index != 0 {
            os.write_int32(10, self.right_stream_index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryOperator {
        BinaryOperator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorBase>>(
                    "base",
                    |m: &BinaryOperator| { &m.base },
                    |m: &mut BinaryOperator| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "left_input_operator_id",
                    |m: &BinaryOperator| { &m.left_input_operator_id },
                    |m: &mut BinaryOperator| { &mut m.left_input_operator_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "right_input_operator_id",
                    |m: &BinaryOperator| { &m.right_input_operator_id },
                    |m: &mut BinaryOperator| { &mut m.right_input_operator_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DistributionPattern>>(
                    "distribute_pattern",
                    |m: &BinaryOperator| { &m.distribute_pattern },
                    |m: &mut BinaryOperator| { &mut m.distribute_pattern },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InputShuffleType>>(
                    "left_shuffle_type",
                    |m: &BinaryOperator| { &m.left_shuffle_type },
                    |m: &mut BinaryOperator| { &mut m.left_shuffle_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputEdgeShuffle>>(
                    "left_input_shuffle",
                    |m: &BinaryOperator| { &m.left_input_shuffle },
                    |m: &mut BinaryOperator| { &mut m.left_input_shuffle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<InputShuffleType>>(
                    "right_shuffle_type",
                    |m: &BinaryOperator| { &m.right_shuffle_type },
                    |m: &mut BinaryOperator| { &mut m.right_shuffle_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InputEdgeShuffle>>(
                    "right_input_shuffle",
                    |m: &BinaryOperator| { &m.right_input_shuffle },
                    |m: &mut BinaryOperator| { &mut m.right_input_shuffle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "left_stream_index",
                    |m: &BinaryOperator| { &m.left_stream_index },
                    |m: &mut BinaryOperator| { &mut m.left_stream_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "right_stream_index",
                    |m: &BinaryOperator| { &m.right_stream_index },
                    |m: &mut BinaryOperator| { &mut m.right_stream_index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BinaryOperator>(
                    "BinaryOperator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BinaryOperator {
        static mut instance: ::protobuf::lazy::Lazy<BinaryOperator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BinaryOperator,
        };
        unsafe {
            instance.get(BinaryOperator::new)
        }
    }
}

impl ::protobuf::Clear for BinaryOperator {
    fn clear(&mut self) {
        self.clear_base();
        self.clear_left_input_operator_id();
        self.clear_right_input_operator_id();
        self.clear_distribute_pattern();
        self.clear_left_shuffle_type();
        self.clear_left_input_shuffle();
        self.clear_right_shuffle_type();
        self.clear_right_input_shuffle();
        self.clear_left_stream_index();
        self.clear_right_stream_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinaryOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryOperator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SinkOperator {
    // message fields
    pub base: ::protobuf::SingularPtrField<OperatorBase>,
    pub input_operator_id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SinkOperator {
    pub fn new() -> SinkOperator {
        ::std::default::Default::default()
    }

    // .maxgraph.OperatorBase base = 1;

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: OperatorBase) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut OperatorBase {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> OperatorBase {
        self.base.take().unwrap_or_else(|| OperatorBase::new())
    }

    pub fn get_base(&self) -> &OperatorBase {
        self.base.as_ref().unwrap_or_else(|| OperatorBase::default_instance())
    }

    // int32 input_operator_id = 2;

    pub fn clear_input_operator_id(&mut self) {
        self.input_operator_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_operator_id(&mut self, v: i32) {
        self.input_operator_id = v;
    }

    pub fn get_input_operator_id(&self) -> i32 {
        self.input_operator_id
    }
}

impl ::protobuf::Message for SinkOperator {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.input_operator_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.input_operator_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.input_operator_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.input_operator_id != 0 {
            os.write_int32(2, self.input_operator_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SinkOperator {
        SinkOperator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorBase>>(
                    "base",
                    |m: &SinkOperator| { &m.base },
                    |m: &mut SinkOperator| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "input_operator_id",
                    |m: &SinkOperator| { &m.input_operator_id },
                    |m: &mut SinkOperator| { &mut m.input_operator_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SinkOperator>(
                    "SinkOperator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SinkOperator {
        static mut instance: ::protobuf::lazy::Lazy<SinkOperator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SinkOperator,
        };
        unsafe {
            instance.get(SinkOperator::new)
        }
    }
}

impl ::protobuf::Clear for SinkOperator {
    fn clear(&mut self) {
        self.clear_base();
        self.clear_input_operator_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SinkOperator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SinkOperator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OdpsQueryInput {
    // message fields
    pub project: ::std::string::String,
    pub table_name: ::std::string::String,
    pub endpoint: ::std::string::String,
    pub access_id: ::std::string::String,
    pub access_key: ::std::string::String,
    pub ds: ::std::string::String,
    pub pk_name_list: ::protobuf::RepeatedField<::std::string::String>,
    pub logical_compare: ::protobuf::RepeatedField<super::message::ColumnLogicalCompare>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OdpsQueryInput {
    pub fn new() -> OdpsQueryInput {
        ::std::default::Default::default()
    }

    // string project = 1;

    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    pub fn get_project(&self) -> &str {
        &self.project
    }

    // string table_name = 2;

    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        &mut self.table_name
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_name, ::std::string::String::new())
    }

    pub fn get_table_name(&self) -> &str {
        &self.table_name
    }

    // string endpoint = 3;

    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }

    // string access_id = 4;

    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }

    // string access_key = 5;

    pub fn clear_access_key(&mut self) {
        self.access_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_key(&mut self, v: ::std::string::String) {
        self.access_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_key(&mut self) -> &mut ::std::string::String {
        &mut self.access_key
    }

    // Take field
    pub fn take_access_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_key, ::std::string::String::new())
    }

    pub fn get_access_key(&self) -> &str {
        &self.access_key
    }

    // string ds = 6;

    pub fn clear_ds(&mut self) {
        self.ds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds(&mut self, v: ::std::string::String) {
        self.ds = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ds(&mut self) -> &mut ::std::string::String {
        &mut self.ds
    }

    // Take field
    pub fn take_ds(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ds, ::std::string::String::new())
    }

    pub fn get_ds(&self) -> &str {
        &self.ds
    }

    // repeated string pk_name_list = 7;

    pub fn clear_pk_name_list(&mut self) {
        self.pk_name_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_pk_name_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.pk_name_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pk_name_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.pk_name_list
    }

    // Take field
    pub fn take_pk_name_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.pk_name_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_pk_name_list(&self) -> &[::std::string::String] {
        &self.pk_name_list
    }

    // repeated .maxgraph.ColumnLogicalCompare logical_compare = 8;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::ColumnLogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::ColumnLogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::ColumnLogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::ColumnLogicalCompare] {
        &self.logical_compare
    }
}

impl ::protobuf::Message for OdpsQueryInput {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ds)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.pk_name_list)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if !self.table_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table_name);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.endpoint);
        }
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.access_id);
        }
        if !self.access_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.access_key);
        }
        if !self.ds.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.ds);
        }
        for value in &self.pk_name_list {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if !self.table_name.is_empty() {
            os.write_string(2, &self.table_name)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(3, &self.endpoint)?;
        }
        if !self.access_id.is_empty() {
            os.write_string(4, &self.access_id)?;
        }
        if !self.access_key.is_empty() {
            os.write_string(5, &self.access_key)?;
        }
        if !self.ds.is_empty() {
            os.write_string(6, &self.ds)?;
        }
        for v in &self.pk_name_list {
            os.write_string(7, &v)?;
        };
        for v in &self.logical_compare {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OdpsQueryInput {
        OdpsQueryInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project",
                    |m: &OdpsQueryInput| { &m.project },
                    |m: &mut OdpsQueryInput| { &mut m.project },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "table_name",
                    |m: &OdpsQueryInput| { &m.table_name },
                    |m: &mut OdpsQueryInput| { &mut m.table_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &OdpsQueryInput| { &m.endpoint },
                    |m: &mut OdpsQueryInput| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "access_id",
                    |m: &OdpsQueryInput| { &m.access_id },
                    |m: &mut OdpsQueryInput| { &mut m.access_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "access_key",
                    |m: &OdpsQueryInput| { &m.access_key },
                    |m: &mut OdpsQueryInput| { &mut m.access_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ds",
                    |m: &OdpsQueryInput| { &m.ds },
                    |m: &mut OdpsQueryInput| { &mut m.ds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pk_name_list",
                    |m: &OdpsQueryInput| { &m.pk_name_list },
                    |m: &mut OdpsQueryInput| { &mut m.pk_name_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::ColumnLogicalCompare>>(
                    "logical_compare",
                    |m: &OdpsQueryInput| { &m.logical_compare },
                    |m: &mut OdpsQueryInput| { &mut m.logical_compare },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OdpsQueryInput>(
                    "OdpsQueryInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OdpsQueryInput {
        static mut instance: ::protobuf::lazy::Lazy<OdpsQueryInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OdpsQueryInput,
        };
        unsafe {
            instance.get(OdpsQueryInput::new)
        }
    }
}

impl ::protobuf::Clear for OdpsQueryInput {
    fn clear(&mut self) {
        self.clear_project();
        self.clear_table_name();
        self.clear_endpoint();
        self.clear_access_id();
        self.clear_access_key();
        self.clear_ds();
        self.clear_pk_name_list();
        self.clear_logical_compare();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OdpsQueryInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OdpsQueryInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OdpsGraphInput {
    // message fields
    pub endpoint: ::std::string::String,
    pub access_id: ::std::string::String,
    pub access_key: ::std::string::String,
    pub edge_input: ::protobuf::RepeatedField<super::message::EdgeInput>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OdpsGraphInput {
    pub fn new() -> OdpsGraphInput {
        ::std::default::Default::default()
    }

    // string endpoint = 1;

    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }

    // string access_id = 2;

    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }

    // string access_key = 3;

    pub fn clear_access_key(&mut self) {
        self.access_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_key(&mut self, v: ::std::string::String) {
        self.access_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_key(&mut self) -> &mut ::std::string::String {
        &mut self.access_key
    }

    // Take field
    pub fn take_access_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_key, ::std::string::String::new())
    }

    pub fn get_access_key(&self) -> &str {
        &self.access_key
    }

    // repeated .maxgraph.EdgeInput edge_input = 4;

    pub fn clear_edge_input(&mut self) {
        self.edge_input.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_input(&mut self, v: ::protobuf::RepeatedField<super::message::EdgeInput>) {
        self.edge_input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_input(&mut self) -> &mut ::protobuf::RepeatedField<super::message::EdgeInput> {
        &mut self.edge_input
    }

    // Take field
    pub fn take_edge_input(&mut self) -> ::protobuf::RepeatedField<super::message::EdgeInput> {
        ::std::mem::replace(&mut self.edge_input, ::protobuf::RepeatedField::new())
    }

    pub fn get_edge_input(&self) -> &[super::message::EdgeInput] {
        &self.edge_input
    }
}

impl ::protobuf::Message for OdpsGraphInput {
    fn is_initialized(&self) -> bool {
        for v in &self.edge_input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_key)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edge_input)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.endpoint);
        }
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.access_id);
        }
        if !self.access_key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.access_key);
        }
        for value in &self.edge_input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.endpoint.is_empty() {
            os.write_string(1, &self.endpoint)?;
        }
        if !self.access_id.is_empty() {
            os.write_string(2, &self.access_id)?;
        }
        if !self.access_key.is_empty() {
            os.write_string(3, &self.access_key)?;
        }
        for v in &self.edge_input {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OdpsGraphInput {
        OdpsGraphInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &OdpsGraphInput| { &m.endpoint },
                    |m: &mut OdpsGraphInput| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "access_id",
                    |m: &OdpsGraphInput| { &m.access_id },
                    |m: &mut OdpsGraphInput| { &mut m.access_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "access_key",
                    |m: &OdpsGraphInput| { &m.access_key },
                    |m: &mut OdpsGraphInput| { &mut m.access_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::EdgeInput>>(
                    "edge_input",
                    |m: &OdpsGraphInput| { &m.edge_input },
                    |m: &mut OdpsGraphInput| { &mut m.edge_input },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OdpsGraphInput>(
                    "OdpsGraphInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OdpsGraphInput {
        static mut instance: ::protobuf::lazy::Lazy<OdpsGraphInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OdpsGraphInput,
        };
        unsafe {
            instance.get(OdpsGraphInput::new)
        }
    }
}

impl ::protobuf::Clear for OdpsGraphInput {
    fn clear(&mut self) {
        self.clear_endpoint();
        self.clear_access_id();
        self.clear_access_key();
        self.clear_edge_input();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OdpsGraphInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OdpsGraphInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OdpsOutputConfig {
    // message fields
    pub project: ::std::string::String,
    pub table_name: ::std::string::String,
    pub endpoint: ::std::string::String,
    pub access_id: ::std::string::String,
    pub access_key: ::std::string::String,
    pub ds: ::std::string::String,
    pub prop_id: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OdpsOutputConfig {
    pub fn new() -> OdpsOutputConfig {
        ::std::default::Default::default()
    }

    // string project = 1;

    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    pub fn get_project(&self) -> &str {
        &self.project
    }

    // string table_name = 2;

    pub fn clear_table_name(&mut self) {
        self.table_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_table_name(&mut self, v: ::std::string::String) {
        self.table_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
        &mut self.table_name
    }

    // Take field
    pub fn take_table_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table_name, ::std::string::String::new())
    }

    pub fn get_table_name(&self) -> &str {
        &self.table_name
    }

    // string endpoint = 3;

    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }

    // string access_id = 4;

    pub fn clear_access_id(&mut self) {
        self.access_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_id(&mut self, v: ::std::string::String) {
        self.access_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_id(&mut self) -> &mut ::std::string::String {
        &mut self.access_id
    }

    // Take field
    pub fn take_access_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_id, ::std::string::String::new())
    }

    pub fn get_access_id(&self) -> &str {
        &self.access_id
    }

    // string access_key = 5;

    pub fn clear_access_key(&mut self) {
        self.access_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_key(&mut self, v: ::std::string::String) {
        self.access_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_key(&mut self) -> &mut ::std::string::String {
        &mut self.access_key
    }

    // Take field
    pub fn take_access_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_key, ::std::string::String::new())
    }

    pub fn get_access_key(&self) -> &str {
        &self.access_key
    }

    // string ds = 6;

    pub fn clear_ds(&mut self) {
        self.ds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds(&mut self, v: ::std::string::String) {
        self.ds = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ds(&mut self) -> &mut ::std::string::String {
        &mut self.ds
    }

    // Take field
    pub fn take_ds(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ds, ::std::string::String::new())
    }

    pub fn get_ds(&self) -> &str {
        &self.ds
    }

    // repeated int32 prop_id = 7;

    pub fn clear_prop_id(&mut self) {
        self.prop_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_id(&mut self, v: ::std::vec::Vec<i32>) {
        self.prop_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_id(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.prop_id
    }

    // Take field
    pub fn take_prop_id(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.prop_id, ::std::vec::Vec::new())
    }

    pub fn get_prop_id(&self) -> &[i32] {
        &self.prop_id
    }
}

impl ::protobuf::Message for OdpsOutputConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ds)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.prop_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if !self.table_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.table_name);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.endpoint);
        }
        if !self.access_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.access_id);
        }
        if !self.access_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.access_key);
        }
        if !self.ds.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.ds);
        }
        for value in &self.prop_id {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if !self.table_name.is_empty() {
            os.write_string(2, &self.table_name)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(3, &self.endpoint)?;
        }
        if !self.access_id.is_empty() {
            os.write_string(4, &self.access_id)?;
        }
        if !self.access_key.is_empty() {
            os.write_string(5, &self.access_key)?;
        }
        if !self.ds.is_empty() {
            os.write_string(6, &self.ds)?;
        }
        for v in &self.prop_id {
            os.write_int32(7, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OdpsOutputConfig {
        OdpsOutputConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project",
                    |m: &OdpsOutputConfig| { &m.project },
                    |m: &mut OdpsOutputConfig| { &mut m.project },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "table_name",
                    |m: &OdpsOutputConfig| { &m.table_name },
                    |m: &mut OdpsOutputConfig| { &mut m.table_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoint",
                    |m: &OdpsOutputConfig| { &m.endpoint },
                    |m: &mut OdpsOutputConfig| { &mut m.endpoint },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "access_id",
                    |m: &OdpsOutputConfig| { &m.access_id },
                    |m: &mut OdpsOutputConfig| { &mut m.access_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "access_key",
                    |m: &OdpsOutputConfig| { &m.access_key },
                    |m: &mut OdpsOutputConfig| { &mut m.access_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ds",
                    |m: &OdpsOutputConfig| { &m.ds },
                    |m: &mut OdpsOutputConfig| { &mut m.ds },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_id",
                    |m: &OdpsOutputConfig| { &m.prop_id },
                    |m: &mut OdpsOutputConfig| { &mut m.prop_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OdpsOutputConfig>(
                    "OdpsOutputConfig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OdpsOutputConfig {
        static mut instance: ::protobuf::lazy::Lazy<OdpsOutputConfig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OdpsOutputConfig,
        };
        unsafe {
            instance.get(OdpsOutputConfig::new)
        }
    }
}

impl ::protobuf::Clear for OdpsOutputConfig {
    fn clear(&mut self) {
        self.clear_project();
        self.clear_table_name();
        self.clear_endpoint();
        self.clear_access_id();
        self.clear_access_key();
        self.clear_ds();
        self.clear_prop_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OdpsOutputConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OdpsOutputConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryInput {
    // message fields
    pub value: ::protobuf::SingularPtrField<super::message::Value>,
    pub logical_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryInput {
    pub fn new() -> QueryInput {
        ::std::default::Default::default()
    }

    // .maxgraph.Value value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::message::Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut super::message::Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> super::message::Value {
        self.value.take().unwrap_or_else(|| super::message::Value::new())
    }

    pub fn get_value(&self) -> &super::message::Value {
        self.value.as_ref().unwrap_or_else(|| super::message::Value::default_instance())
    }

    // repeated .maxgraph.LogicalCompare logical_compare = 2;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare
    }
}

impl ::protobuf::Message for QueryInput {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.logical_compare {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryInput {
        QueryInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::Value>>(
                    "value",
                    |m: &QueryInput| { &m.value },
                    |m: &mut QueryInput| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare",
                    |m: &QueryInput| { &m.logical_compare },
                    |m: &mut QueryInput| { &mut m.logical_compare },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryInput>(
                    "QueryInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryInput {
        static mut instance: ::protobuf::lazy::Lazy<QueryInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryInput,
        };
        unsafe {
            instance.get(QueryInput::new)
        }
    }
}

impl ::protobuf::Clear for QueryInput {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_logical_compare();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Query {
    // message fields
    pub dataflow_id: ::std::string::String,
    pub input: ::protobuf::SingularPtrField<QueryInput>,
    pub timeout_seconds: i64,
    pub query_id: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Query {
    pub fn new() -> Query {
        ::std::default::Default::default()
    }

    // string dataflow_id = 1;

    pub fn clear_dataflow_id(&mut self) {
        self.dataflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataflow_id(&mut self, v: ::std::string::String) {
        self.dataflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.dataflow_id
    }

    // Take field
    pub fn take_dataflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataflow_id, ::std::string::String::new())
    }

    pub fn get_dataflow_id(&self) -> &str {
        &self.dataflow_id
    }

    // .maxgraph.QueryInput input = 2;

    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    pub fn has_input(&self) -> bool {
        self.input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: QueryInput) {
        self.input = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input(&mut self) -> &mut QueryInput {
        if self.input.is_none() {
            self.input.set_default();
        }
        self.input.as_mut().unwrap()
    }

    // Take field
    pub fn take_input(&mut self) -> QueryInput {
        self.input.take().unwrap_or_else(|| QueryInput::new())
    }

    pub fn get_input(&self) -> &QueryInput {
        self.input.as_ref().unwrap_or_else(|| QueryInput::default_instance())
    }

    // int64 timeout_seconds = 3;

    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: i64) {
        self.timeout_seconds = v;
    }

    pub fn get_timeout_seconds(&self) -> i64 {
        self.timeout_seconds
    }

    // string query_id = 4;

    pub fn clear_query_id(&mut self) {
        self.query_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_id(&mut self, v: ::std::string::String) {
        self.query_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query_id(&mut self) -> &mut ::std::string::String {
        &mut self.query_id
    }

    // Take field
    pub fn take_query_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query_id, ::std::string::String::new())
    }

    pub fn get_query_id(&self) -> &str {
        &self.query_id
    }
}

impl ::protobuf::Message for Query {
    fn is_initialized(&self) -> bool {
        for v in &self.input {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataflow_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeout_seconds = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataflow_id);
        }
        if let Some(ref v) = self.input.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.timeout_seconds != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timeout_seconds, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.query_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.query_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.dataflow_id.is_empty() {
            os.write_string(1, &self.dataflow_id)?;
        }
        if let Some(ref v) = self.input.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.timeout_seconds != 0 {
            os.write_int64(3, self.timeout_seconds)?;
        }
        if !self.query_id.is_empty() {
            os.write_string(4, &self.query_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Query {
        Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dataflow_id",
                    |m: &Query| { &m.dataflow_id },
                    |m: &mut Query| { &mut m.dataflow_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryInput>>(
                    "input",
                    |m: &Query| { &m.input },
                    |m: &mut Query| { &mut m.input },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timeout_seconds",
                    |m: &Query| { &m.timeout_seconds },
                    |m: &mut Query| { &mut m.timeout_seconds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query_id",
                    |m: &Query| { &m.query_id },
                    |m: &mut Query| { &mut m.query_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Query>(
                    "Query",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Query {
        static mut instance: ::protobuf::lazy::Lazy<Query> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Query,
        };
        unsafe {
            instance.get(Query::new)
        }
    }
}

impl ::protobuf::Clear for Query {
    fn clear(&mut self) {
        self.clear_dataflow_id();
        self.clear_input();
        self.clear_timeout_seconds();
        self.clear_query_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Query {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogicalCompareListProto {
    // message fields
    pub logical_compare_list: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LogicalCompareListProto {
    pub fn new() -> LogicalCompareListProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.LogicalCompare logical_compare_list = 1;

    pub fn clear_logical_compare_list(&mut self) {
        self.logical_compare_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare_list(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.logical_compare_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare_list(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.logical_compare_list
    }

    // Take field
    pub fn take_logical_compare_list(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare_list(&self) -> &[super::message::LogicalCompare] {
        &self.logical_compare_list
    }
}

impl ::protobuf::Message for LogicalCompareListProto {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_compare_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.logical_compare_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.logical_compare_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalCompareListProto {
        LogicalCompareListProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "logical_compare_list",
                    |m: &LogicalCompareListProto| { &m.logical_compare_list },
                    |m: &mut LogicalCompareListProto| { &mut m.logical_compare_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogicalCompareListProto>(
                    "LogicalCompareListProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogicalCompareListProto {
        static mut instance: ::protobuf::lazy::Lazy<LogicalCompareListProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogicalCompareListProto,
        };
        unsafe {
            instance.get(LogicalCompareListProto::new)
        }
    }
}

impl ::protobuf::Clear for LogicalCompareListProto {
    fn clear(&mut self) {
        self.clear_logical_compare_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalCompareListProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalCompareListProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WhenCompareListProto {
    // message fields
    pub when_compare_list: ::protobuf::RepeatedField<LogicalCompareListProto>,
    pub else_end_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WhenCompareListProto {
    pub fn new() -> WhenCompareListProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.LogicalCompareListProto when_compare_list = 1;

    pub fn clear_when_compare_list(&mut self) {
        self.when_compare_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_when_compare_list(&mut self, v: ::protobuf::RepeatedField<LogicalCompareListProto>) {
        self.when_compare_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_when_compare_list(&mut self) -> &mut ::protobuf::RepeatedField<LogicalCompareListProto> {
        &mut self.when_compare_list
    }

    // Take field
    pub fn take_when_compare_list(&mut self) -> ::protobuf::RepeatedField<LogicalCompareListProto> {
        ::std::mem::replace(&mut self.when_compare_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_when_compare_list(&self) -> &[LogicalCompareListProto] {
        &self.when_compare_list
    }

    // bool else_end_flag = 2;

    pub fn clear_else_end_flag(&mut self) {
        self.else_end_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_else_end_flag(&mut self, v: bool) {
        self.else_end_flag = v;
    }

    pub fn get_else_end_flag(&self) -> bool {
        self.else_end_flag
    }
}

impl ::protobuf::Message for WhenCompareListProto {
    fn is_initialized(&self) -> bool {
        for v in &self.when_compare_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.when_compare_list)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.else_end_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.when_compare_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.else_end_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.when_compare_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.else_end_flag != false {
            os.write_bool(2, self.else_end_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WhenCompareListProto {
        WhenCompareListProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalCompareListProto>>(
                    "when_compare_list",
                    |m: &WhenCompareListProto| { &m.when_compare_list },
                    |m: &mut WhenCompareListProto| { &mut m.when_compare_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "else_end_flag",
                    |m: &WhenCompareListProto| { &m.else_end_flag },
                    |m: &mut WhenCompareListProto| { &mut m.else_end_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WhenCompareListProto>(
                    "WhenCompareListProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WhenCompareListProto {
        static mut instance: ::protobuf::lazy::Lazy<WhenCompareListProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WhenCompareListProto,
        };
        unsafe {
            instance.get(WhenCompareListProto::new)
        }
    }
}

impl ::protobuf::Clear for WhenCompareListProto {
    fn clear(&mut self) {
        self.clear_when_compare_list();
        self.clear_else_end_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WhenCompareListProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WhenCompareListProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WhenThenArgumentProto {
    // message fields
    pub when_compare: ::protobuf::RepeatedField<super::message::LogicalCompare>,
    pub then_plan: ::protobuf::SingularPtrField<QueryPlan>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WhenThenArgumentProto {
    pub fn new() -> WhenThenArgumentProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.LogicalCompare when_compare = 1;

    pub fn clear_when_compare(&mut self) {
        self.when_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_when_compare(&mut self, v: ::protobuf::RepeatedField<super::message::LogicalCompare>) {
        self.when_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_when_compare(&mut self) -> &mut ::protobuf::RepeatedField<super::message::LogicalCompare> {
        &mut self.when_compare
    }

    // Take field
    pub fn take_when_compare(&mut self) -> ::protobuf::RepeatedField<super::message::LogicalCompare> {
        ::std::mem::replace(&mut self.when_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_when_compare(&self) -> &[super::message::LogicalCompare] {
        &self.when_compare
    }

    // .maxgraph.QueryPlan then_plan = 2;

    pub fn clear_then_plan(&mut self) {
        self.then_plan.clear();
    }

    pub fn has_then_plan(&self) -> bool {
        self.then_plan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_then_plan(&mut self, v: QueryPlan) {
        self.then_plan = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_then_plan(&mut self) -> &mut QueryPlan {
        if self.then_plan.is_none() {
            self.then_plan.set_default();
        }
        self.then_plan.as_mut().unwrap()
    }

    // Take field
    pub fn take_then_plan(&mut self) -> QueryPlan {
        self.then_plan.take().unwrap_or_else(|| QueryPlan::new())
    }

    pub fn get_then_plan(&self) -> &QueryPlan {
        self.then_plan.as_ref().unwrap_or_else(|| QueryPlan::default_instance())
    }
}

impl ::protobuf::Message for WhenThenArgumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.when_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.then_plan {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.when_compare)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.then_plan)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.when_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.then_plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.when_compare {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.then_plan.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WhenThenArgumentProto {
        WhenThenArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::message::LogicalCompare>>(
                    "when_compare",
                    |m: &WhenThenArgumentProto| { &m.when_compare },
                    |m: &mut WhenThenArgumentProto| { &mut m.when_compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryPlan>>(
                    "then_plan",
                    |m: &WhenThenArgumentProto| { &m.then_plan },
                    |m: &mut WhenThenArgumentProto| { &mut m.then_plan },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WhenThenArgumentProto>(
                    "WhenThenArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WhenThenArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<WhenThenArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WhenThenArgumentProto,
        };
        unsafe {
            instance.get(WhenThenArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for WhenThenArgumentProto {
    fn clear(&mut self) {
        self.clear_when_compare();
        self.clear_then_plan();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WhenThenArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WhenThenArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CaseWhenArgumentProto {
    // message fields
    pub case_plan: ::protobuf::SingularPtrField<QueryPlan>,
    pub when_then_list: ::protobuf::RepeatedField<WhenThenArgumentProto>,
    pub else_end_plan: ::protobuf::SingularPtrField<QueryPlan>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CaseWhenArgumentProto {
    pub fn new() -> CaseWhenArgumentProto {
        ::std::default::Default::default()
    }

    // .maxgraph.QueryPlan case_plan = 1;

    pub fn clear_case_plan(&mut self) {
        self.case_plan.clear();
    }

    pub fn has_case_plan(&self) -> bool {
        self.case_plan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_case_plan(&mut self, v: QueryPlan) {
        self.case_plan = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_case_plan(&mut self) -> &mut QueryPlan {
        if self.case_plan.is_none() {
            self.case_plan.set_default();
        }
        self.case_plan.as_mut().unwrap()
    }

    // Take field
    pub fn take_case_plan(&mut self) -> QueryPlan {
        self.case_plan.take().unwrap_or_else(|| QueryPlan::new())
    }

    pub fn get_case_plan(&self) -> &QueryPlan {
        self.case_plan.as_ref().unwrap_or_else(|| QueryPlan::default_instance())
    }

    // repeated .maxgraph.WhenThenArgumentProto when_then_list = 2;

    pub fn clear_when_then_list(&mut self) {
        self.when_then_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_when_then_list(&mut self, v: ::protobuf::RepeatedField<WhenThenArgumentProto>) {
        self.when_then_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_when_then_list(&mut self) -> &mut ::protobuf::RepeatedField<WhenThenArgumentProto> {
        &mut self.when_then_list
    }

    // Take field
    pub fn take_when_then_list(&mut self) -> ::protobuf::RepeatedField<WhenThenArgumentProto> {
        ::std::mem::replace(&mut self.when_then_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_when_then_list(&self) -> &[WhenThenArgumentProto] {
        &self.when_then_list
    }

    // .maxgraph.QueryPlan else_end_plan = 3;

    pub fn clear_else_end_plan(&mut self) {
        self.else_end_plan.clear();
    }

    pub fn has_else_end_plan(&self) -> bool {
        self.else_end_plan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_else_end_plan(&mut self, v: QueryPlan) {
        self.else_end_plan = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_else_end_plan(&mut self) -> &mut QueryPlan {
        if self.else_end_plan.is_none() {
            self.else_end_plan.set_default();
        }
        self.else_end_plan.as_mut().unwrap()
    }

    // Take field
    pub fn take_else_end_plan(&mut self) -> QueryPlan {
        self.else_end_plan.take().unwrap_or_else(|| QueryPlan::new())
    }

    pub fn get_else_end_plan(&self) -> &QueryPlan {
        self.else_end_plan.as_ref().unwrap_or_else(|| QueryPlan::default_instance())
    }
}

impl ::protobuf::Message for CaseWhenArgumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.case_plan {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.when_then_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.else_end_plan {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.case_plan)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.when_then_list)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.else_end_plan)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.case_plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.when_then_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.else_end_plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.case_plan.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.when_then_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.else_end_plan.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CaseWhenArgumentProto {
        CaseWhenArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryPlan>>(
                    "case_plan",
                    |m: &CaseWhenArgumentProto| { &m.case_plan },
                    |m: &mut CaseWhenArgumentProto| { &mut m.case_plan },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WhenThenArgumentProto>>(
                    "when_then_list",
                    |m: &CaseWhenArgumentProto| { &m.when_then_list },
                    |m: &mut CaseWhenArgumentProto| { &mut m.when_then_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryPlan>>(
                    "else_end_plan",
                    |m: &CaseWhenArgumentProto| { &m.else_end_plan },
                    |m: &mut CaseWhenArgumentProto| { &mut m.else_end_plan },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CaseWhenArgumentProto>(
                    "CaseWhenArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CaseWhenArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<CaseWhenArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CaseWhenArgumentProto,
        };
        unsafe {
            instance.get(CaseWhenArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for CaseWhenArgumentProto {
    fn clear(&mut self) {
        self.clear_case_plan();
        self.clear_when_then_list();
        self.clear_else_end_plan();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CaseWhenArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaseWhenArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MathOperatorProto {
    // message fields
    pub math_token_type: MathTokenType,
    pub operator_value: ::protobuf::SingularPtrField<MathOperatorValueProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MathOperatorProto {
    pub fn new() -> MathOperatorProto {
        ::std::default::Default::default()
    }

    // .maxgraph.MathTokenType math_token_type = 1;

    pub fn clear_math_token_type(&mut self) {
        self.math_token_type = MathTokenType::TOKEN_ERROR;
    }

    // Param is passed by value, moved
    pub fn set_math_token_type(&mut self, v: MathTokenType) {
        self.math_token_type = v;
    }

    pub fn get_math_token_type(&self) -> MathTokenType {
        self.math_token_type
    }

    // .maxgraph.MathOperatorValueProto operator_value = 2;

    pub fn clear_operator_value(&mut self) {
        self.operator_value.clear();
    }

    pub fn has_operator_value(&self) -> bool {
        self.operator_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator_value(&mut self, v: MathOperatorValueProto) {
        self.operator_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator_value(&mut self) -> &mut MathOperatorValueProto {
        if self.operator_value.is_none() {
            self.operator_value.set_default();
        }
        self.operator_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator_value(&mut self) -> MathOperatorValueProto {
        self.operator_value.take().unwrap_or_else(|| MathOperatorValueProto::new())
    }

    pub fn get_operator_value(&self) -> &MathOperatorValueProto {
        self.operator_value.as_ref().unwrap_or_else(|| MathOperatorValueProto::default_instance())
    }
}

impl ::protobuf::Message for MathOperatorProto {
    fn is_initialized(&self) -> bool {
        for v in &self.operator_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.math_token_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.operator_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.math_token_type != MathTokenType::TOKEN_ERROR {
            my_size += ::protobuf::rt::enum_size(1, self.math_token_type);
        }
        if let Some(ref v) = self.operator_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.math_token_type != MathTokenType::TOKEN_ERROR {
            os.write_enum(1, self.math_token_type.value())?;
        }
        if let Some(ref v) = self.operator_value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MathOperatorProto {
        MathOperatorProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MathTokenType>>(
                    "math_token_type",
                    |m: &MathOperatorProto| { &m.math_token_type },
                    |m: &mut MathOperatorProto| { &mut m.math_token_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MathOperatorValueProto>>(
                    "operator_value",
                    |m: &MathOperatorProto| { &m.operator_value },
                    |m: &mut MathOperatorProto| { &mut m.operator_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MathOperatorProto>(
                    "MathOperatorProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MathOperatorProto {
        static mut instance: ::protobuf::lazy::Lazy<MathOperatorProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MathOperatorProto,
        };
        unsafe {
            instance.get(MathOperatorProto::new)
        }
    }
}

impl ::protobuf::Clear for MathOperatorProto {
    fn clear(&mut self) {
        self.clear_math_token_type();
        self.clear_operator_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MathOperatorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MathOperatorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MathFunctionArgumentProto {
    // message fields
    pub function_type: MathFunctionType,
    pub argument_number: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MathFunctionArgumentProto {
    pub fn new() -> MathFunctionArgumentProto {
        ::std::default::Default::default()
    }

    // .maxgraph.MathFunctionType function_type = 1;

    pub fn clear_function_type(&mut self) {
        self.function_type = MathFunctionType::FUNC_SIN;
    }

    // Param is passed by value, moved
    pub fn set_function_type(&mut self, v: MathFunctionType) {
        self.function_type = v;
    }

    pub fn get_function_type(&self) -> MathFunctionType {
        self.function_type
    }

    // int32 argument_number = 2;

    pub fn clear_argument_number(&mut self) {
        self.argument_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_argument_number(&mut self, v: i32) {
        self.argument_number = v;
    }

    pub fn get_argument_number(&self) -> i32 {
        self.argument_number
    }
}

impl ::protobuf::Message for MathFunctionArgumentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.function_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.argument_number = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.function_type != MathFunctionType::FUNC_SIN {
            my_size += ::protobuf::rt::enum_size(1, self.function_type);
        }
        if self.argument_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.argument_number, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.function_type != MathFunctionType::FUNC_SIN {
            os.write_enum(1, self.function_type.value())?;
        }
        if self.argument_number != 0 {
            os.write_int32(2, self.argument_number)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MathFunctionArgumentProto {
        MathFunctionArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MathFunctionType>>(
                    "function_type",
                    |m: &MathFunctionArgumentProto| { &m.function_type },
                    |m: &mut MathFunctionArgumentProto| { &mut m.function_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "argument_number",
                    |m: &MathFunctionArgumentProto| { &m.argument_number },
                    |m: &mut MathFunctionArgumentProto| { &mut m.argument_number },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MathFunctionArgumentProto>(
                    "MathFunctionArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MathFunctionArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<MathFunctionArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MathFunctionArgumentProto,
        };
        unsafe {
            instance.get(MathFunctionArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for MathFunctionArgumentProto {
    fn clear(&mut self) {
        self.clear_function_type();
        self.clear_argument_number();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MathFunctionArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MathFunctionArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MathOpTokenArgumentProto {
    // message fields
    pub op_token_type: MathOperatorTokenType,
    pub num_operands: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MathOpTokenArgumentProto {
    pub fn new() -> MathOpTokenArgumentProto {
        ::std::default::Default::default()
    }

    // .maxgraph.MathOperatorTokenType op_token_type = 1;

    pub fn clear_op_token_type(&mut self) {
        self.op_token_type = MathOperatorTokenType::OP_ADDITION;
    }

    // Param is passed by value, moved
    pub fn set_op_token_type(&mut self, v: MathOperatorTokenType) {
        self.op_token_type = v;
    }

    pub fn get_op_token_type(&self) -> MathOperatorTokenType {
        self.op_token_type
    }

    // int32 num_operands = 2;

    pub fn clear_num_operands(&mut self) {
        self.num_operands = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_operands(&mut self, v: i32) {
        self.num_operands = v;
    }

    pub fn get_num_operands(&self) -> i32 {
        self.num_operands
    }
}

impl ::protobuf::Message for MathOpTokenArgumentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op_token_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_operands = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op_token_type != MathOperatorTokenType::OP_ADDITION {
            my_size += ::protobuf::rt::enum_size(1, self.op_token_type);
        }
        if self.num_operands != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_operands, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.op_token_type != MathOperatorTokenType::OP_ADDITION {
            os.write_enum(1, self.op_token_type.value())?;
        }
        if self.num_operands != 0 {
            os.write_int32(2, self.num_operands)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MathOpTokenArgumentProto {
        MathOpTokenArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MathOperatorTokenType>>(
                    "op_token_type",
                    |m: &MathOpTokenArgumentProto| { &m.op_token_type },
                    |m: &mut MathOpTokenArgumentProto| { &mut m.op_token_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_operands",
                    |m: &MathOpTokenArgumentProto| { &m.num_operands },
                    |m: &mut MathOpTokenArgumentProto| { &mut m.num_operands },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MathOpTokenArgumentProto>(
                    "MathOpTokenArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MathOpTokenArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<MathOpTokenArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MathOpTokenArgumentProto,
        };
        unsafe {
            instance.get(MathOpTokenArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for MathOpTokenArgumentProto {
    fn clear(&mut self) {
        self.clear_op_token_type();
        self.clear_num_operands();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MathOpTokenArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MathOpTokenArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MathOperatorValueProto {
    // message fields
    pub double_value: f64,
    pub string_value: ::std::string::String,
    pub int_value: i32,
    pub func_arg: ::protobuf::SingularPtrField<MathFunctionArgumentProto>,
    pub op_token_arg: ::protobuf::SingularPtrField<MathOpTokenArgumentProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MathOperatorValueProto {
    pub fn new() -> MathOperatorValueProto {
        ::std::default::Default::default()
    }

    // double double_value = 1;

    pub fn clear_double_value(&mut self) {
        self.double_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = v;
    }

    pub fn get_double_value(&self) -> f64 {
        self.double_value
    }

    // string string_value = 2;

    pub fn clear_string_value(&mut self) {
        self.string_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        &mut self.string_value
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.string_value, ::std::string::String::new())
    }

    pub fn get_string_value(&self) -> &str {
        &self.string_value
    }

    // int32 int_value = 3;

    pub fn clear_int_value(&mut self) {
        self.int_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = v;
    }

    pub fn get_int_value(&self) -> i32 {
        self.int_value
    }

    // .maxgraph.MathFunctionArgumentProto func_arg = 4;

    pub fn clear_func_arg(&mut self) {
        self.func_arg.clear();
    }

    pub fn has_func_arg(&self) -> bool {
        self.func_arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_func_arg(&mut self, v: MathFunctionArgumentProto) {
        self.func_arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_func_arg(&mut self) -> &mut MathFunctionArgumentProto {
        if self.func_arg.is_none() {
            self.func_arg.set_default();
        }
        self.func_arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_func_arg(&mut self) -> MathFunctionArgumentProto {
        self.func_arg.take().unwrap_or_else(|| MathFunctionArgumentProto::new())
    }

    pub fn get_func_arg(&self) -> &MathFunctionArgumentProto {
        self.func_arg.as_ref().unwrap_or_else(|| MathFunctionArgumentProto::default_instance())
    }

    // .maxgraph.MathOpTokenArgumentProto op_token_arg = 5;

    pub fn clear_op_token_arg(&mut self) {
        self.op_token_arg.clear();
    }

    pub fn has_op_token_arg(&self) -> bool {
        self.op_token_arg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_token_arg(&mut self, v: MathOpTokenArgumentProto) {
        self.op_token_arg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_token_arg(&mut self) -> &mut MathOpTokenArgumentProto {
        if self.op_token_arg.is_none() {
            self.op_token_arg.set_default();
        }
        self.op_token_arg.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_token_arg(&mut self) -> MathOpTokenArgumentProto {
        self.op_token_arg.take().unwrap_or_else(|| MathOpTokenArgumentProto::new())
    }

    pub fn get_op_token_arg(&self) -> &MathOpTokenArgumentProto {
        self.op_token_arg.as_ref().unwrap_or_else(|| MathOpTokenArgumentProto::default_instance())
    }
}

impl ::protobuf::Message for MathOperatorValueProto {
    fn is_initialized(&self) -> bool {
        for v in &self.func_arg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.op_token_arg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.double_value = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.string_value)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.int_value = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.func_arg)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.op_token_arg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.double_value != 0. {
            my_size += 9;
        }
        if !self.string_value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.string_value);
        }
        if self.int_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.int_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.func_arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.op_token_arg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.double_value != 0. {
            os.write_double(1, self.double_value)?;
        }
        if !self.string_value.is_empty() {
            os.write_string(2, &self.string_value)?;
        }
        if self.int_value != 0 {
            os.write_int32(3, self.int_value)?;
        }
        if let Some(ref v) = self.func_arg.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.op_token_arg.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MathOperatorValueProto {
        MathOperatorValueProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "double_value",
                    |m: &MathOperatorValueProto| { &m.double_value },
                    |m: &mut MathOperatorValueProto| { &mut m.double_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "string_value",
                    |m: &MathOperatorValueProto| { &m.string_value },
                    |m: &mut MathOperatorValueProto| { &mut m.string_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int_value",
                    |m: &MathOperatorValueProto| { &m.int_value },
                    |m: &mut MathOperatorValueProto| { &mut m.int_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MathFunctionArgumentProto>>(
                    "func_arg",
                    |m: &MathOperatorValueProto| { &m.func_arg },
                    |m: &mut MathOperatorValueProto| { &mut m.func_arg },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MathOpTokenArgumentProto>>(
                    "op_token_arg",
                    |m: &MathOperatorValueProto| { &m.op_token_arg },
                    |m: &mut MathOperatorValueProto| { &mut m.op_token_arg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MathOperatorValueProto>(
                    "MathOperatorValueProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MathOperatorValueProto {
        static mut instance: ::protobuf::lazy::Lazy<MathOperatorValueProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MathOperatorValueProto,
        };
        unsafe {
            instance.get(MathOperatorValueProto::new)
        }
    }
}

impl ::protobuf::Clear for MathOperatorValueProto {
    fn clear(&mut self) {
        self.clear_double_value();
        self.clear_string_value();
        self.clear_int_value();
        self.clear_func_arg();
        self.clear_op_token_arg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MathOperatorValueProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MathOperatorValueProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MathArgumentProto {
    // message fields
    pub math_token_list: ::protobuf::RepeatedField<MathOperatorProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MathArgumentProto {
    pub fn new() -> MathArgumentProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.MathOperatorProto math_token_list = 1;

    pub fn clear_math_token_list(&mut self) {
        self.math_token_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_math_token_list(&mut self, v: ::protobuf::RepeatedField<MathOperatorProto>) {
        self.math_token_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_math_token_list(&mut self) -> &mut ::protobuf::RepeatedField<MathOperatorProto> {
        &mut self.math_token_list
    }

    // Take field
    pub fn take_math_token_list(&mut self) -> ::protobuf::RepeatedField<MathOperatorProto> {
        ::std::mem::replace(&mut self.math_token_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_math_token_list(&self) -> &[MathOperatorProto] {
        &self.math_token_list
    }
}

impl ::protobuf::Message for MathArgumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.math_token_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.math_token_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.math_token_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.math_token_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MathArgumentProto {
        MathArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MathOperatorProto>>(
                    "math_token_list",
                    |m: &MathArgumentProto| { &m.math_token_list },
                    |m: &mut MathArgumentProto| { &mut m.math_token_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MathArgumentProto>(
                    "MathArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MathArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<MathArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MathArgumentProto,
        };
        unsafe {
            instance.get(MathArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for MathArgumentProto {
    fn clear(&mut self) {
        self.clear_math_token_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MathArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MathArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CountArgumentProto {
    // message fields
    pub limit_flag: bool,
    pub limit_count: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CountArgumentProto {
    pub fn new() -> CountArgumentProto {
        ::std::default::Default::default()
    }

    // bool limit_flag = 1;

    pub fn clear_limit_flag(&mut self) {
        self.limit_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_limit_flag(&mut self, v: bool) {
        self.limit_flag = v;
    }

    pub fn get_limit_flag(&self) -> bool {
        self.limit_flag
    }

    // int64 limit_count = 2;

    pub fn clear_limit_count(&mut self) {
        self.limit_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit_count(&mut self, v: i64) {
        self.limit_count = v;
    }

    pub fn get_limit_count(&self) -> i64 {
        self.limit_count
    }
}

impl ::protobuf::Message for CountArgumentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.limit_flag = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.limit_flag != false {
            my_size += 2;
        }
        if self.limit_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.limit_flag != false {
            os.write_bool(1, self.limit_flag)?;
        }
        if self.limit_count != 0 {
            os.write_int64(2, self.limit_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountArgumentProto {
        CountArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "limit_flag",
                    |m: &CountArgumentProto| { &m.limit_flag },
                    |m: &mut CountArgumentProto| { &mut m.limit_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit_count",
                    |m: &CountArgumentProto| { &m.limit_count },
                    |m: &mut CountArgumentProto| { &mut m.limit_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CountArgumentProto>(
                    "CountArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CountArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<CountArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CountArgumentProto,
        };
        unsafe {
            instance.get(CountArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for CountArgumentProto {
    fn clear(&mut self) {
        self.clear_limit_flag();
        self.clear_limit_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnterKeyArgumentProto {
    // message fields
    pub enter_key_type: EnterKeyTypeProto,
    pub prop_label_id: i32,
    pub prop_id_list: ::std::vec::Vec<i32>,
    pub uniq_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EnterKeyArgumentProto {
    pub fn new() -> EnterKeyArgumentProto {
        ::std::default::Default::default()
    }

    // .maxgraph.EnterKeyTypeProto enter_key_type = 1;

    pub fn clear_enter_key_type(&mut self) {
        self.enter_key_type = EnterKeyTypeProto::KEY_SELF;
    }

    // Param is passed by value, moved
    pub fn set_enter_key_type(&mut self, v: EnterKeyTypeProto) {
        self.enter_key_type = v;
    }

    pub fn get_enter_key_type(&self) -> EnterKeyTypeProto {
        self.enter_key_type
    }

    // int32 prop_label_id = 2;

    pub fn clear_prop_label_id(&mut self) {
        self.prop_label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_prop_label_id(&mut self, v: i32) {
        self.prop_label_id = v;
    }

    pub fn get_prop_label_id(&self) -> i32 {
        self.prop_label_id
    }

    // repeated int32 prop_id_list = 3;

    pub fn clear_prop_id_list(&mut self) {
        self.prop_id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_id_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.prop_id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_id_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.prop_id_list
    }

    // Take field
    pub fn take_prop_id_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.prop_id_list, ::std::vec::Vec::new())
    }

    pub fn get_prop_id_list(&self) -> &[i32] {
        &self.prop_id_list
    }

    // bool uniq_flag = 4;

    pub fn clear_uniq_flag(&mut self) {
        self.uniq_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_uniq_flag(&mut self, v: bool) {
        self.uniq_flag = v;
    }

    pub fn get_uniq_flag(&self) -> bool {
        self.uniq_flag
    }
}

impl ::protobuf::Message for EnterKeyArgumentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.enter_key_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.prop_label_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.prop_id_list)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.uniq_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enter_key_type != EnterKeyTypeProto::KEY_SELF {
            my_size += ::protobuf::rt::enum_size(1, self.enter_key_type);
        }
        if self.prop_label_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.prop_label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.prop_id_list {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.uniq_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.enter_key_type != EnterKeyTypeProto::KEY_SELF {
            os.write_enum(1, self.enter_key_type.value())?;
        }
        if self.prop_label_id != 0 {
            os.write_int32(2, self.prop_label_id)?;
        }
        for v in &self.prop_id_list {
            os.write_int32(3, *v)?;
        };
        if self.uniq_flag != false {
            os.write_bool(4, self.uniq_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnterKeyArgumentProto {
        EnterKeyArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EnterKeyTypeProto>>(
                    "enter_key_type",
                    |m: &EnterKeyArgumentProto| { &m.enter_key_type },
                    |m: &mut EnterKeyArgumentProto| { &mut m.enter_key_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_label_id",
                    |m: &EnterKeyArgumentProto| { &m.prop_label_id },
                    |m: &mut EnterKeyArgumentProto| { &mut m.prop_label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_id_list",
                    |m: &EnterKeyArgumentProto| { &m.prop_id_list },
                    |m: &mut EnterKeyArgumentProto| { &mut m.prop_id_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "uniq_flag",
                    |m: &EnterKeyArgumentProto| { &m.uniq_flag },
                    |m: &mut EnterKeyArgumentProto| { &mut m.uniq_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnterKeyArgumentProto>(
                    "EnterKeyArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnterKeyArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<EnterKeyArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnterKeyArgumentProto,
        };
        unsafe {
            instance.get(EnterKeyArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for EnterKeyArgumentProto {
    fn clear(&mut self) {
        self.clear_enter_key_type();
        self.clear_prop_label_id();
        self.clear_prop_id_list();
        self.clear_uniq_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnterKeyArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnterKeyArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RepeatArgumentProto {
    // message fields
    pub leave_id: i32,
    pub feedback_id: i32,
    pub loop_limit: i32,
    pub emit_flag: bool,
    pub plan: ::protobuf::SingularPtrField<QueryPlan>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RepeatArgumentProto {
    pub fn new() -> RepeatArgumentProto {
        ::std::default::Default::default()
    }

    // int32 leave_id = 1;

    pub fn clear_leave_id(&mut self) {
        self.leave_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_leave_id(&mut self, v: i32) {
        self.leave_id = v;
    }

    pub fn get_leave_id(&self) -> i32 {
        self.leave_id
    }

    // int32 feedback_id = 2;

    pub fn clear_feedback_id(&mut self) {
        self.feedback_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_feedback_id(&mut self, v: i32) {
        self.feedback_id = v;
    }

    pub fn get_feedback_id(&self) -> i32 {
        self.feedback_id
    }

    // int32 loop_limit = 3;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // bool emit_flag = 4;

    pub fn clear_emit_flag(&mut self) {
        self.emit_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_emit_flag(&mut self, v: bool) {
        self.emit_flag = v;
    }

    pub fn get_emit_flag(&self) -> bool {
        self.emit_flag
    }

    // .maxgraph.QueryPlan plan = 5;

    pub fn clear_plan(&mut self) {
        self.plan.clear();
    }

    pub fn has_plan(&self) -> bool {
        self.plan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plan(&mut self, v: QueryPlan) {
        self.plan = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plan(&mut self) -> &mut QueryPlan {
        if self.plan.is_none() {
            self.plan.set_default();
        }
        self.plan.as_mut().unwrap()
    }

    // Take field
    pub fn take_plan(&mut self) -> QueryPlan {
        self.plan.take().unwrap_or_else(|| QueryPlan::new())
    }

    pub fn get_plan(&self) -> &QueryPlan {
        self.plan.as_ref().unwrap_or_else(|| QueryPlan::default_instance())
    }
}

impl ::protobuf::Message for RepeatArgumentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.plan {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.leave_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.feedback_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.emit_flag = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plan)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.leave_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.leave_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.feedback_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.feedback_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.emit_flag != false {
            my_size += 2;
        }
        if let Some(ref v) = self.plan.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.leave_id != 0 {
            os.write_int32(1, self.leave_id)?;
        }
        if self.feedback_id != 0 {
            os.write_int32(2, self.feedback_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(3, self.loop_limit)?;
        }
        if self.emit_flag != false {
            os.write_bool(4, self.emit_flag)?;
        }
        if let Some(ref v) = self.plan.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RepeatArgumentProto {
        RepeatArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "leave_id",
                    |m: &RepeatArgumentProto| { &m.leave_id },
                    |m: &mut RepeatArgumentProto| { &mut m.leave_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "feedback_id",
                    |m: &RepeatArgumentProto| { &m.feedback_id },
                    |m: &mut RepeatArgumentProto| { &mut m.feedback_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &RepeatArgumentProto| { &m.loop_limit },
                    |m: &mut RepeatArgumentProto| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "emit_flag",
                    |m: &RepeatArgumentProto| { &m.emit_flag },
                    |m: &mut RepeatArgumentProto| { &mut m.emit_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryPlan>>(
                    "plan",
                    |m: &RepeatArgumentProto| { &m.plan },
                    |m: &mut RepeatArgumentProto| { &mut m.plan },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RepeatArgumentProto>(
                    "RepeatArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RepeatArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<RepeatArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RepeatArgumentProto,
        };
        unsafe {
            instance.get(RepeatArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for RepeatArgumentProto {
    fn clear(&mut self) {
        self.clear_leave_id();
        self.clear_feedback_id();
        self.clear_loop_limit();
        self.clear_emit_flag();
        self.clear_plan();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RepeatArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RepeatArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BarrierArgumentProto {
    // message fields
    pub barrier_size: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BarrierArgumentProto {
    pub fn new() -> BarrierArgumentProto {
        ::std::default::Default::default()
    }

    // int32 barrier_size = 1;

    pub fn clear_barrier_size(&mut self) {
        self.barrier_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_barrier_size(&mut self, v: i32) {
        self.barrier_size = v;
    }

    pub fn get_barrier_size(&self) -> i32 {
        self.barrier_size
    }
}

impl ::protobuf::Message for BarrierArgumentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.barrier_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.barrier_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.barrier_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.barrier_size != 0 {
            os.write_int32(1, self.barrier_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BarrierArgumentProto {
        BarrierArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "barrier_size",
                    |m: &BarrierArgumentProto| { &m.barrier_size },
                    |m: &mut BarrierArgumentProto| { &mut m.barrier_size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BarrierArgumentProto>(
                    "BarrierArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BarrierArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<BarrierArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BarrierArgumentProto,
        };
        unsafe {
            instance.get(BarrierArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for BarrierArgumentProto {
    fn clear(&mut self) {
        self.clear_barrier_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BarrierArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BarrierArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateGraphArgumentProto {
    // message fields
    pub graph_name: ::std::string::String,
    pub crate_graph_type: CreateGraphTypeProto,
    pub graph_schema: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateGraphArgumentProto {
    pub fn new() -> CreateGraphArgumentProto {
        ::std::default::Default::default()
    }

    // string graph_name = 1;

    pub fn clear_graph_name(&mut self) {
        self.graph_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_name(&mut self, v: ::std::string::String) {
        self.graph_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_name(&mut self) -> &mut ::std::string::String {
        &mut self.graph_name
    }

    // Take field
    pub fn take_graph_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_name, ::std::string::String::new())
    }

    pub fn get_graph_name(&self) -> &str {
        &self.graph_name
    }

    // .maxgraph.CreateGraphTypeProto crate_graph_type = 2;

    pub fn clear_crate_graph_type(&mut self) {
        self.crate_graph_type = CreateGraphTypeProto::VINEYARD;
    }

    // Param is passed by value, moved
    pub fn set_crate_graph_type(&mut self, v: CreateGraphTypeProto) {
        self.crate_graph_type = v;
    }

    pub fn get_crate_graph_type(&self) -> CreateGraphTypeProto {
        self.crate_graph_type
    }

    // string graph_schema = 3;

    pub fn clear_graph_schema(&mut self) {
        self.graph_schema.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_schema(&mut self, v: ::std::string::String) {
        self.graph_schema = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_schema(&mut self) -> &mut ::std::string::String {
        &mut self.graph_schema
    }

    // Take field
    pub fn take_graph_schema(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_schema, ::std::string::String::new())
    }

    pub fn get_graph_schema(&self) -> &str {
        &self.graph_schema
    }
}

impl ::protobuf::Message for CreateGraphArgumentProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.crate_graph_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_schema)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.graph_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph_name);
        }
        if self.crate_graph_type != CreateGraphTypeProto::VINEYARD {
            my_size += ::protobuf::rt::enum_size(2, self.crate_graph_type);
        }
        if !self.graph_schema.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.graph_schema);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.graph_name.is_empty() {
            os.write_string(1, &self.graph_name)?;
        }
        if self.crate_graph_type != CreateGraphTypeProto::VINEYARD {
            os.write_enum(2, self.crate_graph_type.value())?;
        }
        if !self.graph_schema.is_empty() {
            os.write_string(3, &self.graph_schema)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateGraphArgumentProto {
        CreateGraphArgumentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "graph_name",
                    |m: &CreateGraphArgumentProto| { &m.graph_name },
                    |m: &mut CreateGraphArgumentProto| { &mut m.graph_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CreateGraphTypeProto>>(
                    "crate_graph_type",
                    |m: &CreateGraphArgumentProto| { &m.crate_graph_type },
                    |m: &mut CreateGraphArgumentProto| { &mut m.crate_graph_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "graph_schema",
                    |m: &CreateGraphArgumentProto| { &m.graph_schema },
                    |m: &mut CreateGraphArgumentProto| { &mut m.graph_schema },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateGraphArgumentProto>(
                    "CreateGraphArgumentProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateGraphArgumentProto {
        static mut instance: ::protobuf::lazy::Lazy<CreateGraphArgumentProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateGraphArgumentProto,
        };
        unsafe {
            instance.get(CreateGraphArgumentProto::new)
        }
    }
}

impl ::protobuf::Clear for CreateGraphArgumentProto {
    fn clear(&mut self) {
        self.clear_graph_name();
        self.clear_crate_graph_type();
        self.clear_graph_schema();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateGraphArgumentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGraphArgumentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimePropertyProto {
    // message fields
    pub id: i32,
    pub name: ::std::string::String,
    pub data_type: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimePropertyProto {
    pub fn new() -> RuntimePropertyProto {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string data_type = 3;

    pub fn clear_data_type(&mut self) {
        self.data_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: ::std::string::String) {
        self.data_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_type(&mut self) -> &mut ::std::string::String {
        &mut self.data_type
    }

    // Take field
    pub fn take_data_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data_type, ::std::string::String::new())
    }

    pub fn get_data_type(&self) -> &str {
        &self.data_type
    }
}

impl ::protobuf::Message for RuntimePropertyProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.data_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.data_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.data_type.is_empty() {
            os.write_string(3, &self.data_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimePropertyProto {
        RuntimePropertyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &RuntimePropertyProto| { &m.id },
                    |m: &mut RuntimePropertyProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &RuntimePropertyProto| { &m.name },
                    |m: &mut RuntimePropertyProto| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data_type",
                    |m: &RuntimePropertyProto| { &m.data_type },
                    |m: &mut RuntimePropertyProto| { &mut m.data_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimePropertyProto>(
                    "RuntimePropertyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimePropertyProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimePropertyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimePropertyProto,
        };
        unsafe {
            instance.get(RuntimePropertyProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimePropertyProto {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_name();
        self.clear_data_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimePropertyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimePropertyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeVertexTypeProto {
    // message fields
    pub label_id: i32,
    pub label_name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<RuntimePropertyProto>,
    pub primary_keys: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeVertexTypeProto {
    pub fn new() -> RuntimeVertexTypeProto {
        ::std::default::Default::default()
    }

    // int32 label_id = 1;

    pub fn clear_label_id(&mut self) {
        self.label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: i32) {
        self.label_id = v;
    }

    pub fn get_label_id(&self) -> i32 {
        self.label_id
    }

    // string label_name = 2;

    pub fn clear_label_name(&mut self) {
        self.label_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_name(&mut self, v: ::std::string::String) {
        self.label_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_name(&mut self) -> &mut ::std::string::String {
        &mut self.label_name
    }

    // Take field
    pub fn take_label_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label_name, ::std::string::String::new())
    }

    pub fn get_label_name(&self) -> &str {
        &self.label_name
    }

    // repeated .maxgraph.RuntimePropertyProto properties = 3;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<RuntimePropertyProto>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<RuntimePropertyProto> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<RuntimePropertyProto> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[RuntimePropertyProto] {
        &self.properties
    }

    // repeated string primary_keys = 4;

    pub fn clear_primary_keys(&mut self) {
        self.primary_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.primary_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primary_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.primary_keys
    }

    // Take field
    pub fn take_primary_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.primary_keys, ::protobuf::RepeatedField::new())
    }

    pub fn get_primary_keys(&self) -> &[::std::string::String] {
        &self.primary_keys
    }
}

impl ::protobuf::Message for RuntimeVertexTypeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.primary_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.label_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label_name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.primary_keys {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.label_id != 0 {
            os.write_int32(1, self.label_id)?;
        }
        if !self.label_name.is_empty() {
            os.write_string(2, &self.label_name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.primary_keys {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeVertexTypeProto {
        RuntimeVertexTypeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_id",
                    |m: &RuntimeVertexTypeProto| { &m.label_id },
                    |m: &mut RuntimeVertexTypeProto| { &mut m.label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label_name",
                    |m: &RuntimeVertexTypeProto| { &m.label_name },
                    |m: &mut RuntimeVertexTypeProto| { &mut m.label_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimePropertyProto>>(
                    "properties",
                    |m: &RuntimeVertexTypeProto| { &m.properties },
                    |m: &mut RuntimeVertexTypeProto| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "primary_keys",
                    |m: &RuntimeVertexTypeProto| { &m.primary_keys },
                    |m: &mut RuntimeVertexTypeProto| { &mut m.primary_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeVertexTypeProto>(
                    "RuntimeVertexTypeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeVertexTypeProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeVertexTypeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeVertexTypeProto,
        };
        unsafe {
            instance.get(RuntimeVertexTypeProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeVertexTypeProto {
    fn clear(&mut self) {
        self.clear_label_id();
        self.clear_label_name();
        self.clear_properties();
        self.clear_primary_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeVertexTypeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeVertexTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeEdgeRelationProto {
    // message fields
    pub source_label: ::std::string::String,
    pub target_label: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeEdgeRelationProto {
    pub fn new() -> RuntimeEdgeRelationProto {
        ::std::default::Default::default()
    }

    // string source_label = 1;

    pub fn clear_source_label(&mut self) {
        self.source_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_label(&mut self, v: ::std::string::String) {
        self.source_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_label(&mut self) -> &mut ::std::string::String {
        &mut self.source_label
    }

    // Take field
    pub fn take_source_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_label, ::std::string::String::new())
    }

    pub fn get_source_label(&self) -> &str {
        &self.source_label
    }

    // string target_label = 2;

    pub fn clear_target_label(&mut self) {
        self.target_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_label(&mut self, v: ::std::string::String) {
        self.target_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_label(&mut self) -> &mut ::std::string::String {
        &mut self.target_label
    }

    // Take field
    pub fn take_target_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_label, ::std::string::String::new())
    }

    pub fn get_target_label(&self) -> &str {
        &self.target_label
    }
}

impl ::protobuf::Message for RuntimeEdgeRelationProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_label)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target_label)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.source_label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source_label);
        }
        if !self.target_label.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.target_label);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.source_label.is_empty() {
            os.write_string(1, &self.source_label)?;
        }
        if !self.target_label.is_empty() {
            os.write_string(2, &self.target_label)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeEdgeRelationProto {
        RuntimeEdgeRelationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source_label",
                    |m: &RuntimeEdgeRelationProto| { &m.source_label },
                    |m: &mut RuntimeEdgeRelationProto| { &mut m.source_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "target_label",
                    |m: &RuntimeEdgeRelationProto| { &m.target_label },
                    |m: &mut RuntimeEdgeRelationProto| { &mut m.target_label },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeEdgeRelationProto>(
                    "RuntimeEdgeRelationProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeEdgeRelationProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeEdgeRelationProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeEdgeRelationProto,
        };
        unsafe {
            instance.get(RuntimeEdgeRelationProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeEdgeRelationProto {
    fn clear(&mut self) {
        self.clear_source_label();
        self.clear_target_label();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeEdgeRelationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeEdgeRelationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeEdgeTypeProto {
    // message fields
    pub label_id: i32,
    pub label_name: ::std::string::String,
    pub properties: ::protobuf::RepeatedField<RuntimePropertyProto>,
    pub relations: ::protobuf::RepeatedField<RuntimeEdgeRelationProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeEdgeTypeProto {
    pub fn new() -> RuntimeEdgeTypeProto {
        ::std::default::Default::default()
    }

    // int32 label_id = 1;

    pub fn clear_label_id(&mut self) {
        self.label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: i32) {
        self.label_id = v;
    }

    pub fn get_label_id(&self) -> i32 {
        self.label_id
    }

    // string label_name = 2;

    pub fn clear_label_name(&mut self) {
        self.label_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_name(&mut self, v: ::std::string::String) {
        self.label_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_name(&mut self) -> &mut ::std::string::String {
        &mut self.label_name
    }

    // Take field
    pub fn take_label_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label_name, ::std::string::String::new())
    }

    pub fn get_label_name(&self) -> &str {
        &self.label_name
    }

    // repeated .maxgraph.RuntimePropertyProto properties = 3;

    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: ::protobuf::RepeatedField<RuntimePropertyProto>) {
        self.properties = v;
    }

    // Mutable pointer to the field.
    pub fn mut_properties(&mut self) -> &mut ::protobuf::RepeatedField<RuntimePropertyProto> {
        &mut self.properties
    }

    // Take field
    pub fn take_properties(&mut self) -> ::protobuf::RepeatedField<RuntimePropertyProto> {
        ::std::mem::replace(&mut self.properties, ::protobuf::RepeatedField::new())
    }

    pub fn get_properties(&self) -> &[RuntimePropertyProto] {
        &self.properties
    }

    // repeated .maxgraph.RuntimeEdgeRelationProto relations = 4;

    pub fn clear_relations(&mut self) {
        self.relations.clear();
    }

    // Param is passed by value, moved
    pub fn set_relations(&mut self, v: ::protobuf::RepeatedField<RuntimeEdgeRelationProto>) {
        self.relations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_relations(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeEdgeRelationProto> {
        &mut self.relations
    }

    // Take field
    pub fn take_relations(&mut self) -> ::protobuf::RepeatedField<RuntimeEdgeRelationProto> {
        ::std::mem::replace(&mut self.relations, ::protobuf::RepeatedField::new())
    }

    pub fn get_relations(&self) -> &[RuntimeEdgeRelationProto] {
        &self.relations
    }
}

impl ::protobuf::Message for RuntimeEdgeTypeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.relations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.properties)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.relations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.label_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.label_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.label_name);
        }
        for value in &self.properties {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.relations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.label_id != 0 {
            os.write_int32(1, self.label_id)?;
        }
        if !self.label_name.is_empty() {
            os.write_string(2, &self.label_name)?;
        }
        for v in &self.properties {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.relations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeEdgeTypeProto {
        RuntimeEdgeTypeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_id",
                    |m: &RuntimeEdgeTypeProto| { &m.label_id },
                    |m: &mut RuntimeEdgeTypeProto| { &mut m.label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "label_name",
                    |m: &RuntimeEdgeTypeProto| { &m.label_name },
                    |m: &mut RuntimeEdgeTypeProto| { &mut m.label_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimePropertyProto>>(
                    "properties",
                    |m: &RuntimeEdgeTypeProto| { &m.properties },
                    |m: &mut RuntimeEdgeTypeProto| { &mut m.properties },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeEdgeRelationProto>>(
                    "relations",
                    |m: &RuntimeEdgeTypeProto| { &m.relations },
                    |m: &mut RuntimeEdgeTypeProto| { &mut m.relations },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeEdgeTypeProto>(
                    "RuntimeEdgeTypeProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeEdgeTypeProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeEdgeTypeProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeEdgeTypeProto,
        };
        unsafe {
            instance.get(RuntimeEdgeTypeProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeEdgeTypeProto {
    fn clear(&mut self) {
        self.clear_label_id();
        self.clear_label_name();
        self.clear_properties();
        self.clear_relations();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeEdgeTypeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeEdgeTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeGraphSchemaProto {
    // message fields
    pub vertex_types: ::protobuf::RepeatedField<RuntimeVertexTypeProto>,
    pub edge_types: ::protobuf::RepeatedField<RuntimeEdgeTypeProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RuntimeGraphSchemaProto {
    pub fn new() -> RuntimeGraphSchemaProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.RuntimeVertexTypeProto vertex_types = 1;

    pub fn clear_vertex_types(&mut self) {
        self.vertex_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_vertex_types(&mut self, v: ::protobuf::RepeatedField<RuntimeVertexTypeProto>) {
        self.vertex_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_vertex_types(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeVertexTypeProto> {
        &mut self.vertex_types
    }

    // Take field
    pub fn take_vertex_types(&mut self) -> ::protobuf::RepeatedField<RuntimeVertexTypeProto> {
        ::std::mem::replace(&mut self.vertex_types, ::protobuf::RepeatedField::new())
    }

    pub fn get_vertex_types(&self) -> &[RuntimeVertexTypeProto] {
        &self.vertex_types
    }

    // repeated .maxgraph.RuntimeEdgeTypeProto edge_types = 2;

    pub fn clear_edge_types(&mut self) {
        self.edge_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_types(&mut self, v: ::protobuf::RepeatedField<RuntimeEdgeTypeProto>) {
        self.edge_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_types(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeEdgeTypeProto> {
        &mut self.edge_types
    }

    // Take field
    pub fn take_edge_types(&mut self) -> ::protobuf::RepeatedField<RuntimeEdgeTypeProto> {
        ::std::mem::replace(&mut self.edge_types, ::protobuf::RepeatedField::new())
    }

    pub fn get_edge_types(&self) -> &[RuntimeEdgeTypeProto] {
        &self.edge_types
    }
}

impl ::protobuf::Message for RuntimeGraphSchemaProto {
    fn is_initialized(&self) -> bool {
        for v in &self.vertex_types {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.edge_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.vertex_types)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.edge_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.vertex_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.edge_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.vertex_types {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.edge_types {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeGraphSchemaProto {
        RuntimeGraphSchemaProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeVertexTypeProto>>(
                    "vertex_types",
                    |m: &RuntimeGraphSchemaProto| { &m.vertex_types },
                    |m: &mut RuntimeGraphSchemaProto| { &mut m.vertex_types },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeEdgeTypeProto>>(
                    "edge_types",
                    |m: &RuntimeGraphSchemaProto| { &m.edge_types },
                    |m: &mut RuntimeGraphSchemaProto| { &mut m.edge_types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RuntimeGraphSchemaProto>(
                    "RuntimeGraphSchemaProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RuntimeGraphSchemaProto {
        static mut instance: ::protobuf::lazy::Lazy<RuntimeGraphSchemaProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RuntimeGraphSchemaProto,
        };
        unsafe {
            instance.get(RuntimeGraphSchemaProto::new)
        }
    }
}

impl ::protobuf::Clear for RuntimeGraphSchemaProto {
    fn clear(&mut self) {
        self.clear_vertex_types();
        self.clear_edge_types();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeGraphSchemaProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeGraphSchemaProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexPrimaryKeyListProto {
    // message fields
    pub primary_keys: ::protobuf::RepeatedField<VertexPrimaryKeyProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VertexPrimaryKeyListProto {
    pub fn new() -> VertexPrimaryKeyListProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.VertexPrimaryKeyProto primary_keys = 1;

    pub fn clear_primary_keys(&mut self) {
        self.primary_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_keys(&mut self, v: ::protobuf::RepeatedField<VertexPrimaryKeyProto>) {
        self.primary_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_primary_keys(&mut self) -> &mut ::protobuf::RepeatedField<VertexPrimaryKeyProto> {
        &mut self.primary_keys
    }

    // Take field
    pub fn take_primary_keys(&mut self) -> ::protobuf::RepeatedField<VertexPrimaryKeyProto> {
        ::std::mem::replace(&mut self.primary_keys, ::protobuf::RepeatedField::new())
    }

    pub fn get_primary_keys(&self) -> &[VertexPrimaryKeyProto] {
        &self.primary_keys
    }
}

impl ::protobuf::Message for VertexPrimaryKeyListProto {
    fn is_initialized(&self) -> bool {
        for v in &self.primary_keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.primary_keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.primary_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.primary_keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexPrimaryKeyListProto {
        VertexPrimaryKeyListProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VertexPrimaryKeyProto>>(
                    "primary_keys",
                    |m: &VertexPrimaryKeyListProto| { &m.primary_keys },
                    |m: &mut VertexPrimaryKeyListProto| { &mut m.primary_keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VertexPrimaryKeyListProto>(
                    "VertexPrimaryKeyListProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexPrimaryKeyListProto {
        static mut instance: ::protobuf::lazy::Lazy<VertexPrimaryKeyListProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VertexPrimaryKeyListProto,
        };
        unsafe {
            instance.get(VertexPrimaryKeyListProto::new)
        }
    }
}

impl ::protobuf::Clear for VertexPrimaryKeyListProto {
    fn clear(&mut self) {
        self.clear_primary_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexPrimaryKeyListProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexPrimaryKeyListProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexPrimaryKeyProto {
    // message fields
    pub label_id: i32,
    pub primary_key_value: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VertexPrimaryKeyProto {
    pub fn new() -> VertexPrimaryKeyProto {
        ::std::default::Default::default()
    }

    // int32 label_id = 1;

    pub fn clear_label_id(&mut self) {
        self.label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: i32) {
        self.label_id = v;
    }

    pub fn get_label_id(&self) -> i32 {
        self.label_id
    }

    // string primary_key_value = 2;

    pub fn clear_primary_key_value(&mut self) {
        self.primary_key_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_primary_key_value(&mut self, v: ::std::string::String) {
        self.primary_key_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_key_value(&mut self) -> &mut ::std::string::String {
        &mut self.primary_key_value
    }

    // Take field
    pub fn take_primary_key_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.primary_key_value, ::std::string::String::new())
    }

    pub fn get_primary_key_value(&self) -> &str {
        &self.primary_key_value
    }
}

impl ::protobuf::Message for VertexPrimaryKeyProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.primary_key_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.label_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.primary_key_value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.primary_key_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.label_id != 0 {
            os.write_int32(1, self.label_id)?;
        }
        if !self.primary_key_value.is_empty() {
            os.write_string(2, &self.primary_key_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexPrimaryKeyProto {
        VertexPrimaryKeyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_id",
                    |m: &VertexPrimaryKeyProto| { &m.label_id },
                    |m: &mut VertexPrimaryKeyProto| { &mut m.label_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "primary_key_value",
                    |m: &VertexPrimaryKeyProto| { &m.primary_key_value },
                    |m: &mut VertexPrimaryKeyProto| { &mut m.primary_key_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VertexPrimaryKeyProto>(
                    "VertexPrimaryKeyProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexPrimaryKeyProto {
        static mut instance: ::protobuf::lazy::Lazy<VertexPrimaryKeyProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VertexPrimaryKeyProto,
        };
        unsafe {
            instance.get(VertexPrimaryKeyProto::new)
        }
    }
}

impl ::protobuf::Clear for VertexPrimaryKeyProto {
    fn clear(&mut self) {
        self.clear_label_id();
        self.clear_primary_key_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexPrimaryKeyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexPrimaryKeyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InputBatchLevel {
    Medium = 0,
    Small = 1,
    VerySmall = 2,
    Large = 3,
    VeryLarge = 4,
}

impl ::protobuf::ProtobufEnum for InputBatchLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InputBatchLevel> {
        match value {
            0 => ::std::option::Option::Some(InputBatchLevel::Medium),
            1 => ::std::option::Option::Some(InputBatchLevel::Small),
            2 => ::std::option::Option::Some(InputBatchLevel::VerySmall),
            3 => ::std::option::Option::Some(InputBatchLevel::Large),
            4 => ::std::option::Option::Some(InputBatchLevel::VeryLarge),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InputBatchLevel] = &[
            InputBatchLevel::Medium,
            InputBatchLevel::Small,
            InputBatchLevel::VerySmall,
            InputBatchLevel::Large,
            InputBatchLevel::VeryLarge,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("InputBatchLevel", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for InputBatchLevel {
}

impl ::std::default::Default for InputBatchLevel {
    fn default() -> Self {
        InputBatchLevel::Medium
    }
}

impl ::protobuf::reflect::ProtobufValue for InputBatchLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OperatorType {
    V = 0,
    E = 1,
    OUT = 2,
    IN = 3,
    BOTH = 4,
    OUT_E = 5,
    IN_E = 6,
    BOTH_E = 7,
    OUT_V = 8,
    IN_V = 9,
    BOTH_V = 10,
    SELECT_ONE = 11,
    COUNT_LOCAL = 12,
    JOIN_LABEL = 13,
    ORDER = 14,
    RANGE = 15,
    FIRST_BY_LABEL = 16,
    UNION = 17,
    DEDUP = 18,
    GROUP_COUNT = 19,
    HAS = 20,
    REPEAT_START = 21,
    REPEAT = 22,
    SELECT = 23,
    WHERE = 24,
    PROP_VALUE = 25,
    PROP_KEY_VALUE = 26,
    WHERE_LABEL = 27,
    UNFOLD = 28,
    PATH_OUT = 29,
    FILTER = 30,
    JOIN_COUNT_LABEL = 31,
    SIMPLE_PATH = 32,
    PROP_MAP_VALUE = 33,
    SOURCE_CHAIN = 34,
    UNARY_CHAIN = 35,
    BINARY_CHAIN = 36,
    FOLD = 37,
    RANGE_LOCAL = 38,
    ORDER_LOCAL = 39,
    SACK_OUT = 40,
    COUNT_BY_KEY = 41,
    PROP_FILL = 42,
    DEDUP_COUNT_LABEL = 43,
    DUPLICATE_LABEL = 44,
    COUNT = 45,
    JOIN_DIRECT_FILTER = 46,
    NOT = 47,
    OTHER_V = 48,
    SUM = 49,
    COLUMN = 50,
    CONSTANT = 51,
    FOLD_BY_KEY = 52,
    SUM_BY_KEY = 53,
    MAX = 54,
    MIN = 55,
    MAX_BY_KEY = 56,
    MIN_BY_KEY = 57,
    ENTRY_OUT = 58,
    FOLDMAP = 59,
    PROPERTIES = 60,
    WRITE_ODPS = 61,
    RANGE_BY_KEY = 62,
    DEDUP_BY_KEY = 63,
    V_COUNT = 64,
    E_COUNT = 65,
    OUT_COUNT = 66,
    IN_COUNT = 67,
    BOTH_COUNT = 68,
    COUNT_LIMIT = 69,
    JOIN_DIRECT_FILTER_NEGATE = 70,
    JOIN_DIRECT_FILTER_KEY_NEGATE = 71,
    DFS_SOURCE = 72,
    DFS_REPEAT_GRAPH = 73,
    DFS_FINISH_JOIN = 74,
    SAMPLE = 75,
    GRAPH_SOURCE = 76,
    BRANCH_OPTION = 77,
    JOIN_RATIO = 78,
    JOIN_STORE_FILTER = 79,
    SUBGRAPH = 80,
    SUBGRAPH_SOURCE = 81,
    JOIN_CASE_WHEN = 82,
    CACHE = 83,
    MATH = 84,
    JOIN_RIGHT_ZERO_JOIN = 85,
    ENTER_KEY = 86,
    JOIN_RIGHT_VALUE_KEY = 87,
    BYKEY_ENTRY = 88,
    KEY_MESSAGE = 89,
    RANGE_SUM = 90,
    LABEL_VALUE = 91,
    FOLD_STORE = 92,
    COMBINER_SUM = 93,
    ESTIMATE_COUNT = 94,
    COMBINER_RANGE = 95,
    DFS_REPEAT_CMD = 96,
    DFS_REPEAT_DATA = 97,
    BARRIER = 98,
    LAMBDA_FILTER = 1000,
    LAMBDA_MAP = 1001,
    LAMBDA_FLATMAP = 1002,
    GRAPH_VINEYARD_BUILDER = 2000,
    GRAPH_VINEYARD_STREAM = 2001,
    OUTPUT_VINEYARD_VERTEX = 2002,
    OUTPUT_VINEYARD_EDGE = 2003,
    PROGRAM_CC = 10000,
    PROGRAM_GRAPH_CC = 10001,
    PROGRAM_GRAPH_LPA = 10002,
    PROGRAM_GRAPH_PAGERANK = 10003,
    PROGRAM_GRAPH_HITS = 10004,
    PROGRAM_GRAPH_ALLPATH = 10005,
    PROGRAM_GRAPH_SHORTESTPATH = 10006,
    PROGRAM_GRAPH_PEERPRESSURE = 10007,
}

impl ::protobuf::ProtobufEnum for OperatorType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OperatorType> {
        match value {
            0 => ::std::option::Option::Some(OperatorType::V),
            1 => ::std::option::Option::Some(OperatorType::E),
            2 => ::std::option::Option::Some(OperatorType::OUT),
            3 => ::std::option::Option::Some(OperatorType::IN),
            4 => ::std::option::Option::Some(OperatorType::BOTH),
            5 => ::std::option::Option::Some(OperatorType::OUT_E),
            6 => ::std::option::Option::Some(OperatorType::IN_E),
            7 => ::std::option::Option::Some(OperatorType::BOTH_E),
            8 => ::std::option::Option::Some(OperatorType::OUT_V),
            9 => ::std::option::Option::Some(OperatorType::IN_V),
            10 => ::std::option::Option::Some(OperatorType::BOTH_V),
            11 => ::std::option::Option::Some(OperatorType::SELECT_ONE),
            12 => ::std::option::Option::Some(OperatorType::COUNT_LOCAL),
            13 => ::std::option::Option::Some(OperatorType::JOIN_LABEL),
            14 => ::std::option::Option::Some(OperatorType::ORDER),
            15 => ::std::option::Option::Some(OperatorType::RANGE),
            16 => ::std::option::Option::Some(OperatorType::FIRST_BY_LABEL),
            17 => ::std::option::Option::Some(OperatorType::UNION),
            18 => ::std::option::Option::Some(OperatorType::DEDUP),
            19 => ::std::option::Option::Some(OperatorType::GROUP_COUNT),
            20 => ::std::option::Option::Some(OperatorType::HAS),
            21 => ::std::option::Option::Some(OperatorType::REPEAT_START),
            22 => ::std::option::Option::Some(OperatorType::REPEAT),
            23 => ::std::option::Option::Some(OperatorType::SELECT),
            24 => ::std::option::Option::Some(OperatorType::WHERE),
            25 => ::std::option::Option::Some(OperatorType::PROP_VALUE),
            26 => ::std::option::Option::Some(OperatorType::PROP_KEY_VALUE),
            27 => ::std::option::Option::Some(OperatorType::WHERE_LABEL),
            28 => ::std::option::Option::Some(OperatorType::UNFOLD),
            29 => ::std::option::Option::Some(OperatorType::PATH_OUT),
            30 => ::std::option::Option::Some(OperatorType::FILTER),
            31 => ::std::option::Option::Some(OperatorType::JOIN_COUNT_LABEL),
            32 => ::std::option::Option::Some(OperatorType::SIMPLE_PATH),
            33 => ::std::option::Option::Some(OperatorType::PROP_MAP_VALUE),
            34 => ::std::option::Option::Some(OperatorType::SOURCE_CHAIN),
            35 => ::std::option::Option::Some(OperatorType::UNARY_CHAIN),
            36 => ::std::option::Option::Some(OperatorType::BINARY_CHAIN),
            37 => ::std::option::Option::Some(OperatorType::FOLD),
            38 => ::std::option::Option::Some(OperatorType::RANGE_LOCAL),
            39 => ::std::option::Option::Some(OperatorType::ORDER_LOCAL),
            40 => ::std::option::Option::Some(OperatorType::SACK_OUT),
            41 => ::std::option::Option::Some(OperatorType::COUNT_BY_KEY),
            42 => ::std::option::Option::Some(OperatorType::PROP_FILL),
            43 => ::std::option::Option::Some(OperatorType::DEDUP_COUNT_LABEL),
            44 => ::std::option::Option::Some(OperatorType::DUPLICATE_LABEL),
            45 => ::std::option::Option::Some(OperatorType::COUNT),
            46 => ::std::option::Option::Some(OperatorType::JOIN_DIRECT_FILTER),
            47 => ::std::option::Option::Some(OperatorType::NOT),
            48 => ::std::option::Option::Some(OperatorType::OTHER_V),
            49 => ::std::option::Option::Some(OperatorType::SUM),
            50 => ::std::option::Option::Some(OperatorType::COLUMN),
            51 => ::std::option::Option::Some(OperatorType::CONSTANT),
            52 => ::std::option::Option::Some(OperatorType::FOLD_BY_KEY),
            53 => ::std::option::Option::Some(OperatorType::SUM_BY_KEY),
            54 => ::std::option::Option::Some(OperatorType::MAX),
            55 => ::std::option::Option::Some(OperatorType::MIN),
            56 => ::std::option::Option::Some(OperatorType::MAX_BY_KEY),
            57 => ::std::option::Option::Some(OperatorType::MIN_BY_KEY),
            58 => ::std::option::Option::Some(OperatorType::ENTRY_OUT),
            59 => ::std::option::Option::Some(OperatorType::FOLDMAP),
            60 => ::std::option::Option::Some(OperatorType::PROPERTIES),
            61 => ::std::option::Option::Some(OperatorType::WRITE_ODPS),
            62 => ::std::option::Option::Some(OperatorType::RANGE_BY_KEY),
            63 => ::std::option::Option::Some(OperatorType::DEDUP_BY_KEY),
            64 => ::std::option::Option::Some(OperatorType::V_COUNT),
            65 => ::std::option::Option::Some(OperatorType::E_COUNT),
            66 => ::std::option::Option::Some(OperatorType::OUT_COUNT),
            67 => ::std::option::Option::Some(OperatorType::IN_COUNT),
            68 => ::std::option::Option::Some(OperatorType::BOTH_COUNT),
            69 => ::std::option::Option::Some(OperatorType::COUNT_LIMIT),
            70 => ::std::option::Option::Some(OperatorType::JOIN_DIRECT_FILTER_NEGATE),
            71 => ::std::option::Option::Some(OperatorType::JOIN_DIRECT_FILTER_KEY_NEGATE),
            72 => ::std::option::Option::Some(OperatorType::DFS_SOURCE),
            73 => ::std::option::Option::Some(OperatorType::DFS_REPEAT_GRAPH),
            74 => ::std::option::Option::Some(OperatorType::DFS_FINISH_JOIN),
            75 => ::std::option::Option::Some(OperatorType::SAMPLE),
            76 => ::std::option::Option::Some(OperatorType::GRAPH_SOURCE),
            77 => ::std::option::Option::Some(OperatorType::BRANCH_OPTION),
            78 => ::std::option::Option::Some(OperatorType::JOIN_RATIO),
            79 => ::std::option::Option::Some(OperatorType::JOIN_STORE_FILTER),
            80 => ::std::option::Option::Some(OperatorType::SUBGRAPH),
            81 => ::std::option::Option::Some(OperatorType::SUBGRAPH_SOURCE),
            82 => ::std::option::Option::Some(OperatorType::JOIN_CASE_WHEN),
            83 => ::std::option::Option::Some(OperatorType::CACHE),
            84 => ::std::option::Option::Some(OperatorType::MATH),
            85 => ::std::option::Option::Some(OperatorType::JOIN_RIGHT_ZERO_JOIN),
            86 => ::std::option::Option::Some(OperatorType::ENTER_KEY),
            87 => ::std::option::Option::Some(OperatorType::JOIN_RIGHT_VALUE_KEY),
            88 => ::std::option::Option::Some(OperatorType::BYKEY_ENTRY),
            89 => ::std::option::Option::Some(OperatorType::KEY_MESSAGE),
            90 => ::std::option::Option::Some(OperatorType::RANGE_SUM),
            91 => ::std::option::Option::Some(OperatorType::LABEL_VALUE),
            92 => ::std::option::Option::Some(OperatorType::FOLD_STORE),
            93 => ::std::option::Option::Some(OperatorType::COMBINER_SUM),
            94 => ::std::option::Option::Some(OperatorType::ESTIMATE_COUNT),
            95 => ::std::option::Option::Some(OperatorType::COMBINER_RANGE),
            96 => ::std::option::Option::Some(OperatorType::DFS_REPEAT_CMD),
            97 => ::std::option::Option::Some(OperatorType::DFS_REPEAT_DATA),
            98 => ::std::option::Option::Some(OperatorType::BARRIER),
            1000 => ::std::option::Option::Some(OperatorType::LAMBDA_FILTER),
            1001 => ::std::option::Option::Some(OperatorType::LAMBDA_MAP),
            1002 => ::std::option::Option::Some(OperatorType::LAMBDA_FLATMAP),
            2000 => ::std::option::Option::Some(OperatorType::GRAPH_VINEYARD_BUILDER),
            2001 => ::std::option::Option::Some(OperatorType::GRAPH_VINEYARD_STREAM),
            2002 => ::std::option::Option::Some(OperatorType::OUTPUT_VINEYARD_VERTEX),
            2003 => ::std::option::Option::Some(OperatorType::OUTPUT_VINEYARD_EDGE),
            10000 => ::std::option::Option::Some(OperatorType::PROGRAM_CC),
            10001 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_CC),
            10002 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_LPA),
            10003 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_PAGERANK),
            10004 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_HITS),
            10005 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_ALLPATH),
            10006 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_SHORTESTPATH),
            10007 => ::std::option::Option::Some(OperatorType::PROGRAM_GRAPH_PEERPRESSURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OperatorType] = &[
            OperatorType::V,
            OperatorType::E,
            OperatorType::OUT,
            OperatorType::IN,
            OperatorType::BOTH,
            OperatorType::OUT_E,
            OperatorType::IN_E,
            OperatorType::BOTH_E,
            OperatorType::OUT_V,
            OperatorType::IN_V,
            OperatorType::BOTH_V,
            OperatorType::SELECT_ONE,
            OperatorType::COUNT_LOCAL,
            OperatorType::JOIN_LABEL,
            OperatorType::ORDER,
            OperatorType::RANGE,
            OperatorType::FIRST_BY_LABEL,
            OperatorType::UNION,
            OperatorType::DEDUP,
            OperatorType::GROUP_COUNT,
            OperatorType::HAS,
            OperatorType::REPEAT_START,
            OperatorType::REPEAT,
            OperatorType::SELECT,
            OperatorType::WHERE,
            OperatorType::PROP_VALUE,
            OperatorType::PROP_KEY_VALUE,
            OperatorType::WHERE_LABEL,
            OperatorType::UNFOLD,
            OperatorType::PATH_OUT,
            OperatorType::FILTER,
            OperatorType::JOIN_COUNT_LABEL,
            OperatorType::SIMPLE_PATH,
            OperatorType::PROP_MAP_VALUE,
            OperatorType::SOURCE_CHAIN,
            OperatorType::UNARY_CHAIN,
            OperatorType::BINARY_CHAIN,
            OperatorType::FOLD,
            OperatorType::RANGE_LOCAL,
            OperatorType::ORDER_LOCAL,
            OperatorType::SACK_OUT,
            OperatorType::COUNT_BY_KEY,
            OperatorType::PROP_FILL,
            OperatorType::DEDUP_COUNT_LABEL,
            OperatorType::DUPLICATE_LABEL,
            OperatorType::COUNT,
            OperatorType::JOIN_DIRECT_FILTER,
            OperatorType::NOT,
            OperatorType::OTHER_V,
            OperatorType::SUM,
            OperatorType::COLUMN,
            OperatorType::CONSTANT,
            OperatorType::FOLD_BY_KEY,
            OperatorType::SUM_BY_KEY,
            OperatorType::MAX,
            OperatorType::MIN,
            OperatorType::MAX_BY_KEY,
            OperatorType::MIN_BY_KEY,
            OperatorType::ENTRY_OUT,
            OperatorType::FOLDMAP,
            OperatorType::PROPERTIES,
            OperatorType::WRITE_ODPS,
            OperatorType::RANGE_BY_KEY,
            OperatorType::DEDUP_BY_KEY,
            OperatorType::V_COUNT,
            OperatorType::E_COUNT,
            OperatorType::OUT_COUNT,
            OperatorType::IN_COUNT,
            OperatorType::BOTH_COUNT,
            OperatorType::COUNT_LIMIT,
            OperatorType::JOIN_DIRECT_FILTER_NEGATE,
            OperatorType::JOIN_DIRECT_FILTER_KEY_NEGATE,
            OperatorType::DFS_SOURCE,
            OperatorType::DFS_REPEAT_GRAPH,
            OperatorType::DFS_FINISH_JOIN,
            OperatorType::SAMPLE,
            OperatorType::GRAPH_SOURCE,
            OperatorType::BRANCH_OPTION,
            OperatorType::JOIN_RATIO,
            OperatorType::JOIN_STORE_FILTER,
            OperatorType::SUBGRAPH,
            OperatorType::SUBGRAPH_SOURCE,
            OperatorType::JOIN_CASE_WHEN,
            OperatorType::CACHE,
            OperatorType::MATH,
            OperatorType::JOIN_RIGHT_ZERO_JOIN,
            OperatorType::ENTER_KEY,
            OperatorType::JOIN_RIGHT_VALUE_KEY,
            OperatorType::BYKEY_ENTRY,
            OperatorType::KEY_MESSAGE,
            OperatorType::RANGE_SUM,
            OperatorType::LABEL_VALUE,
            OperatorType::FOLD_STORE,
            OperatorType::COMBINER_SUM,
            OperatorType::ESTIMATE_COUNT,
            OperatorType::COMBINER_RANGE,
            OperatorType::DFS_REPEAT_CMD,
            OperatorType::DFS_REPEAT_DATA,
            OperatorType::BARRIER,
            OperatorType::LAMBDA_FILTER,
            OperatorType::LAMBDA_MAP,
            OperatorType::LAMBDA_FLATMAP,
            OperatorType::GRAPH_VINEYARD_BUILDER,
            OperatorType::GRAPH_VINEYARD_STREAM,
            OperatorType::OUTPUT_VINEYARD_VERTEX,
            OperatorType::OUTPUT_VINEYARD_EDGE,
            OperatorType::PROGRAM_CC,
            OperatorType::PROGRAM_GRAPH_CC,
            OperatorType::PROGRAM_GRAPH_LPA,
            OperatorType::PROGRAM_GRAPH_PAGERANK,
            OperatorType::PROGRAM_GRAPH_HITS,
            OperatorType::PROGRAM_GRAPH_ALLPATH,
            OperatorType::PROGRAM_GRAPH_SHORTESTPATH,
            OperatorType::PROGRAM_GRAPH_PEERPRESSURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OperatorType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OperatorType {
}

impl ::std::default::Default for OperatorType {
    fn default() -> Self {
        OperatorType::V
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RequirementType {
    LABEL_START = 0,
    LABEL_DEL = 1,
    PATH_START = 2,
    PATH_ADD = 3,
    KEY_DEL = 4,
}

impl ::protobuf::ProtobufEnum for RequirementType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequirementType> {
        match value {
            0 => ::std::option::Option::Some(RequirementType::LABEL_START),
            1 => ::std::option::Option::Some(RequirementType::LABEL_DEL),
            2 => ::std::option::Option::Some(RequirementType::PATH_START),
            3 => ::std::option::Option::Some(RequirementType::PATH_ADD),
            4 => ::std::option::Option::Some(RequirementType::KEY_DEL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequirementType] = &[
            RequirementType::LABEL_START,
            RequirementType::LABEL_DEL,
            RequirementType::PATH_START,
            RequirementType::PATH_ADD,
            RequirementType::KEY_DEL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("RequirementType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for RequirementType {
}

impl ::std::default::Default for RequirementType {
    fn default() -> Self {
        RequirementType::LABEL_START
    }
}

impl ::protobuf::reflect::ProtobufValue for RequirementType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ColumnType {
    COLUMN_KEYS = 0,
    COLUMN_VALUES = 1,
}

impl ::protobuf::ProtobufEnum for ColumnType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColumnType> {
        match value {
            0 => ::std::option::Option::Some(ColumnType::COLUMN_KEYS),
            1 => ::std::option::Option::Some(ColumnType::COLUMN_VALUES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ColumnType] = &[
            ColumnType::COLUMN_KEYS,
            ColumnType::COLUMN_VALUES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ColumnType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ColumnType {
}

impl ::std::default::Default for ColumnType {
    fn default() -> Self {
        ColumnType::COLUMN_KEYS
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SourceType {
    GRAPH = 0,
    ODPS = 1,
}

impl ::protobuf::ProtobufEnum for SourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SourceType> {
        match value {
            0 => ::std::option::Option::Some(SourceType::GRAPH),
            1 => ::std::option::Option::Some(SourceType::ODPS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SourceType] = &[
            SourceType::GRAPH,
            SourceType::ODPS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("SourceType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for SourceType {
}

impl ::std::default::Default for SourceType {
    fn default() -> Self {
        SourceType::GRAPH
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LoopType {
    LOOP_ENTER = 0,
    LOOP_LEAVE = 1,
    LOOP_FEEDBACK = 2,
    LOOP_LEAVE_LAST = 3,
}

impl ::protobuf::ProtobufEnum for LoopType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LoopType> {
        match value {
            0 => ::std::option::Option::Some(LoopType::LOOP_ENTER),
            1 => ::std::option::Option::Some(LoopType::LOOP_LEAVE),
            2 => ::std::option::Option::Some(LoopType::LOOP_FEEDBACK),
            3 => ::std::option::Option::Some(LoopType::LOOP_LEAVE_LAST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LoopType] = &[
            LoopType::LOOP_ENTER,
            LoopType::LOOP_LEAVE,
            LoopType::LOOP_FEEDBACK,
            LoopType::LOOP_LEAVE_LAST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LoopType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LoopType {
}

impl ::std::default::Default for LoopType {
    fn default() -> Self {
        LoopType::LOOP_ENTER
    }
}

impl ::protobuf::reflect::ProtobufValue for LoopType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum InputShuffleType {
    FORWARD_TYPE = 0,
    SHUFFLE_BY_KEY_TYPE = 1,
    SHUFFLE_BY_ID_TYPE = 2,
    SHUFFLE_BY_CONST_TYPE = 3,
    BROADCAST_TYPE = 4,
}

impl ::protobuf::ProtobufEnum for InputShuffleType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<InputShuffleType> {
        match value {
            0 => ::std::option::Option::Some(InputShuffleType::FORWARD_TYPE),
            1 => ::std::option::Option::Some(InputShuffleType::SHUFFLE_BY_KEY_TYPE),
            2 => ::std::option::Option::Some(InputShuffleType::SHUFFLE_BY_ID_TYPE),
            3 => ::std::option::Option::Some(InputShuffleType::SHUFFLE_BY_CONST_TYPE),
            4 => ::std::option::Option::Some(InputShuffleType::BROADCAST_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [InputShuffleType] = &[
            InputShuffleType::FORWARD_TYPE,
            InputShuffleType::SHUFFLE_BY_KEY_TYPE,
            InputShuffleType::SHUFFLE_BY_ID_TYPE,
            InputShuffleType::SHUFFLE_BY_CONST_TYPE,
            InputShuffleType::BROADCAST_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("InputShuffleType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for InputShuffleType {
}

impl ::std::default::Default for InputShuffleType {
    fn default() -> Self {
        InputShuffleType::FORWARD_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for InputShuffleType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AssignHint {
    VERTEX_HASH = 0,
    EDGE_HASH = 1,
    ARBITRARILY = 2,
}

impl ::protobuf::ProtobufEnum for AssignHint {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AssignHint> {
        match value {
            0 => ::std::option::Option::Some(AssignHint::VERTEX_HASH),
            1 => ::std::option::Option::Some(AssignHint::EDGE_HASH),
            2 => ::std::option::Option::Some(AssignHint::ARBITRARILY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AssignHint] = &[
            AssignHint::VERTEX_HASH,
            AssignHint::EDGE_HASH,
            AssignHint::ARBITRARILY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("AssignHint", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for AssignHint {
}

impl ::std::default::Default for AssignHint {
    fn default() -> Self {
        AssignHint::VERTEX_HASH
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignHint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DistributionPattern {
    ALL_TO_ALL = 0,
    POINT_WISE_VERTEX = 1,
    POINT_WISE_EDGE = 2,
    BROADCAST = 3,
}

impl ::protobuf::ProtobufEnum for DistributionPattern {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DistributionPattern> {
        match value {
            0 => ::std::option::Option::Some(DistributionPattern::ALL_TO_ALL),
            1 => ::std::option::Option::Some(DistributionPattern::POINT_WISE_VERTEX),
            2 => ::std::option::Option::Some(DistributionPattern::POINT_WISE_EDGE),
            3 => ::std::option::Option::Some(DistributionPattern::BROADCAST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DistributionPattern] = &[
            DistributionPattern::ALL_TO_ALL,
            DistributionPattern::POINT_WISE_VERTEX,
            DistributionPattern::POINT_WISE_EDGE,
            DistributionPattern::BROADCAST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DistributionPattern", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DistributionPattern {
}

impl ::std::default::Default for DistributionPattern {
    fn default() -> Self {
        DistributionPattern::ALL_TO_ALL
    }
}

impl ::protobuf::reflect::ProtobufValue for DistributionPattern {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MathTokenType {
    TOKEN_ERROR = 0,
    TOKEN_NUMBER = 1,
    TOKEN_OPERATOR = 2,
    TOKEN_FUNCTION = 3,
    TOKEN_PARENTHESES_OPEN = 4,
    TOKEN_PARENTHESES_CLOSE = 5,
    TOKEN_VARIABLE = 6,
    TOKEN_SEPARATOR = 7,
}

impl ::protobuf::ProtobufEnum for MathTokenType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MathTokenType> {
        match value {
            0 => ::std::option::Option::Some(MathTokenType::TOKEN_ERROR),
            1 => ::std::option::Option::Some(MathTokenType::TOKEN_NUMBER),
            2 => ::std::option::Option::Some(MathTokenType::TOKEN_OPERATOR),
            3 => ::std::option::Option::Some(MathTokenType::TOKEN_FUNCTION),
            4 => ::std::option::Option::Some(MathTokenType::TOKEN_PARENTHESES_OPEN),
            5 => ::std::option::Option::Some(MathTokenType::TOKEN_PARENTHESES_CLOSE),
            6 => ::std::option::Option::Some(MathTokenType::TOKEN_VARIABLE),
            7 => ::std::option::Option::Some(MathTokenType::TOKEN_SEPARATOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MathTokenType] = &[
            MathTokenType::TOKEN_ERROR,
            MathTokenType::TOKEN_NUMBER,
            MathTokenType::TOKEN_OPERATOR,
            MathTokenType::TOKEN_FUNCTION,
            MathTokenType::TOKEN_PARENTHESES_OPEN,
            MathTokenType::TOKEN_PARENTHESES_CLOSE,
            MathTokenType::TOKEN_VARIABLE,
            MathTokenType::TOKEN_SEPARATOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MathTokenType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MathTokenType {
}

impl ::std::default::Default for MathTokenType {
    fn default() -> Self {
        MathTokenType::TOKEN_ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for MathTokenType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MathFunctionType {
    FUNC_SIN = 0,
    FUNC_COS = 1,
    FUNC_TAN = 2,
    FUNC_COT = 3,
    FUNC_LOG = 4,
    FUNC_LOG1P = 5,
    FUNC_ABS = 6,
    FUNC_ACOS = 7,
    FUNC_ASIN = 8,
    FUNC_ATAN = 9,
    FUNC_CBRT = 10,
    FUNC_CEIL = 11,
    FUNC_FLOOR = 12,
    FUNC_SINH = 13,
    FUNC_SQRT = 14,
    FUNC_TANH = 15,
    FUNC_COSH = 16,
    FUNC_POW = 17,
    FUNC_EXP = 18,
    FUNC_EXPM1 = 19,
    FUNC_LOG10 = 20,
    FUNC_LOG2 = 21,
    FUNC_SIGNUM = 22,
}

impl ::protobuf::ProtobufEnum for MathFunctionType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MathFunctionType> {
        match value {
            0 => ::std::option::Option::Some(MathFunctionType::FUNC_SIN),
            1 => ::std::option::Option::Some(MathFunctionType::FUNC_COS),
            2 => ::std::option::Option::Some(MathFunctionType::FUNC_TAN),
            3 => ::std::option::Option::Some(MathFunctionType::FUNC_COT),
            4 => ::std::option::Option::Some(MathFunctionType::FUNC_LOG),
            5 => ::std::option::Option::Some(MathFunctionType::FUNC_LOG1P),
            6 => ::std::option::Option::Some(MathFunctionType::FUNC_ABS),
            7 => ::std::option::Option::Some(MathFunctionType::FUNC_ACOS),
            8 => ::std::option::Option::Some(MathFunctionType::FUNC_ASIN),
            9 => ::std::option::Option::Some(MathFunctionType::FUNC_ATAN),
            10 => ::std::option::Option::Some(MathFunctionType::FUNC_CBRT),
            11 => ::std::option::Option::Some(MathFunctionType::FUNC_CEIL),
            12 => ::std::option::Option::Some(MathFunctionType::FUNC_FLOOR),
            13 => ::std::option::Option::Some(MathFunctionType::FUNC_SINH),
            14 => ::std::option::Option::Some(MathFunctionType::FUNC_SQRT),
            15 => ::std::option::Option::Some(MathFunctionType::FUNC_TANH),
            16 => ::std::option::Option::Some(MathFunctionType::FUNC_COSH),
            17 => ::std::option::Option::Some(MathFunctionType::FUNC_POW),
            18 => ::std::option::Option::Some(MathFunctionType::FUNC_EXP),
            19 => ::std::option::Option::Some(MathFunctionType::FUNC_EXPM1),
            20 => ::std::option::Option::Some(MathFunctionType::FUNC_LOG10),
            21 => ::std::option::Option::Some(MathFunctionType::FUNC_LOG2),
            22 => ::std::option::Option::Some(MathFunctionType::FUNC_SIGNUM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MathFunctionType] = &[
            MathFunctionType::FUNC_SIN,
            MathFunctionType::FUNC_COS,
            MathFunctionType::FUNC_TAN,
            MathFunctionType::FUNC_COT,
            MathFunctionType::FUNC_LOG,
            MathFunctionType::FUNC_LOG1P,
            MathFunctionType::FUNC_ABS,
            MathFunctionType::FUNC_ACOS,
            MathFunctionType::FUNC_ASIN,
            MathFunctionType::FUNC_ATAN,
            MathFunctionType::FUNC_CBRT,
            MathFunctionType::FUNC_CEIL,
            MathFunctionType::FUNC_FLOOR,
            MathFunctionType::FUNC_SINH,
            MathFunctionType::FUNC_SQRT,
            MathFunctionType::FUNC_TANH,
            MathFunctionType::FUNC_COSH,
            MathFunctionType::FUNC_POW,
            MathFunctionType::FUNC_EXP,
            MathFunctionType::FUNC_EXPM1,
            MathFunctionType::FUNC_LOG10,
            MathFunctionType::FUNC_LOG2,
            MathFunctionType::FUNC_SIGNUM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MathFunctionType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MathFunctionType {
}

impl ::std::default::Default for MathFunctionType {
    fn default() -> Self {
        MathFunctionType::FUNC_SIN
    }
}

impl ::protobuf::reflect::ProtobufValue for MathFunctionType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MathOperatorTokenType {
    OP_ADDITION = 0,
    OP_SUBTRACTION = 1,
    OP_MUTLIPLICATION = 2,
    OP_DIVISION = 3,
    OP_POWER = 4,
    OP_MODULO = 5,
    OP_UNARYMINUS = 6,
    OP_UNARYPLUS = 7,
}

impl ::protobuf::ProtobufEnum for MathOperatorTokenType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MathOperatorTokenType> {
        match value {
            0 => ::std::option::Option::Some(MathOperatorTokenType::OP_ADDITION),
            1 => ::std::option::Option::Some(MathOperatorTokenType::OP_SUBTRACTION),
            2 => ::std::option::Option::Some(MathOperatorTokenType::OP_MUTLIPLICATION),
            3 => ::std::option::Option::Some(MathOperatorTokenType::OP_DIVISION),
            4 => ::std::option::Option::Some(MathOperatorTokenType::OP_POWER),
            5 => ::std::option::Option::Some(MathOperatorTokenType::OP_MODULO),
            6 => ::std::option::Option::Some(MathOperatorTokenType::OP_UNARYMINUS),
            7 => ::std::option::Option::Some(MathOperatorTokenType::OP_UNARYPLUS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MathOperatorTokenType] = &[
            MathOperatorTokenType::OP_ADDITION,
            MathOperatorTokenType::OP_SUBTRACTION,
            MathOperatorTokenType::OP_MUTLIPLICATION,
            MathOperatorTokenType::OP_DIVISION,
            MathOperatorTokenType::OP_POWER,
            MathOperatorTokenType::OP_MODULO,
            MathOperatorTokenType::OP_UNARYMINUS,
            MathOperatorTokenType::OP_UNARYPLUS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MathOperatorTokenType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MathOperatorTokenType {
}

impl ::std::default::Default for MathOperatorTokenType {
    fn default() -> Self {
        MathOperatorTokenType::OP_ADDITION
    }
}

impl ::protobuf::reflect::ProtobufValue for MathOperatorTokenType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EnterKeyTypeProto {
    KEY_SELF = 0,
    KEY_PROP_LABEL = 1,
    KEY_PROP_VAL_MAP = 2,
}

impl ::protobuf::ProtobufEnum for EnterKeyTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EnterKeyTypeProto> {
        match value {
            0 => ::std::option::Option::Some(EnterKeyTypeProto::KEY_SELF),
            1 => ::std::option::Option::Some(EnterKeyTypeProto::KEY_PROP_LABEL),
            2 => ::std::option::Option::Some(EnterKeyTypeProto::KEY_PROP_VAL_MAP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EnterKeyTypeProto] = &[
            EnterKeyTypeProto::KEY_SELF,
            EnterKeyTypeProto::KEY_PROP_LABEL,
            EnterKeyTypeProto::KEY_PROP_VAL_MAP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EnterKeyTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EnterKeyTypeProto {
}

impl ::std::default::Default for EnterKeyTypeProto {
    fn default() -> Self {
        EnterKeyTypeProto::KEY_SELF
    }
}

impl ::protobuf::reflect::ProtobufValue for EnterKeyTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateGraphTypeProto {
    VINEYARD = 0,
}

impl ::protobuf::ProtobufEnum for CreateGraphTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateGraphTypeProto> {
        match value {
            0 => ::std::option::Option::Some(CreateGraphTypeProto::VINEYARD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateGraphTypeProto] = &[
            CreateGraphTypeProto::VINEYARD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CreateGraphTypeProto", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CreateGraphTypeProto {
}

impl ::std::default::Default for CreateGraphTypeProto {
    fn default() -> Self {
        CreateGraphTypeProto::VINEYARD
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateGraphTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10query_flow.proto\x12\x08maxgraph\x1a\x11sdk/message.proto\"\xa6\
    \x07\n\tQueryFlow\x12\x19\n\x08query_id\x18\x01\x20\x01(\tR\x07queryId\
    \x122\n\nquery_plan\x18\x02\x20\x01(\x0b2\x13.maxgraph.QueryPlanR\tquery\
    Plan\x12/\n\x07sink_op\x18\x03\x20\x01(\x0b2\x16.maxgraph.SinkOperatorR\
    \x06sinkOp\x127\n\x06config\x18\x04\x20\x03(\x0b2\x1f.maxgraph.QueryFlow\
    .ConfigEntryR\x06config\x12\x1d\n\ngraph_name\x18\x05\x20\x01(\tR\tgraph\
    Name\x12\x20\n\x0bparallelism\x18\x06\x20\x01(\x05R\x0bparallelism\x12\
    \x17\n\x07host_ip\x18\x07\x20\x03(\tR\x06hostIp\x12\x1a\n\x08snapshot\
    \x18\x08\x20\x01(\x03R\x08snapshot\x12\x16\n\x06script\x18\t\x20\x01(\tR\
    \x06script\x12\x1d\n\ntimeout_ms\x18\n\x20\x01(\x04R\ttimeoutMs\x12-\n\
    \x13global_stop_op_list\x18\x0b\x20\x03(\x05R\x10globalStopOpList\x12R\n\
    \x11scop_stop_op_list\x18\x0c\x20\x03(\x0b2'.maxgraph.QueryFlow.ScopStop\
    OpListEntryR\x0escopStopOpList\x12E\n\x11input_batch_level\x18\r\x20\x01\
    (\x0e2\x19.maxgraph.InputBatchLevelR\x0finputBatchLevel\x12$\n\x0edebug_\
    log_flag\x18\x0e\x20\x01(\x08R\x0cdebugLogFlag\x12,\n\x12start_timestamp\
    _ms\x18\x0f\x20\x01(\x04R\x10startTimestampMs\x12\x19\n\x08front_id\x18\
    \x10\x20\x01(\rR\x07frontId\x12&\n\x0fexec_local_flag\x18\x11\x20\x01(\
    \x08R\rexecLocalFlag\x12%\n\x0elambda_existed\x18\x12\x20\x01(\x08R\rlam\
    bdaExisted\x12\x1a\n\x08bytecode\x18\x14\x20\x01(\x0cR\x08bytecode\x1a9\
    \n\x0bConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aT\n\x13ScopStopOpLis\
    tEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12'\n\x05value\x18\
    \x02\x20\x01(\x0b2\x11.maxgraph.ListIntR\x05value:\x028\x01\"\xd7\x01\n\
    \tQueryPlan\x125\n\tsource_op\x18\x01\x20\x01(\x0b2\x18.maxgraph.SourceO\
    peratorR\x08sourceOp\x122\n\x08unary_op\x18\x02\x20\x03(\x0b2\x17.maxgra\
    ph.UnaryOperatorR\x07unaryOp\x125\n\tbinary_op\x18\x03\x20\x03(\x0b2\x18\
    .maxgraph.BinaryOperatorR\x08binaryOp\x12(\n\x10operator_id_list\x18\x04\
    \x20\x03(\x05R\x0eoperatorIdList\"|\n\x10RequirementValue\x124\n\x08req_\
    type\x18\x01\x20\x01(\x0e2\x19.maxgraph.RequirementTypeR\x07reqType\x122\
    \n\x0creq_argument\x18\x02\x20\x01(\x0b2\x0f.maxgraph.ValueR\x0breqArgum\
    ent\"J\n\nRangeLimit\x12\x1f\n\x0brange_start\x18\x01\x20\x01(\x03R\nran\
    geStart\x12\x1b\n\trange_end\x18\x02\x20\x01(\x03R\x08rangeEnd\"\x82\x06\
    \n\x0cOperatorBase\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12;\n\ro\
    perator_type\x18\x02\x20\x01(\x0e2\x16.maxgraph.OperatorTypeR\x0coperato\
    rType\x12+\n\x08argument\x18\x03\x20\x01(\x0b2\x0f.maxgraph.ValueR\x08ar\
    gument\x125\n\x0bassign_hint\x18\x04\x20\x01(\x0e2\x14.maxgraph.AssignHi\
    ntR\nassignHint\x12/\n\tloop_type\x18\x05\x20\x03(\x0e2\x12.maxgraph.Loo\
    pTypeR\x08loopType\x12\x1d\n\nloop_limit\x18\x06\x20\x01(\x05R\tloopLimi\
    t\x12A\n\x0flogical_compare\x18\x07\x20\x03(\x0b2\x18.maxgraph.LogicalCo\
    mpareR\x0elogicalCompare\x12A\n\x10chained_function\x18\x08\x20\x03(\x0b\
    2\x16.maxgraph.OperatorBaseR\x0fchainedFunction\x125\n\x0brange_limit\
    \x18\t\x20\x01(\x0b2\x14.maxgraph.RangeLimitR\nrangeLimit\x12I\n\x12befo\
    re_requirement\x18\n\x20\x03(\x0b2\x1a.maxgraph.RequirementValueR\x11bef\
    oreRequirement\x12G\n\x11after_requirement\x18\x0b\x20\x03(\x0b2\x1a.max\
    graph.RequirementValueR\x10afterRequirement\x12K\n\x13early_stop_argumen\
    t\x18\x0c\x20\x01(\x0b2\x1b.maxgraph.EarlyStopArgumentR\x11earlyStopArgu\
    ment\x12(\n\x10early_scope_list\x18\r\x20\x03(\x05R\x0eearlyScopeList\
    \x12)\n\x10argument_payload\x18\x0e\x20\x01(\x0cR\x0fargumentPayload\"k\
    \n\x11EarlyStopArgument\x12(\n\x10global_stop_flag\x18\x01\x20\x01(\x08R\
    \x0eglobalStopFlag\x12,\n\x12global_filter_flag\x18\x02\x20\x01(\x08R\
    \x10globalFilterFlag\"\xfa\x01\n\x0eSourceOperator\x12*\n\x04base\x18\
    \x01\x20\x01(\x0b2\x16.maxgraph.OperatorBaseR\x04base\x12L\n\x12distribu\
    te_pattern\x18\x02\x20\x01(\x0e2\x1d.maxgraph.DistributionPatternR\x11di\
    stributePattern\x127\n\nodps_input\x18\x03\x20\x01(\x0b2\x18.maxgraph.Od\
    psQueryInputR\todpsInput\x125\n\x0bsource_type\x18\x04\x20\x01(\x0e2\x14\
    .maxgraph.SourceTypeR\nsourceType\"v\n\x10InputEdgeShuffle\x12=\n\x0cshu\
    ffle_type\x18\x01\x20\x01(\x0e2\x1a.maxgraph.InputShuffleTypeR\x0bshuffl\
    eType\x12#\n\rshuffle_value\x18\x02\x20\x01(\x05R\x0cshuffleValue\"\xe3\
    \x02\n\rUnaryOperator\x12*\n\x04base\x18\x01\x20\x01(\x0b2\x16.maxgraph.\
    OperatorBaseR\x04base\x12*\n\x11input_operator_id\x18\x02\x20\x01(\x05R\
    \x0finputOperatorId\x12L\n\x12distribute_pattern\x18\x03\x20\x01(\x0e2\
    \x1d.maxgraph.DistributionPatternR\x11distributePattern\x12=\n\x0cshuffl\
    e_type\x18\x04\x20\x01(\x0e2\x1a.maxgraph.InputShuffleTypeR\x0bshuffleTy\
    pe\x12?\n\rinput_shuffle\x18\x05\x20\x01(\x0b2\x1a.maxgraph.InputEdgeShu\
    ffleR\x0cinputShuffle\x12,\n\x12input_stream_index\x18\x06\x20\x01(\x05R\
    \x10inputStreamIndex\"\xf8\x04\n\x0eBinaryOperator\x12*\n\x04base\x18\
    \x01\x20\x01(\x0b2\x16.maxgraph.OperatorBaseR\x04base\x123\n\x16left_inp\
    ut_operator_id\x18\x02\x20\x01(\x05R\x13leftInputOperatorId\x125\n\x17ri\
    ght_input_operator_id\x18\x03\x20\x01(\x05R\x14rightInputOperatorId\x12L\
    \n\x12distribute_pattern\x18\x04\x20\x01(\x0e2\x1d.maxgraph.Distribution\
    PatternR\x11distributePattern\x12F\n\x11left_shuffle_type\x18\x05\x20\
    \x01(\x0e2\x1a.maxgraph.InputShuffleTypeR\x0fleftShuffleType\x12H\n\x12l\
    eft_input_shuffle\x18\x06\x20\x01(\x0b2\x1a.maxgraph.InputEdgeShuffleR\
    \x10leftInputShuffle\x12H\n\x12right_shuffle_type\x18\x07\x20\x01(\x0e2\
    \x1a.maxgraph.InputShuffleTypeR\x10rightShuffleType\x12J\n\x13right_inpu\
    t_shuffle\x18\x08\x20\x01(\x0b2\x1a.maxgraph.InputEdgeShuffleR\x11rightI\
    nputShuffle\x12*\n\x11left_stream_index\x18\t\x20\x01(\x05R\x0fleftStrea\
    mIndex\x12,\n\x12right_stream_index\x18\n\x20\x01(\x05R\x10rightStreamIn\
    dex\"f\n\x0cSinkOperator\x12*\n\x04base\x18\x01\x20\x01(\x0b2\x16.maxgra\
    ph.OperatorBaseR\x04base\x12*\n\x11input_operator_id\x18\x02\x20\x01(\
    \x05R\x0finputOperatorId\"\x9c\x02\n\x0eOdpsQueryInput\x12\x18\n\x07proj\
    ect\x18\x01\x20\x01(\tR\x07project\x12\x1d\n\ntable_name\x18\x02\x20\x01\
    (\tR\ttableName\x12\x1a\n\x08endpoint\x18\x03\x20\x01(\tR\x08endpoint\
    \x12\x1b\n\taccess_id\x18\x04\x20\x01(\tR\x08accessId\x12\x1d\n\naccess_\
    key\x18\x05\x20\x01(\tR\taccessKey\x12\x0e\n\x02ds\x18\x06\x20\x01(\tR\
    \x02ds\x12\x20\n\x0cpk_name_list\x18\x07\x20\x03(\tR\npkNameList\x12G\n\
    \x0flogical_compare\x18\x08\x20\x03(\x0b2\x1e.maxgraph.ColumnLogicalComp\
    areR\x0elogicalCompare\"\x9c\x01\n\x0eOdpsGraphInput\x12\x1a\n\x08endpoi\
    nt\x18\x01\x20\x01(\tR\x08endpoint\x12\x1b\n\taccess_id\x18\x02\x20\x01(\
    \tR\x08accessId\x12\x1d\n\naccess_key\x18\x03\x20\x01(\tR\taccessKey\x12\
    2\n\nedge_input\x18\x04\x20\x03(\x0b2\x13.maxgraph.EdgeInputR\tedgeInput\
    \"\xcc\x01\n\x10OdpsOutputConfig\x12\x18\n\x07project\x18\x01\x20\x01(\t\
    R\x07project\x12\x1d\n\ntable_name\x18\x02\x20\x01(\tR\ttableName\x12\
    \x1a\n\x08endpoint\x18\x03\x20\x01(\tR\x08endpoint\x12\x1b\n\taccess_id\
    \x18\x04\x20\x01(\tR\x08accessId\x12\x1d\n\naccess_key\x18\x05\x20\x01(\
    \tR\taccessKey\x12\x0e\n\x02ds\x18\x06\x20\x01(\tR\x02ds\x12\x17\n\x07pr\
    op_id\x18\x07\x20\x03(\x05R\x06propId\"v\n\nQueryInput\x12%\n\x05value\
    \x18\x01\x20\x01(\x0b2\x0f.maxgraph.ValueR\x05value\x12A\n\x0flogical_co\
    mpare\x18\x02\x20\x03(\x0b2\x18.maxgraph.LogicalCompareR\x0elogicalCompa\
    re\"\x98\x01\n\x05Query\x12\x1f\n\x0bdataflow_id\x18\x01\x20\x01(\tR\nda\
    taflowId\x12*\n\x05input\x18\x02\x20\x01(\x0b2\x14.maxgraph.QueryInputR\
    \x05input\x12'\n\x0ftimeout_seconds\x18\x03\x20\x01(\x03R\x0etimeoutSeco\
    nds\x12\x19\n\x08query_id\x18\x04\x20\x01(\tR\x07queryId\"e\n\x17Logical\
    CompareListProto\x12J\n\x14logical_compare_list\x18\x01\x20\x03(\x0b2\
    \x18.maxgraph.LogicalCompareR\x12logicalCompareList\"\x89\x01\n\x14WhenC\
    ompareListProto\x12M\n\x11when_compare_list\x18\x01\x20\x03(\x0b2!.maxgr\
    aph.LogicalCompareListProtoR\x0fwhenCompareList\x12\"\n\relse_end_flag\
    \x18\x02\x20\x01(\x08R\x0belseEndFlag\"\x86\x01\n\x15WhenThenArgumentPro\
    to\x12;\n\x0cwhen_compare\x18\x01\x20\x03(\x0b2\x18.maxgraph.LogicalComp\
    areR\x0bwhenCompare\x120\n\tthen_plan\x18\x02\x20\x01(\x0b2\x13.maxgraph\
    .QueryPlanR\x08thenPlan\"\xc9\x01\n\x15CaseWhenArgumentProto\x120\n\tcas\
    e_plan\x18\x01\x20\x01(\x0b2\x13.maxgraph.QueryPlanR\x08casePlan\x12E\n\
    \x0ewhen_then_list\x18\x02\x20\x03(\x0b2\x1f.maxgraph.WhenThenArgumentPr\
    otoR\x0cwhenThenList\x127\n\relse_end_plan\x18\x03\x20\x01(\x0b2\x13.max\
    graph.QueryPlanR\x0belseEndPlan\"\x9d\x01\n\x11MathOperatorProto\x12?\n\
    \x0fmath_token_type\x18\x01\x20\x01(\x0e2\x17.maxgraph.MathTokenTypeR\rm\
    athTokenType\x12G\n\x0eoperator_value\x18\x02\x20\x01(\x0b2\x20.maxgraph\
    .MathOperatorValueProtoR\roperatorValue\"\x85\x01\n\x19MathFunctionArgum\
    entProto\x12?\n\rfunction_type\x18\x01\x20\x01(\x0e2\x1a.maxgraph.MathFu\
    nctionTypeR\x0cfunctionType\x12'\n\x0fargument_number\x18\x02\x20\x01(\
    \x05R\x0eargumentNumber\"\x82\x01\n\x18MathOpTokenArgumentProto\x12C\n\r\
    op_token_type\x18\x01\x20\x01(\x0e2\x1f.maxgraph.MathOperatorTokenTypeR\
    \x0bopTokenType\x12!\n\x0cnum_operands\x18\x02\x20\x01(\x05R\x0bnumOpera\
    nds\"\x81\x02\n\x16MathOperatorValueProto\x12!\n\x0cdouble_value\x18\x01\
    \x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cstring_value\x18\x02\x20\x01(\tR\
    \x0bstringValue\x12\x1b\n\tint_value\x18\x03\x20\x01(\x05R\x08intValue\
    \x12>\n\x08func_arg\x18\x04\x20\x01(\x0b2#.maxgraph.MathFunctionArgument\
    ProtoR\x07funcArg\x12D\n\x0cop_token_arg\x18\x05\x20\x01(\x0b2\".maxgrap\
    h.MathOpTokenArgumentProtoR\nopTokenArg\"X\n\x11MathArgumentProto\x12C\n\
    \x0fmath_token_list\x18\x01\x20\x03(\x0b2\x1b.maxgraph.MathOperatorProto\
    R\rmathTokenList\"T\n\x12CountArgumentProto\x12\x1d\n\nlimit_flag\x18\
    \x01\x20\x01(\x08R\tlimitFlag\x12\x1f\n\x0blimit_count\x18\x02\x20\x01(\
    \x03R\nlimitCount\"\xbd\x01\n\x15EnterKeyArgumentProto\x12A\n\x0eenter_k\
    ey_type\x18\x01\x20\x01(\x0e2\x1b.maxgraph.EnterKeyTypeProtoR\x0centerKe\
    yType\x12\"\n\rprop_label_id\x18\x02\x20\x01(\x05R\x0bpropLabelId\x12\
    \x20\n\x0cprop_id_list\x18\x03\x20\x03(\x05R\npropIdList\x12\x1b\n\tuniq\
    _flag\x18\x04\x20\x01(\x08R\x08uniqFlag\"\xb6\x01\n\x13RepeatArgumentPro\
    to\x12\x19\n\x08leave_id\x18\x01\x20\x01(\x05R\x07leaveId\x12\x1f\n\x0bf\
    eedback_id\x18\x02\x20\x01(\x05R\nfeedbackId\x12\x1d\n\nloop_limit\x18\
    \x03\x20\x01(\x05R\tloopLimit\x12\x1b\n\temit_flag\x18\x04\x20\x01(\x08R\
    \x08emitFlag\x12'\n\x04plan\x18\x05\x20\x01(\x0b2\x13.maxgraph.QueryPlan\
    R\x04plan\"9\n\x14BarrierArgumentProto\x12!\n\x0cbarrier_size\x18\x01\
    \x20\x01(\x05R\x0bbarrierSize\"\xa6\x01\n\x18CreateGraphArgumentProto\
    \x12\x1d\n\ngraph_name\x18\x01\x20\x01(\tR\tgraphName\x12H\n\x10crate_gr\
    aph_type\x18\x02\x20\x01(\x0e2\x1e.maxgraph.CreateGraphTypeProtoR\x0ecra\
    teGraphType\x12!\n\x0cgraph_schema\x18\x03\x20\x01(\tR\x0bgraphSchema\"W\
    \n\x14RuntimePropertyProto\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1b\n\tdata_type\x18\
    \x03\x20\x01(\tR\x08dataType\"\xb5\x01\n\x16RuntimeVertexTypeProto\x12\
    \x19\n\x08label_id\x18\x01\x20\x01(\x05R\x07labelId\x12\x1d\n\nlabel_nam\
    e\x18\x02\x20\x01(\tR\tlabelName\x12>\n\nproperties\x18\x03\x20\x03(\x0b\
    2\x1e.maxgraph.RuntimePropertyProtoR\nproperties\x12!\n\x0cprimary_keys\
    \x18\x04\x20\x03(\tR\x0bprimaryKeys\"`\n\x18RuntimeEdgeRelationProto\x12\
    !\n\x0csource_label\x18\x01\x20\x01(\tR\x0bsourceLabel\x12!\n\x0ctarget_\
    label\x18\x02\x20\x01(\tR\x0btargetLabel\"\xd2\x01\n\x14RuntimeEdgeTypeP\
    roto\x12\x19\n\x08label_id\x18\x01\x20\x01(\x05R\x07labelId\x12\x1d\n\nl\
    abel_name\x18\x02\x20\x01(\tR\tlabelName\x12>\n\nproperties\x18\x03\x20\
    \x03(\x0b2\x1e.maxgraph.RuntimePropertyProtoR\nproperties\x12@\n\trelati\
    ons\x18\x04\x20\x03(\x0b2\".maxgraph.RuntimeEdgeRelationProtoR\trelation\
    s\"\x9d\x01\n\x17RuntimeGraphSchemaProto\x12C\n\x0cvertex_types\x18\x01\
    \x20\x03(\x0b2\x20.maxgraph.RuntimeVertexTypeProtoR\x0bvertexTypes\x12=\
    \n\nedge_types\x18\x02\x20\x03(\x0b2\x1e.maxgraph.RuntimeEdgeTypeProtoR\
    \tedgeTypes\"_\n\x19VertexPrimaryKeyListProto\x12B\n\x0cprimary_keys\x18\
    \x01\x20\x03(\x0b2\x1f.maxgraph.VertexPrimaryKeyProtoR\x0bprimaryKeys\"^\
    \n\x15VertexPrimaryKeyProto\x12\x19\n\x08label_id\x18\x01\x20\x01(\x05R\
    \x07labelId\x12*\n\x11primary_key_value\x18\x02\x20\x01(\tR\x0fprimaryKe\
    yValue*Q\n\x0fInputBatchLevel\x12\n\n\x06Medium\x10\0\x12\t\n\x05Small\
    \x10\x01\x12\r\n\tVerySmall\x10\x02\x12\t\n\x05Large\x10\x03\x12\r\n\tVe\
    ryLarge\x10\x04*\x97\x0f\n\x0cOperatorType\x12\x05\n\x01V\x10\0\x12\x05\
    \n\x01E\x10\x01\x12\x07\n\x03OUT\x10\x02\x12\x06\n\x02IN\x10\x03\x12\x08\
    \n\x04BOTH\x10\x04\x12\t\n\x05OUT_E\x10\x05\x12\x08\n\x04IN_E\x10\x06\
    \x12\n\n\x06BOTH_E\x10\x07\x12\t\n\x05OUT_V\x10\x08\x12\x08\n\x04IN_V\
    \x10\t\x12\n\n\x06BOTH_V\x10\n\x12\x0e\n\nSELECT_ONE\x10\x0b\x12\x0f\n\
    \x0bCOUNT_LOCAL\x10\x0c\x12\x0e\n\nJOIN_LABEL\x10\r\x12\t\n\x05ORDER\x10\
    \x0e\x12\t\n\x05RANGE\x10\x0f\x12\x12\n\x0eFIRST_BY_LABEL\x10\x10\x12\t\
    \n\x05UNION\x10\x11\x12\t\n\x05DEDUP\x10\x12\x12\x0f\n\x0bGROUP_COUNT\
    \x10\x13\x12\x07\n\x03HAS\x10\x14\x12\x10\n\x0cREPEAT_START\x10\x15\x12\
    \n\n\x06REPEAT\x10\x16\x12\n\n\x06SELECT\x10\x17\x12\t\n\x05WHERE\x10\
    \x18\x12\x0e\n\nPROP_VALUE\x10\x19\x12\x12\n\x0ePROP_KEY_VALUE\x10\x1a\
    \x12\x0f\n\x0bWHERE_LABEL\x10\x1b\x12\n\n\x06UNFOLD\x10\x1c\x12\x0c\n\
    \x08PATH_OUT\x10\x1d\x12\n\n\x06FILTER\x10\x1e\x12\x14\n\x10JOIN_COUNT_L\
    ABEL\x10\x1f\x12\x0f\n\x0bSIMPLE_PATH\x10\x20\x12\x12\n\x0ePROP_MAP_VALU\
    E\x10!\x12\x10\n\x0cSOURCE_CHAIN\x10\"\x12\x0f\n\x0bUNARY_CHAIN\x10#\x12\
    \x10\n\x0cBINARY_CHAIN\x10$\x12\x08\n\x04FOLD\x10%\x12\x0f\n\x0bRANGE_LO\
    CAL\x10&\x12\x0f\n\x0bORDER_LOCAL\x10'\x12\x0c\n\x08SACK_OUT\x10(\x12\
    \x10\n\x0cCOUNT_BY_KEY\x10)\x12\r\n\tPROP_FILL\x10*\x12\x15\n\x11DEDUP_C\
    OUNT_LABEL\x10+\x12\x13\n\x0fDUPLICATE_LABEL\x10,\x12\t\n\x05COUNT\x10-\
    \x12\x16\n\x12JOIN_DIRECT_FILTER\x10.\x12\x07\n\x03NOT\x10/\x12\x0b\n\
    \x07OTHER_V\x100\x12\x07\n\x03SUM\x101\x12\n\n\x06COLUMN\x102\x12\x0c\n\
    \x08CONSTANT\x103\x12\x0f\n\x0bFOLD_BY_KEY\x104\x12\x0e\n\nSUM_BY_KEY\
    \x105\x12\x07\n\x03MAX\x106\x12\x07\n\x03MIN\x107\x12\x0e\n\nMAX_BY_KEY\
    \x108\x12\x0e\n\nMIN_BY_KEY\x109\x12\r\n\tENTRY_OUT\x10:\x12\x0b\n\x07FO\
    LDMAP\x10;\x12\x0e\n\nPROPERTIES\x10<\x12\x0e\n\nWRITE_ODPS\x10=\x12\x10\
    \n\x0cRANGE_BY_KEY\x10>\x12\x10\n\x0cDEDUP_BY_KEY\x10?\x12\x0b\n\x07V_CO\
    UNT\x10@\x12\x0b\n\x07E_COUNT\x10A\x12\r\n\tOUT_COUNT\x10B\x12\x0c\n\x08\
    IN_COUNT\x10C\x12\x0e\n\nBOTH_COUNT\x10D\x12\x0f\n\x0bCOUNT_LIMIT\x10E\
    \x12\x1d\n\x19JOIN_DIRECT_FILTER_NEGATE\x10F\x12!\n\x1dJOIN_DIRECT_FILTE\
    R_KEY_NEGATE\x10G\x12\x0e\n\nDFS_SOURCE\x10H\x12\x14\n\x10DFS_REPEAT_GRA\
    PH\x10I\x12\x13\n\x0fDFS_FINISH_JOIN\x10J\x12\n\n\x06SAMPLE\x10K\x12\x10\
    \n\x0cGRAPH_SOURCE\x10L\x12\x11\n\rBRANCH_OPTION\x10M\x12\x0e\n\nJOIN_RA\
    TIO\x10N\x12\x15\n\x11JOIN_STORE_FILTER\x10O\x12\x0c\n\x08SUBGRAPH\x10P\
    \x12\x13\n\x0fSUBGRAPH_SOURCE\x10Q\x12\x12\n\x0eJOIN_CASE_WHEN\x10R\x12\
    \t\n\x05CACHE\x10S\x12\x08\n\x04MATH\x10T\x12\x18\n\x14JOIN_RIGHT_ZERO_J\
    OIN\x10U\x12\r\n\tENTER_KEY\x10V\x12\x18\n\x14JOIN_RIGHT_VALUE_KEY\x10W\
    \x12\x0f\n\x0bBYKEY_ENTRY\x10X\x12\x0f\n\x0bKEY_MESSAGE\x10Y\x12\r\n\tRA\
    NGE_SUM\x10Z\x12\x0f\n\x0bLABEL_VALUE\x10[\x12\x0e\n\nFOLD_STORE\x10\\\
    \x12\x10\n\x0cCOMBINER_SUM\x10]\x12\x12\n\x0eESTIMATE_COUNT\x10^\x12\x12\
    \n\x0eCOMBINER_RANGE\x10_\x12\x12\n\x0eDFS_REPEAT_CMD\x10`\x12\x13\n\x0f\
    DFS_REPEAT_DATA\x10a\x12\x0b\n\x07BARRIER\x10b\x12\x12\n\rLAMBDA_FILTER\
    \x10\xe8\x07\x12\x0f\n\nLAMBDA_MAP\x10\xe9\x07\x12\x13\n\x0eLAMBDA_FLATM\
    AP\x10\xea\x07\x12\x1b\n\x16GRAPH_VINEYARD_BUILDER\x10\xd0\x0f\x12\x1a\n\
    \x15GRAPH_VINEYARD_STREAM\x10\xd1\x0f\x12\x1b\n\x16OUTPUT_VINEYARD_VERTE\
    X\x10\xd2\x0f\x12\x19\n\x14OUTPUT_VINEYARD_EDGE\x10\xd3\x0f\x12\x0f\n\nP\
    ROGRAM_CC\x10\x90N\x12\x15\n\x10PROGRAM_GRAPH_CC\x10\x91N\x12\x16\n\x11P\
    ROGRAM_GRAPH_LPA\x10\x92N\x12\x1b\n\x16PROGRAM_GRAPH_PAGERANK\x10\x93N\
    \x12\x17\n\x12PROGRAM_GRAPH_HITS\x10\x94N\x12\x1a\n\x15PROGRAM_GRAPH_ALL\
    PATH\x10\x95N\x12\x1f\n\x1aPROGRAM_GRAPH_SHORTESTPATH\x10\x96N\x12\x1f\n\
    \x1aPROGRAM_GRAPH_PEERPRESSURE\x10\x97N*\\\n\x0fRequirementType\x12\x0f\
    \n\x0bLABEL_START\x10\0\x12\r\n\tLABEL_DEL\x10\x01\x12\x0e\n\nPATH_START\
    \x10\x02\x12\x0c\n\x08PATH_ADD\x10\x03\x12\x0b\n\x07KEY_DEL\x10\x04*0\n\
    \nColumnType\x12\x0f\n\x0bCOLUMN_KEYS\x10\0\x12\x11\n\rCOLUMN_VALUES\x10\
    \x01*!\n\nSourceType\x12\t\n\x05GRAPH\x10\0\x12\x08\n\x04ODPS\x10\x01*R\
    \n\x08LoopType\x12\x0e\n\nLOOP_ENTER\x10\0\x12\x0e\n\nLOOP_LEAVE\x10\x01\
    \x12\x11\n\rLOOP_FEEDBACK\x10\x02\x12\x13\n\x0fLOOP_LEAVE_LAST\x10\x03*\
    \x84\x01\n\x10InputShuffleType\x12\x10\n\x0cFORWARD_TYPE\x10\0\x12\x17\n\
    \x13SHUFFLE_BY_KEY_TYPE\x10\x01\x12\x16\n\x12SHUFFLE_BY_ID_TYPE\x10\x02\
    \x12\x19\n\x15SHUFFLE_BY_CONST_TYPE\x10\x03\x12\x12\n\x0eBROADCAST_TYPE\
    \x10\x04*=\n\nAssignHint\x12\x0f\n\x0bVERTEX_HASH\x10\0\x12\r\n\tEDGE_HA\
    SH\x10\x01\x12\x0f\n\x0bARBITRARILY\x10\x02*`\n\x13DistributionPattern\
    \x12\x0e\n\nALL_TO_ALL\x10\0\x12\x15\n\x11POINT_WISE_VERTEX\x10\x01\x12\
    \x13\n\x0fPOINT_WISE_EDGE\x10\x02\x12\r\n\tBROADCAST\x10\x03*\xbc\x01\n\
    \rMathTokenType\x12\x0f\n\x0bTOKEN_ERROR\x10\0\x12\x10\n\x0cTOKEN_NUMBER\
    \x10\x01\x12\x12\n\x0eTOKEN_OPERATOR\x10\x02\x12\x12\n\x0eTOKEN_FUNCTION\
    \x10\x03\x12\x1a\n\x16TOKEN_PARENTHESES_OPEN\x10\x04\x12\x1b\n\x17TOKEN_\
    PARENTHESES_CLOSE\x10\x05\x12\x12\n\x0eTOKEN_VARIABLE\x10\x06\x12\x13\n\
    \x0fTOKEN_SEPARATOR\x10\x07*\xe9\x02\n\x10MathFunctionType\x12\x0c\n\x08\
    FUNC_SIN\x10\0\x12\x0c\n\x08FUNC_COS\x10\x01\x12\x0c\n\x08FUNC_TAN\x10\
    \x02\x12\x0c\n\x08FUNC_COT\x10\x03\x12\x0c\n\x08FUNC_LOG\x10\x04\x12\x0e\
    \n\nFUNC_LOG1P\x10\x05\x12\x0c\n\x08FUNC_ABS\x10\x06\x12\r\n\tFUNC_ACOS\
    \x10\x07\x12\r\n\tFUNC_ASIN\x10\x08\x12\r\n\tFUNC_ATAN\x10\t\x12\r\n\tFU\
    NC_CBRT\x10\n\x12\r\n\tFUNC_CEIL\x10\x0b\x12\x0e\n\nFUNC_FLOOR\x10\x0c\
    \x12\r\n\tFUNC_SINH\x10\r\x12\r\n\tFUNC_SQRT\x10\x0e\x12\r\n\tFUNC_TANH\
    \x10\x0f\x12\r\n\tFUNC_COSH\x10\x10\x12\x0c\n\x08FUNC_POW\x10\x11\x12\
    \x0c\n\x08FUNC_EXP\x10\x12\x12\x0e\n\nFUNC_EXPM1\x10\x13\x12\x0e\n\nFUNC\
    _LOG10\x10\x14\x12\r\n\tFUNC_LOG2\x10\x15\x12\x0f\n\x0bFUNC_SIGNUM\x10\
    \x16*\xa6\x01\n\x15MathOperatorTokenType\x12\x0f\n\x0bOP_ADDITION\x10\0\
    \x12\x12\n\x0eOP_SUBTRACTION\x10\x01\x12\x15\n\x11OP_MUTLIPLICATION\x10\
    \x02\x12\x0f\n\x0bOP_DIVISION\x10\x03\x12\x0c\n\x08OP_POWER\x10\x04\x12\
    \r\n\tOP_MODULO\x10\x05\x12\x11\n\rOP_UNARYMINUS\x10\x06\x12\x10\n\x0cOP\
    _UNARYPLUS\x10\x07*K\n\x11EnterKeyTypeProto\x12\x0c\n\x08KEY_SELF\x10\0\
    \x12\x12\n\x0eKEY_PROP_LABEL\x10\x01\x12\x14\n\x10KEY_PROP_VAL_MAP\x10\
    \x02*$\n\x14CreateGraphTypeProto\x12\x0c\n\x08VINEYARD\x10\0B\x16\n\x14c\
    om.alibaba.maxgraphb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
