//
//! Copyright 2020 Alibaba Group Holding Limited.
//! 
//! Licensed under the Apache License, Version 2.0 (the "License");
//! you may not use this file except in compliance with the License.
//! You may obtain a copy of the License at
//! 
//!     http://www.apache.org/licenses/LICENSE-2.0
//! 
//! Unless required by applicable law or agreed to in writing, software
//! distributed under the License is distributed on an "AS IS" BASIS,
//! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//! See the License for the specific language governing permissions and
//! limitations under the License.

// This file is generated by rust-protobuf 2.0.6. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub code: ErrorCode,
    pub message: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // .maxgraph.ErrorCode code = 1;

    pub fn clear_code(&mut self) {
        self.code = ErrorCode::OK;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ErrorCode) {
        self.code = v;
    }

    pub fn get_code(&self) -> ErrorCode {
        self.code
    }

    // bytes message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }

    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != ErrorCode::OK {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != ErrorCode::OK {
            os.write_enum(1, self.code.value())?;
        }
        if !self.message.is_empty() {
            os.write_bytes(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ErrorCode>>(
                    "code",
                    |m: &Error| { &m.code },
                    |m: &mut Error| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message",
                    |m: &Error| { &m.message },
                    |m: &mut Error| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Error>(
                    "Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.clear_code();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Property {
    // message fields
    pub id: i32,
    pub field_type: VariantType,
    pub value: ::std::vec::Vec<u8>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub path: ::protobuf::RepeatedField<PathValue>,
    pub not_vertex_property: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Property {
    pub fn new() -> Property {
        ::std::default::Default::default()
    }

    // int32 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = v;
    }

    pub fn get_id(&self) -> i32 {
        self.id
    }

    // .maxgraph.VariantType type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = VariantType::VT_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: VariantType) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> VariantType {
        self.field_type
    }

    // bytes value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // repeated .maxgraph.LabelValue label_value = 4;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // repeated .maxgraph.PathValue path = 5;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }

    // bool not_vertex_property = 6;

    pub fn clear_not_vertex_property(&mut self) {
        self.not_vertex_property = false;
    }

    // Param is passed by value, moved
    pub fn set_not_vertex_property(&mut self, v: bool) {
        self.not_vertex_property = v;
    }

    pub fn get_not_vertex_property(&self) -> bool {
        self.not_vertex_property
    }
}

impl ::protobuf::Message for Property {
    fn is_initialized(&self) -> bool {
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_vertex_property = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_type != VariantType::VT_BOOL {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.not_vertex_property != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.field_type != VariantType::VT_BOOL {
            os.write_enum(2, self.field_type.value())?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        for v in &self.label_value {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.not_vertex_property != false {
            os.write_bool(6, self.not_vertex_property)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Property {
        Property::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "id",
                    |m: &Property| { &m.id },
                    |m: &mut Property| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VariantType>>(
                    "type",
                    |m: &Property| { &m.field_type },
                    |m: &mut Property| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &Property| { &m.value },
                    |m: &mut Property| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &Property| { &m.label_value },
                    |m: &mut Property| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &Property| { &m.path },
                    |m: &mut Property| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "not_vertex_property",
                    |m: &Property| { &m.not_vertex_property },
                    |m: &mut Property| { &mut m.not_vertex_property },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Property>(
                    "Property",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Property {
        static mut instance: ::protobuf::lazy::Lazy<Property> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Property,
        };
        unsafe {
            instance.get(Property::new)
        }
    }
}

impl ::protobuf::Clear for Property {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_field_type();
        self.clear_value();
        self.clear_label_value();
        self.clear_path();
        self.clear_not_vertex_property();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Property {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Property {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vertex {
    // message fields
    pub id: i64,
    pub type_id: i32,
    pub path: ::protobuf::RepeatedField<PathValue>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub property: ::protobuf::RepeatedField<Property>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Vertex {
    pub fn new() -> Vertex {
        ::std::default::Default::default()
    }

    // int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }

    // int32 type_id = 2;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // repeated .maxgraph.PathValue path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }

    // repeated .maxgraph.LabelValue label_value = 4;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // repeated .maxgraph.Property property = 5;

    pub fn clear_property(&mut self) {
        self.property.clear();
    }

    // Param is passed by value, moved
    pub fn set_property(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.property = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.property
    }

    // Take field
    pub fn take_property(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.property, ::protobuf::RepeatedField::new())
    }

    pub fn get_property(&self) -> &[Property] {
        &self.property
    }
}

impl ::protobuf::Message for Vertex {
    fn is_initialized(&self) -> bool {
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.property {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.property)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.property {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if self.type_id != 0 {
            os.write_int32(2, self.type_id)?;
        }
        for v in &self.path {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.label_value {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.property {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vertex {
        Vertex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &Vertex| { &m.id },
                    |m: &mut Vertex| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &Vertex| { &m.type_id },
                    |m: &mut Vertex| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &Vertex| { &m.path },
                    |m: &mut Vertex| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &Vertex| { &m.label_value },
                    |m: &mut Vertex| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                    "property",
                    |m: &Vertex| { &m.property },
                    |m: &mut Vertex| { &mut m.property },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Vertex>(
                    "Vertex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Vertex {
        static mut instance: ::protobuf::lazy::Lazy<Vertex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Vertex,
        };
        unsafe {
            instance.get(Vertex::new)
        }
    }
}

impl ::protobuf::Clear for Vertex {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_type_id();
        self.clear_path();
        self.clear_label_value();
        self.clear_property();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vertex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vertex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Edge {
    // message fields
    pub src: ::protobuf::SingularPtrField<Vertex>,
    pub dst: ::protobuf::SingularPtrField<Vertex>,
    pub out_direction: bool,
    pub type_id: i32,
    pub property: ::protobuf::RepeatedField<Property>,
    pub path: ::protobuf::RepeatedField<PathValue>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub id: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Edge {
    pub fn new() -> Edge {
        ::std::default::Default::default()
    }

    // .maxgraph.Vertex src = 1;

    pub fn clear_src(&mut self) {
        self.src.clear();
    }

    pub fn has_src(&self) -> bool {
        self.src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_src(&mut self, v: Vertex) {
        self.src = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src(&mut self) -> &mut Vertex {
        if self.src.is_none() {
            self.src.set_default();
        }
        self.src.as_mut().unwrap()
    }

    // Take field
    pub fn take_src(&mut self) -> Vertex {
        self.src.take().unwrap_or_else(|| Vertex::new())
    }

    pub fn get_src(&self) -> &Vertex {
        self.src.as_ref().unwrap_or_else(|| Vertex::default_instance())
    }

    // .maxgraph.Vertex dst = 2;

    pub fn clear_dst(&mut self) {
        self.dst.clear();
    }

    pub fn has_dst(&self) -> bool {
        self.dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst(&mut self, v: Vertex) {
        self.dst = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst(&mut self) -> &mut Vertex {
        if self.dst.is_none() {
            self.dst.set_default();
        }
        self.dst.as_mut().unwrap()
    }

    // Take field
    pub fn take_dst(&mut self) -> Vertex {
        self.dst.take().unwrap_or_else(|| Vertex::new())
    }

    pub fn get_dst(&self) -> &Vertex {
        self.dst.as_ref().unwrap_or_else(|| Vertex::default_instance())
    }

    // bool out_direction = 3;

    pub fn clear_out_direction(&mut self) {
        self.out_direction = false;
    }

    // Param is passed by value, moved
    pub fn set_out_direction(&mut self, v: bool) {
        self.out_direction = v;
    }

    pub fn get_out_direction(&self) -> bool {
        self.out_direction
    }

    // int32 type_id = 4;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // repeated .maxgraph.Property property = 5;

    pub fn clear_property(&mut self) {
        self.property.clear();
    }

    // Param is passed by value, moved
    pub fn set_property(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.property = v;
    }

    // Mutable pointer to the field.
    pub fn mut_property(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.property
    }

    // Take field
    pub fn take_property(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.property, ::protobuf::RepeatedField::new())
    }

    pub fn get_property(&self) -> &[Property] {
        &self.property
    }

    // repeated .maxgraph.PathValue path = 6;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }

    // repeated .maxgraph.LabelValue label_value = 7;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // int64 id = 8;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }
}

impl ::protobuf::Message for Edge {
    fn is_initialized(&self) -> bool {
        for v in &self.src {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dst {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.property {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.src)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dst)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.out_direction = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.property)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.src.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dst.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.out_direction != false {
            my_size += 2;
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.property {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(8, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.src.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dst.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.out_direction != false {
            os.write_bool(3, self.out_direction)?;
        }
        if self.type_id != 0 {
            os.write_int32(4, self.type_id)?;
        }
        for v in &self.property {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.label_value {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.id != 0 {
            os.write_int64(8, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Edge {
        Edge::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vertex>>(
                    "src",
                    |m: &Edge| { &m.src },
                    |m: &mut Edge| { &mut m.src },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Vertex>>(
                    "dst",
                    |m: &Edge| { &m.dst },
                    |m: &mut Edge| { &mut m.dst },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "out_direction",
                    |m: &Edge| { &m.out_direction },
                    |m: &mut Edge| { &mut m.out_direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &Edge| { &m.type_id },
                    |m: &mut Edge| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                    "property",
                    |m: &Edge| { &m.property },
                    |m: &mut Edge| { &mut m.property },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &Edge| { &m.path },
                    |m: &mut Edge| { &mut m.path },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &Edge| { &m.label_value },
                    |m: &mut Edge| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &Edge| { &m.id },
                    |m: &mut Edge| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Edge>(
                    "Edge",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Edge {
        static mut instance: ::protobuf::lazy::Lazy<Edge> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Edge,
        };
        unsafe {
            instance.get(Edge::new)
        }
    }
}

impl ::protobuf::Clear for Edge {
    fn clear(&mut self) {
        self.clear_src();
        self.clear_dst();
        self.clear_out_direction();
        self.clear_type_id();
        self.clear_property();
        self.clear_path();
        self.clear_label_value();
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Edge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Edge {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DfsCommand {
    // message fields
    pub batch_size: i64,
    pub send_count: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DfsCommand {
    pub fn new() -> DfsCommand {
        ::std::default::Default::default()
    }

    // int64 batch_size = 1;

    pub fn clear_batch_size(&mut self) {
        self.batch_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_size(&mut self, v: i64) {
        self.batch_size = v;
    }

    pub fn get_batch_size(&self) -> i64 {
        self.batch_size
    }

    // int64 send_count = 2;

    pub fn clear_send_count(&mut self) {
        self.send_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_count(&mut self, v: i64) {
        self.send_count = v;
    }

    pub fn get_send_count(&self) -> i64 {
        self.send_count
    }
}

impl ::protobuf::Message for DfsCommand {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.batch_size = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.send_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.batch_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.send_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.send_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.batch_size != 0 {
            os.write_int64(1, self.batch_size)?;
        }
        if self.send_count != 0 {
            os.write_int64(2, self.send_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DfsCommand {
        DfsCommand::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "batch_size",
                    |m: &DfsCommand| { &m.batch_size },
                    |m: &mut DfsCommand| { &mut m.batch_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "send_count",
                    |m: &DfsCommand| { &m.send_count },
                    |m: &mut DfsCommand| { &mut m.send_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DfsCommand>(
                    "DfsCommand",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DfsCommand {
        static mut instance: ::protobuf::lazy::Lazy<DfsCommand> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DfsCommand,
        };
        unsafe {
            instance.get(DfsCommand::new)
        }
    }
}

impl ::protobuf::Clear for DfsCommand {
    fn clear(&mut self) {
        self.clear_batch_size();
        self.clear_send_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DfsCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DfsCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Object {
    // message fields
    pub field: ::protobuf::RepeatedField<Property>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Object {
    pub fn new() -> Object {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.Property field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::protobuf::RepeatedField<Property>) {
        self.field = v;
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut ::protobuf::RepeatedField<Property> {
        &mut self.field
    }

    // Take field
    pub fn take_field(&mut self) -> ::protobuf::RepeatedField<Property> {
        ::std::mem::replace(&mut self.field, ::protobuf::RepeatedField::new())
    }

    pub fn get_field(&self) -> &[Property] {
        &self.field
    }
}

impl ::protobuf::Message for Object {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.field {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Object {
        Object::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Property>>(
                    "field",
                    |m: &Object| { &m.field },
                    |m: &mut Object| { &mut m.field },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Object>(
                    "Object",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Object {
        static mut instance: ::protobuf::lazy::Lazy<Object> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Object,
        };
        unsafe {
            instance.get(Object::new)
        }
    }
}

impl ::protobuf::Clear for Object {
    fn clear(&mut self) {
        self.clear_field();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Object {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Object {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClassValue {
    // message fields
    pub class_type: ClassType,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ClassValue {
    pub fn new() -> ClassValue {
        ::std::default::Default::default()
    }

    // .maxgraph.ClassType class_type = 1;

    pub fn clear_class_type(&mut self) {
        self.class_type = ClassType::VERTEX;
    }

    // Param is passed by value, moved
    pub fn set_class_type(&mut self, v: ClassType) {
        self.class_type = v;
    }

    pub fn get_class_type(&self) -> ClassType {
        self.class_type
    }

    // bytes payload = 2;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
}

impl ::protobuf::Message for ClassValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.class_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.class_type != ClassType::VERTEX {
            my_size += ::protobuf::rt::enum_size(1, self.class_type);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.class_type != ClassType::VERTEX {
            os.write_enum(1, self.class_type.value())?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(2, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClassValue {
        ClassValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClassType>>(
                    "class_type",
                    |m: &ClassValue| { &m.class_type },
                    |m: &mut ClassValue| { &mut m.class_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &ClassValue| { &m.payload },
                    |m: &mut ClassValue| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClassValue>(
                    "ClassValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClassValue {
        static mut instance: ::protobuf::lazy::Lazy<ClassValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClassValue,
        };
        unsafe {
            instance.get(ClassValue::new)
        }
    }
}

impl ::protobuf::Clear for ClassValue {
    fn clear(&mut self) {
        self.clear_class_type();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClassValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelValue {
    // message fields
    pub class_value: ::protobuf::SingularPtrField<ClassValue>,
    pub label_id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LabelValue {
    pub fn new() -> LabelValue {
        ::std::default::Default::default()
    }

    // .maxgraph.ClassValue class_value = 1;

    pub fn clear_class_value(&mut self) {
        self.class_value.clear();
    }

    pub fn has_class_value(&self) -> bool {
        self.class_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_value(&mut self, v: ClassValue) {
        self.class_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_value(&mut self) -> &mut ClassValue {
        if self.class_value.is_none() {
            self.class_value.set_default();
        }
        self.class_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_class_value(&mut self) -> ClassValue {
        self.class_value.take().unwrap_or_else(|| ClassValue::new())
    }

    pub fn get_class_value(&self) -> &ClassValue {
        self.class_value.as_ref().unwrap_or_else(|| ClassValue::default_instance())
    }

    // int32 label_id = 2;

    pub fn clear_label_id(&mut self) {
        self.label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: i32) {
        self.label_id = v;
    }

    pub fn get_label_id(&self) -> i32 {
        self.label_id
    }
}

impl ::protobuf::Message for LabelValue {
    fn is_initialized(&self) -> bool {
        for v in &self.class_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.class_value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.class_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.label_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.class_value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.label_id != 0 {
            os.write_int32(2, self.label_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelValue {
        LabelValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassValue>>(
                    "class_value",
                    |m: &LabelValue| { &m.class_value },
                    |m: &mut LabelValue| { &mut m.class_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_id",
                    |m: &LabelValue| { &m.label_id },
                    |m: &mut LabelValue| { &mut m.label_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LabelValue>(
                    "LabelValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LabelValue {
        static mut instance: ::protobuf::lazy::Lazy<LabelValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LabelValue,
        };
        unsafe {
            instance.get(LabelValue::new)
        }
    }
}

impl ::protobuf::Clear for LabelValue {
    fn clear(&mut self) {
        self.clear_class_value();
        self.clear_label_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathValue {
    // message fields
    pub class_value: ::protobuf::SingularPtrField<ClassValue>,
    pub label_id_list: ::std::vec::Vec<i32>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub path: ::protobuf::RepeatedField<PathValue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PathValue {
    pub fn new() -> PathValue {
        ::std::default::Default::default()
    }

    // .maxgraph.ClassValue class_value = 1;

    pub fn clear_class_value(&mut self) {
        self.class_value.clear();
    }

    pub fn has_class_value(&self) -> bool {
        self.class_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_value(&mut self, v: ClassValue) {
        self.class_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_class_value(&mut self) -> &mut ClassValue {
        if self.class_value.is_none() {
            self.class_value.set_default();
        }
        self.class_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_class_value(&mut self) -> ClassValue {
        self.class_value.take().unwrap_or_else(|| ClassValue::new())
    }

    pub fn get_class_value(&self) -> &ClassValue {
        self.class_value.as_ref().unwrap_or_else(|| ClassValue::default_instance())
    }

    // repeated int32 label_id_list = 2;

    pub fn clear_label_id_list(&mut self) {
        self.label_id_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_id_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.label_id_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_id_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.label_id_list
    }

    // Take field
    pub fn take_label_id_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.label_id_list, ::std::vec::Vec::new())
    }

    pub fn get_label_id_list(&self) -> &[i32] {
        &self.label_id_list
    }

    // repeated .maxgraph.LabelValue label_value = 3;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // repeated .maxgraph.PathValue path = 4;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }
}

impl ::protobuf::Message for PathValue {
    fn is_initialized(&self) -> bool {
        for v in &self.class_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.class_value)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.label_id_list)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.class_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.label_id_list {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.class_value.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.label_id_list {
            os.write_int32(2, *v)?;
        };
        for v in &self.label_value {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathValue {
        PathValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassValue>>(
                    "class_value",
                    |m: &PathValue| { &m.class_value },
                    |m: &mut PathValue| { &mut m.class_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_id_list",
                    |m: &PathValue| { &m.label_id_list },
                    |m: &mut PathValue| { &mut m.label_id_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &PathValue| { &m.label_value },
                    |m: &mut PathValue| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &PathValue| { &m.path },
                    |m: &mut PathValue| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PathValue>(
                    "PathValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PathValue {
        static mut instance: ::protobuf::lazy::Lazy<PathValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PathValue,
        };
        unsafe {
            instance.get(PathValue::new)
        }
    }
}

impl ::protobuf::Clear for PathValue {
    fn clear(&mut self) {
        self.clear_class_value();
        self.clear_label_id_list();
        self.clear_label_value();
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct List {
    // message fields
    pub value: ::protobuf::RepeatedField<ClassValue>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub path: ::protobuf::RepeatedField<PathValue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.ClassValue value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<ClassValue>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<ClassValue> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<ClassValue> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }

    pub fn get_value(&self) -> &[ClassValue] {
        &self.value
    }

    // repeated .maxgraph.LabelValue label_value = 2;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // repeated .maxgraph.PathValue path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }
}

impl ::protobuf::Message for List {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.label_value {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> List {
        List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassValue>>(
                    "value",
                    |m: &List| { &m.value },
                    |m: &mut List| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &List| { &m.label_value },
                    |m: &mut List| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &List| { &m.path },
                    |m: &mut List| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<List>(
                    "List",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static List {
        static mut instance: ::protobuf::lazy::Lazy<List> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const List,
        };
        unsafe {
            instance.get(List::new)
        }
    }
}

impl ::protobuf::Clear for List {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_label_value();
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Entry {
    // message fields
    pub key: ::protobuf::SingularPtrField<ClassValue>,
    pub value: ::protobuf::SingularPtrField<ClassValue>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub path: ::protobuf::RepeatedField<PathValue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Entry {
    pub fn new() -> Entry {
        ::std::default::Default::default()
    }

    // .maxgraph.ClassValue key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ClassValue) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ClassValue {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ClassValue {
        self.key.take().unwrap_or_else(|| ClassValue::new())
    }

    pub fn get_key(&self) -> &ClassValue {
        self.key.as_ref().unwrap_or_else(|| ClassValue::default_instance())
    }

    // .maxgraph.ClassValue value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ClassValue) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ClassValue {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ClassValue {
        self.value.take().unwrap_or_else(|| ClassValue::new())
    }

    pub fn get_value(&self) -> &ClassValue {
        self.value.as_ref().unwrap_or_else(|| ClassValue::default_instance())
    }

    // repeated .maxgraph.LabelValue label_value = 3;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // repeated .maxgraph.PathValue path = 4;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }
}

impl ::protobuf::Message for Entry {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.label_value {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Entry {
        Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassValue>>(
                    "key",
                    |m: &Entry| { &m.key },
                    |m: &mut Entry| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClassValue>>(
                    "value",
                    |m: &Entry| { &m.value },
                    |m: &mut Entry| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &Entry| { &m.label_value },
                    |m: &mut Entry| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &Entry| { &m.path },
                    |m: &mut Entry| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Entry>(
                    "Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Entry {
        static mut instance: ::protobuf::lazy::Lazy<Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Entry,
        };
        unsafe {
            instance.get(Entry::new)
        }
    }
}

impl ::protobuf::Clear for Entry {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.clear_label_value();
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Map {
    // message fields
    pub entry_list: ::protobuf::RepeatedField<Entry>,
    pub label_value: ::protobuf::RepeatedField<LabelValue>,
    pub path: ::protobuf::RepeatedField<PathValue>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Map {
    pub fn new() -> Map {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.Entry entry_list = 1;

    pub fn clear_entry_list(&mut self) {
        self.entry_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_list(&mut self, v: ::protobuf::RepeatedField<Entry>) {
        self.entry_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry_list(&mut self) -> &mut ::protobuf::RepeatedField<Entry> {
        &mut self.entry_list
    }

    // Take field
    pub fn take_entry_list(&mut self) -> ::protobuf::RepeatedField<Entry> {
        ::std::mem::replace(&mut self.entry_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_entry_list(&self) -> &[Entry] {
        &self.entry_list
    }

    // repeated .maxgraph.LabelValue label_value = 2;

    pub fn clear_label_value(&mut self) {
        self.label_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_value(&mut self, v: ::protobuf::RepeatedField<LabelValue>) {
        self.label_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_value(&mut self) -> &mut ::protobuf::RepeatedField<LabelValue> {
        &mut self.label_value
    }

    // Take field
    pub fn take_label_value(&mut self) -> ::protobuf::RepeatedField<LabelValue> {
        ::std::mem::replace(&mut self.label_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_value(&self) -> &[LabelValue] {
        &self.label_value
    }

    // repeated .maxgraph.PathValue path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::RepeatedField<PathValue>) {
        self.path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::protobuf::RepeatedField<PathValue> {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::RepeatedField<PathValue> {
        ::std::mem::replace(&mut self.path, ::protobuf::RepeatedField::new())
    }

    pub fn get_path(&self) -> &[PathValue] {
        &self.path
    }
}

impl ::protobuf::Message for Map {
    fn is_initialized(&self) -> bool {
        for v in &self.entry_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.path {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry_list)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_value)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.label_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.path {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.label_value {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.path {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Map {
        Map::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Entry>>(
                    "entry_list",
                    |m: &Map| { &m.entry_list },
                    |m: &mut Map| { &mut m.entry_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelValue>>(
                    "label_value",
                    |m: &Map| { &m.label_value },
                    |m: &mut Map| { &mut m.label_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathValue>>(
                    "path",
                    |m: &Map| { &m.path },
                    |m: &mut Map| { &mut m.path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Map>(
                    "Map",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Map {
        static mut instance: ::protobuf::lazy::Lazy<Map> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Map,
        };
        unsafe {
            instance.get(Map::new)
        }
    }
}

impl ::protobuf::Clear for Map {
    fn clear(&mut self) {
        self.clear_entry_list();
        self.clear_label_value();
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Map {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Map {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Value {
    // message fields
    pub index: i32,
    pub int_value: i32,
    pub long_value: i64,
    pub float_value: f32,
    pub double_value: f64,
    pub bool_value: bool,
    pub str_value: ::std::string::String,
    pub int_value_list: ::std::vec::Vec<i32>,
    pub long_value_list: ::std::vec::Vec<i64>,
    pub str_value_list: ::protobuf::RepeatedField<::std::string::String>,
    pub payload: ::std::vec::Vec<u8>,
    pub value_type: VariantType,
    pub path_out_value: ::protobuf::RepeatedField<PathOutValue>,
    pub bool_flag: bool,
    pub order_flag: bool,
    pub subquery_flag: bool,
    pub dedup_local_flag: bool,
    pub exec_local_disable: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    // int32 index = 1;

    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    pub fn get_index(&self) -> i32 {
        self.index
    }

    // int32 int_value = 2;

    pub fn clear_int_value(&mut self) {
        self.int_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i32) {
        self.int_value = v;
    }

    pub fn get_int_value(&self) -> i32 {
        self.int_value
    }

    // int64 long_value = 3;

    pub fn clear_long_value(&mut self) {
        self.long_value = 0;
    }

    // Param is passed by value, moved
    pub fn set_long_value(&mut self, v: i64) {
        self.long_value = v;
    }

    pub fn get_long_value(&self) -> i64 {
        self.long_value
    }

    // float float_value = 4;

    pub fn clear_float_value(&mut self) {
        self.float_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = v;
    }

    pub fn get_float_value(&self) -> f32 {
        self.float_value
    }

    // double double_value = 5;

    pub fn clear_double_value(&mut self) {
        self.double_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = v;
    }

    pub fn get_double_value(&self) -> f64 {
        self.double_value
    }

    // bool bool_value = 6;

    pub fn clear_bool_value(&mut self) {
        self.bool_value = false;
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.bool_value = v;
    }

    pub fn get_bool_value(&self) -> bool {
        self.bool_value
    }

    // string str_value = 7;

    pub fn clear_str_value(&mut self) {
        self.str_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_str_value(&mut self, v: ::std::string::String) {
        self.str_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_str_value(&mut self) -> &mut ::std::string::String {
        &mut self.str_value
    }

    // Take field
    pub fn take_str_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.str_value, ::std::string::String::new())
    }

    pub fn get_str_value(&self) -> &str {
        &self.str_value
    }

    // repeated int32 int_value_list = 8;

    pub fn clear_int_value_list(&mut self) {
        self.int_value_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_int_value_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.int_value_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int_value_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.int_value_list
    }

    // Take field
    pub fn take_int_value_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.int_value_list, ::std::vec::Vec::new())
    }

    pub fn get_int_value_list(&self) -> &[i32] {
        &self.int_value_list
    }

    // repeated int64 long_value_list = 9;

    pub fn clear_long_value_list(&mut self) {
        self.long_value_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_long_value_list(&mut self, v: ::std::vec::Vec<i64>) {
        self.long_value_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_long_value_list(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.long_value_list
    }

    // Take field
    pub fn take_long_value_list(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.long_value_list, ::std::vec::Vec::new())
    }

    pub fn get_long_value_list(&self) -> &[i64] {
        &self.long_value_list
    }

    // repeated string str_value_list = 10;

    pub fn clear_str_value_list(&mut self) {
        self.str_value_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_str_value_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.str_value_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_str_value_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.str_value_list
    }

    // Take field
    pub fn take_str_value_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.str_value_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_str_value_list(&self) -> &[::std::string::String] {
        &self.str_value_list
    }

    // bytes payload = 11;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }

    // .maxgraph.VariantType value_type = 12;

    pub fn clear_value_type(&mut self) {
        self.value_type = VariantType::VT_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: VariantType) {
        self.value_type = v;
    }

    pub fn get_value_type(&self) -> VariantType {
        self.value_type
    }

    // repeated .maxgraph.PathOutValue path_out_value = 13;

    pub fn clear_path_out_value(&mut self) {
        self.path_out_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_out_value(&mut self, v: ::protobuf::RepeatedField<PathOutValue>) {
        self.path_out_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path_out_value(&mut self) -> &mut ::protobuf::RepeatedField<PathOutValue> {
        &mut self.path_out_value
    }

    // Take field
    pub fn take_path_out_value(&mut self) -> ::protobuf::RepeatedField<PathOutValue> {
        ::std::mem::replace(&mut self.path_out_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_path_out_value(&self) -> &[PathOutValue] {
        &self.path_out_value
    }

    // bool bool_flag = 14;

    pub fn clear_bool_flag(&mut self) {
        self.bool_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_bool_flag(&mut self, v: bool) {
        self.bool_flag = v;
    }

    pub fn get_bool_flag(&self) -> bool {
        self.bool_flag
    }

    // bool order_flag = 15;

    pub fn clear_order_flag(&mut self) {
        self.order_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_order_flag(&mut self, v: bool) {
        self.order_flag = v;
    }

    pub fn get_order_flag(&self) -> bool {
        self.order_flag
    }

    // bool subquery_flag = 16;

    pub fn clear_subquery_flag(&mut self) {
        self.subquery_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_subquery_flag(&mut self, v: bool) {
        self.subquery_flag = v;
    }

    pub fn get_subquery_flag(&self) -> bool {
        self.subquery_flag
    }

    // bool dedup_local_flag = 17;

    pub fn clear_dedup_local_flag(&mut self) {
        self.dedup_local_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_dedup_local_flag(&mut self, v: bool) {
        self.dedup_local_flag = v;
    }

    pub fn get_dedup_local_flag(&self) -> bool {
        self.dedup_local_flag
    }

    // bool exec_local_disable = 18;

    pub fn clear_exec_local_disable(&mut self) {
        self.exec_local_disable = false;
    }

    // Param is passed by value, moved
    pub fn set_exec_local_disable(&mut self, v: bool) {
        self.exec_local_disable = v;
    }

    pub fn get_exec_local_disable(&self) -> bool {
        self.exec_local_disable
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        for v in &self.path_out_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.int_value = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.long_value = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_value = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.double_value = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_value = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.str_value)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.int_value_list)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.long_value_list)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.str_value_list)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value_type, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path_out_value)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_flag = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.order_flag = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.subquery_flag = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dedup_local_flag = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exec_local_disable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.int_value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.int_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.long_value != 0 {
            my_size += ::protobuf::rt::value_size(3, self.long_value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.float_value != 0. {
            my_size += 5;
        }
        if self.double_value != 0. {
            my_size += 9;
        }
        if self.bool_value != false {
            my_size += 2;
        }
        if !self.str_value.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.str_value);
        }
        for value in &self.int_value_list {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.long_value_list {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.str_value_list {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.payload);
        }
        if self.value_type != VariantType::VT_BOOL {
            my_size += ::protobuf::rt::enum_size(12, self.value_type);
        }
        for value in &self.path_out_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.bool_flag != false {
            my_size += 2;
        }
        if self.order_flag != false {
            my_size += 2;
        }
        if self.subquery_flag != false {
            my_size += 3;
        }
        if self.dedup_local_flag != false {
            my_size += 3;
        }
        if self.exec_local_disable != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int32(1, self.index)?;
        }
        if self.int_value != 0 {
            os.write_int32(2, self.int_value)?;
        }
        if self.long_value != 0 {
            os.write_int64(3, self.long_value)?;
        }
        if self.float_value != 0. {
            os.write_float(4, self.float_value)?;
        }
        if self.double_value != 0. {
            os.write_double(5, self.double_value)?;
        }
        if self.bool_value != false {
            os.write_bool(6, self.bool_value)?;
        }
        if !self.str_value.is_empty() {
            os.write_string(7, &self.str_value)?;
        }
        for v in &self.int_value_list {
            os.write_int32(8, *v)?;
        };
        for v in &self.long_value_list {
            os.write_int64(9, *v)?;
        };
        for v in &self.str_value_list {
            os.write_string(10, &v)?;
        };
        if !self.payload.is_empty() {
            os.write_bytes(11, &self.payload)?;
        }
        if self.value_type != VariantType::VT_BOOL {
            os.write_enum(12, self.value_type.value())?;
        }
        for v in &self.path_out_value {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.bool_flag != false {
            os.write_bool(14, self.bool_flag)?;
        }
        if self.order_flag != false {
            os.write_bool(15, self.order_flag)?;
        }
        if self.subquery_flag != false {
            os.write_bool(16, self.subquery_flag)?;
        }
        if self.dedup_local_flag != false {
            os.write_bool(17, self.dedup_local_flag)?;
        }
        if self.exec_local_disable != false {
            os.write_bool(18, self.exec_local_disable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Value {
        Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &Value| { &m.index },
                    |m: &mut Value| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int_value",
                    |m: &Value| { &m.int_value },
                    |m: &mut Value| { &mut m.int_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "long_value",
                    |m: &Value| { &m.long_value },
                    |m: &mut Value| { &mut m.long_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "float_value",
                    |m: &Value| { &m.float_value },
                    |m: &mut Value| { &mut m.float_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "double_value",
                    |m: &Value| { &m.double_value },
                    |m: &mut Value| { &mut m.double_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bool_value",
                    |m: &Value| { &m.bool_value },
                    |m: &mut Value| { &mut m.bool_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "str_value",
                    |m: &Value| { &m.str_value },
                    |m: &mut Value| { &mut m.str_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "int_value_list",
                    |m: &Value| { &m.int_value_list },
                    |m: &mut Value| { &mut m.int_value_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "long_value_list",
                    |m: &Value| { &m.long_value_list },
                    |m: &mut Value| { &mut m.long_value_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "str_value_list",
                    |m: &Value| { &m.str_value_list },
                    |m: &mut Value| { &mut m.str_value_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &Value| { &m.payload },
                    |m: &mut Value| { &mut m.payload },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VariantType>>(
                    "value_type",
                    |m: &Value| { &m.value_type },
                    |m: &mut Value| { &mut m.value_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathOutValue>>(
                    "path_out_value",
                    |m: &Value| { &m.path_out_value },
                    |m: &mut Value| { &mut m.path_out_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "bool_flag",
                    |m: &Value| { &m.bool_flag },
                    |m: &mut Value| { &mut m.bool_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "order_flag",
                    |m: &Value| { &m.order_flag },
                    |m: &mut Value| { &mut m.order_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "subquery_flag",
                    |m: &Value| { &m.subquery_flag },
                    |m: &mut Value| { &mut m.subquery_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "dedup_local_flag",
                    |m: &Value| { &m.dedup_local_flag },
                    |m: &mut Value| { &mut m.dedup_local_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "exec_local_disable",
                    |m: &Value| { &m.exec_local_disable },
                    |m: &mut Value| { &mut m.exec_local_disable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value>(
                    "Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Value {
        static mut instance: ::protobuf::lazy::Lazy<Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value,
        };
        unsafe {
            instance.get(Value::new)
        }
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.clear_index();
        self.clear_int_value();
        self.clear_long_value();
        self.clear_float_value();
        self.clear_double_value();
        self.clear_bool_value();
        self.clear_str_value();
        self.clear_int_value_list();
        self.clear_long_value_list();
        self.clear_str_value_list();
        self.clear_payload();
        self.clear_value_type();
        self.clear_path_out_value();
        self.clear_bool_flag();
        self.clear_order_flag();
        self.clear_subquery_flag();
        self.clear_dedup_local_flag();
        self.clear_exec_local_disable();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Value {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryResponse {
    // message fields
    pub value: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub error_code: i32,
    pub message: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl QueryResponse {
    pub fn new() -> QueryResponse {
        ::std::default::Default::default()
    }

    // repeated bytes value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }

    pub fn get_value(&self) -> &[::std::vec::Vec<u8>] {
        &self.value
    }

    // int32 error_code = 2;

    pub fn clear_error_code(&mut self) {
        self.error_code = 0;
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: i32) {
        self.error_code = v;
    }

    pub fn get_error_code(&self) -> i32 {
        self.error_code
    }

    // string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for QueryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.error_code = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if self.error_code != 0 {
            my_size += ::protobuf::rt::value_size(2, self.error_code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_bytes(1, &v)?;
        };
        if self.error_code != 0 {
            os.write_int32(2, self.error_code)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryResponse {
        QueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &QueryResponse| { &m.value },
                    |m: &mut QueryResponse| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "error_code",
                    |m: &QueryResponse| { &m.error_code },
                    |m: &mut QueryResponse| { &mut m.error_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &QueryResponse| { &m.message },
                    |m: &mut QueryResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QueryResponse>(
                    "QueryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static QueryResponse {
        static mut instance: ::protobuf::lazy::Lazy<QueryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QueryResponse,
        };
        unsafe {
            instance.get(QueryResponse::new)
        }
    }
}

impl ::protobuf::Clear for QueryResponse {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_error_code();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListInt {
    // message fields
    pub value: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListInt {
    pub fn new() -> ListInt {
        ::std::default::Default::default()
    }

    // repeated int32 value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<i32>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[i32] {
        &self.value
    }
}

impl ::protobuf::Message for ListInt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListInt {
        ListInt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &ListInt| { &m.value },
                    |m: &mut ListInt| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListInt>(
                    "ListInt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListInt {
        static mut instance: ::protobuf::lazy::Lazy<ListInt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListInt,
        };
        unsafe {
            instance.get(ListInt::new)
        }
    }
}

impl ::protobuf::Clear for ListInt {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListInt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListLong {
    // message fields
    pub value: ::std::vec::Vec<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListLong {
    pub fn new() -> ListLong {
        ::std::default::Default::default()
    }

    // repeated int64 value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<i64>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[i64] {
        &self.value
    }
}

impl ::protobuf::Message for ListLong {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListLong {
        ListLong::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "value",
                    |m: &ListLong| { &m.value },
                    |m: &mut ListLong| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListLong>(
                    "ListLong",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListLong {
        static mut instance: ::protobuf::lazy::Lazy<ListLong> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListLong,
        };
        unsafe {
            instance.get(ListLong::new)
        }
    }
}

impl ::protobuf::Clear for ListLong {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListLong {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListLong {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListString {
    // message fields
    pub value: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListString {
    pub fn new() -> ListString {
        ::std::default::Default::default()
    }

    // repeated string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }

    pub fn get_value(&self) -> &[::std::string::String] {
        &self.value
    }
}

impl ::protobuf::Message for ListString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListString {
        ListString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    |m: &ListString| { &m.value },
                    |m: &mut ListString| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListString>(
                    "ListString",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListString {
        static mut instance: ::protobuf::lazy::Lazy<ListString> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListString,
        };
        unsafe {
            instance.get(ListString::new)
        }
    }
}

impl ::protobuf::Clear for ListString {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListString {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListFloat {
    // message fields
    pub value: ::std::vec::Vec<f32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListFloat {
    pub fn new() -> ListFloat {
        ::std::default::Default::default()
    }

    // repeated float value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<f32>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[f32] {
        &self.value
    }
}

impl ::protobuf::Message for ListFloat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.value.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListFloat {
        ListFloat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "value",
                    |m: &ListFloat| { &m.value },
                    |m: &mut ListFloat| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListFloat>(
                    "ListFloat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListFloat {
        static mut instance: ::protobuf::lazy::Lazy<ListFloat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListFloat,
        };
        unsafe {
            instance.get(ListFloat::new)
        }
    }
}

impl ::protobuf::Clear for ListFloat {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListFloat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListFloat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDouble {
    // message fields
    pub value: ::std::vec::Vec<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListDouble {
    pub fn new() -> ListDouble {
        ::std::default::Default::default()
    }

    // repeated double value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<f64>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[f64] {
        &self.value
    }
}

impl ::protobuf::Message for ListDouble {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.value.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_double(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDouble {
        ListDouble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "value",
                    |m: &ListDouble| { &m.value },
                    |m: &mut ListDouble| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDouble>(
                    "ListDouble",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDouble {
        static mut instance: ::protobuf::lazy::Lazy<ListDouble> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDouble,
        };
        unsafe {
            instance.get(ListDouble::new)
        }
    }
}

impl ::protobuf::Clear for ListDouble {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDouble {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListBinary {
    // message fields
    pub value: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListBinary {
    pub fn new() -> ListBinary {
        ::std::default::Default::default()
    }

    // repeated bytes value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }

    pub fn get_value(&self) -> &[::std::vec::Vec<u8>] {
        &self.value
    }
}

impl ::protobuf::Message for ListBinary {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListBinary {
        ListBinary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &ListBinary| { &m.value },
                    |m: &mut ListBinary| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListBinary>(
                    "ListBinary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListBinary {
        static mut instance: ::protobuf::lazy::Lazy<ListBinary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListBinary,
        };
        unsafe {
            instance.get(ListBinary::new)
        }
    }
}

impl ::protobuf::Clear for ListBinary {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListBinary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListBinary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathOutValue {
    // message fields
    pub path_out_type: PathOutType,
    pub path_prop_id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PathOutValue {
    pub fn new() -> PathOutValue {
        ::std::default::Default::default()
    }

    // .maxgraph.PathOutType path_out_type = 1;

    pub fn clear_path_out_type(&mut self) {
        self.path_out_type = PathOutType::PATH_VALUE;
    }

    // Param is passed by value, moved
    pub fn set_path_out_type(&mut self, v: PathOutType) {
        self.path_out_type = v;
    }

    pub fn get_path_out_type(&self) -> PathOutType {
        self.path_out_type
    }

    // int32 path_prop_id = 2;

    pub fn clear_path_prop_id(&mut self) {
        self.path_prop_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_path_prop_id(&mut self, v: i32) {
        self.path_prop_id = v;
    }

    pub fn get_path_prop_id(&self) -> i32 {
        self.path_prop_id
    }
}

impl ::protobuf::Message for PathOutValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.path_out_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.path_prop_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.path_out_type != PathOutType::PATH_VALUE {
            my_size += ::protobuf::rt::enum_size(1, self.path_out_type);
        }
        if self.path_prop_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.path_prop_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.path_out_type != PathOutType::PATH_VALUE {
            os.write_enum(1, self.path_out_type.value())?;
        }
        if self.path_prop_id != 0 {
            os.write_int32(2, self.path_prop_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathOutValue {
        PathOutValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PathOutType>>(
                    "path_out_type",
                    |m: &PathOutValue| { &m.path_out_type },
                    |m: &mut PathOutValue| { &mut m.path_out_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "path_prop_id",
                    |m: &PathOutValue| { &m.path_prop_id },
                    |m: &mut PathOutValue| { &mut m.path_prop_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PathOutValue>(
                    "PathOutValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PathOutValue {
        static mut instance: ::protobuf::lazy::Lazy<PathOutValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PathOutValue,
        };
        unsafe {
            instance.get(PathOutValue::new)
        }
    }
}

impl ::protobuf::Clear for PathOutValue {
    fn clear(&mut self) {
        self.clear_path_out_type();
        self.clear_path_prop_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathOutValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathOutValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OrderComparator {
    // message fields
    pub prop_id: i32,
    pub order_type: OrderType,
    pub prop_type: VariantType,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OrderComparator {
    pub fn new() -> OrderComparator {
        ::std::default::Default::default()
    }

    // int32 prop_id = 1;

    pub fn clear_prop_id(&mut self) {
        self.prop_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_prop_id(&mut self, v: i32) {
        self.prop_id = v;
    }

    pub fn get_prop_id(&self) -> i32 {
        self.prop_id
    }

    // .maxgraph.OrderType order_type = 2;

    pub fn clear_order_type(&mut self) {
        self.order_type = OrderType::INCR;
    }

    // Param is passed by value, moved
    pub fn set_order_type(&mut self, v: OrderType) {
        self.order_type = v;
    }

    pub fn get_order_type(&self) -> OrderType {
        self.order_type
    }

    // .maxgraph.VariantType prop_type = 3;

    pub fn clear_prop_type(&mut self) {
        self.prop_type = VariantType::VT_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_prop_type(&mut self, v: VariantType) {
        self.prop_type = v;
    }

    pub fn get_prop_type(&self) -> VariantType {
        self.prop_type
    }
}

impl ::protobuf::Message for OrderComparator {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.prop_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.order_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.prop_type, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.prop_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.prop_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.order_type != OrderType::INCR {
            my_size += ::protobuf::rt::enum_size(2, self.order_type);
        }
        if self.prop_type != VariantType::VT_BOOL {
            my_size += ::protobuf::rt::enum_size(3, self.prop_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.prop_id != 0 {
            os.write_int32(1, self.prop_id)?;
        }
        if self.order_type != OrderType::INCR {
            os.write_enum(2, self.order_type.value())?;
        }
        if self.prop_type != VariantType::VT_BOOL {
            os.write_enum(3, self.prop_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderComparator {
        OrderComparator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_id",
                    |m: &OrderComparator| { &m.prop_id },
                    |m: &mut OrderComparator| { &mut m.prop_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OrderType>>(
                    "order_type",
                    |m: &OrderComparator| { &m.order_type },
                    |m: &mut OrderComparator| { &mut m.order_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VariantType>>(
                    "prop_type",
                    |m: &OrderComparator| { &m.prop_type },
                    |m: &mut OrderComparator| { &mut m.prop_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OrderComparator>(
                    "OrderComparator",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OrderComparator {
        static mut instance: ::protobuf::lazy::Lazy<OrderComparator> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OrderComparator,
        };
        unsafe {
            instance.get(OrderComparator::new)
        }
    }
}

impl ::protobuf::Clear for OrderComparator {
    fn clear(&mut self) {
        self.clear_prop_id();
        self.clear_order_type();
        self.clear_prop_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OrderComparator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderComparator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OrderComparatorList {
    // message fields
    pub order_comparator: ::protobuf::RepeatedField<OrderComparator>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OrderComparatorList {
    pub fn new() -> OrderComparatorList {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.OrderComparator order_comparator = 1;

    pub fn clear_order_comparator(&mut self) {
        self.order_comparator.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_comparator(&mut self, v: ::protobuf::RepeatedField<OrderComparator>) {
        self.order_comparator = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_comparator(&mut self) -> &mut ::protobuf::RepeatedField<OrderComparator> {
        &mut self.order_comparator
    }

    // Take field
    pub fn take_order_comparator(&mut self) -> ::protobuf::RepeatedField<OrderComparator> {
        ::std::mem::replace(&mut self.order_comparator, ::protobuf::RepeatedField::new())
    }

    pub fn get_order_comparator(&self) -> &[OrderComparator] {
        &self.order_comparator
    }
}

impl ::protobuf::Message for OrderComparatorList {
    fn is_initialized(&self) -> bool {
        for v in &self.order_comparator {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.order_comparator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.order_comparator {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.order_comparator {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OrderComparatorList {
        OrderComparatorList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OrderComparator>>(
                    "order_comparator",
                    |m: &OrderComparatorList| { &m.order_comparator },
                    |m: &mut OrderComparatorList| { &mut m.order_comparator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OrderComparatorList>(
                    "OrderComparatorList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OrderComparatorList {
        static mut instance: ::protobuf::lazy::Lazy<OrderComparatorList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OrderComparatorList,
        };
        unsafe {
            instance.get(OrderComparatorList::new)
        }
    }
}

impl ::protobuf::Clear for OrderComparatorList {
    fn clear(&mut self) {
        self.clear_order_comparator();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OrderComparatorList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderComparatorList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CountMap {
    // message fields
    pub int_map: ::std::collections::HashMap<i32, i32>,
    pub long_map: ::std::collections::HashMap<i64, i32>,
    pub string_map: ::std::collections::HashMap<::std::string::String, i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CountMap {
    pub fn new() -> CountMap {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.CountMap.IntMapEntry int_map = 1;

    pub fn clear_int_map(&mut self) {
        self.int_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_int_map(&mut self, v: ::std::collections::HashMap<i32, i32>) {
        self.int_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int_map(&mut self) -> &mut ::std::collections::HashMap<i32, i32> {
        &mut self.int_map
    }

    // Take field
    pub fn take_int_map(&mut self) -> ::std::collections::HashMap<i32, i32> {
        ::std::mem::replace(&mut self.int_map, ::std::collections::HashMap::new())
    }

    pub fn get_int_map(&self) -> &::std::collections::HashMap<i32, i32> {
        &self.int_map
    }

    // repeated .maxgraph.CountMap.LongMapEntry long_map = 2;

    pub fn clear_long_map(&mut self) {
        self.long_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_long_map(&mut self, v: ::std::collections::HashMap<i64, i32>) {
        self.long_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_long_map(&mut self) -> &mut ::std::collections::HashMap<i64, i32> {
        &mut self.long_map
    }

    // Take field
    pub fn take_long_map(&mut self) -> ::std::collections::HashMap<i64, i32> {
        ::std::mem::replace(&mut self.long_map, ::std::collections::HashMap::new())
    }

    pub fn get_long_map(&self) -> &::std::collections::HashMap<i64, i32> {
        &self.long_map
    }

    // repeated .maxgraph.CountMap.StringMapEntry string_map = 3;

    pub fn clear_string_map(&mut self) {
        self.string_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_map(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.string_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_map(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.string_map
    }

    // Take field
    pub fn take_string_map(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.string_map, ::std::collections::HashMap::new())
    }

    pub fn get_string_map(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.string_map
    }
}

impl ::protobuf::Message for CountMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.int_map)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.long_map)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.string_map)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(1, &self.int_map);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(2, &self.long_map);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(3, &self.string_map);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(1, &self.int_map, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(2, &self.long_map, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(3, &self.string_map, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountMap {
        CountMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt32>(
                    "int_map",
                    |m: &CountMap| { &m.int_map },
                    |m: &mut CountMap| { &mut m.int_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(
                    "long_map",
                    |m: &CountMap| { &m.long_map },
                    |m: &mut CountMap| { &mut m.long_map },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                    "string_map",
                    |m: &CountMap| { &m.string_map },
                    |m: &mut CountMap| { &mut m.string_map },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CountMap>(
                    "CountMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CountMap {
        static mut instance: ::protobuf::lazy::Lazy<CountMap> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CountMap,
        };
        unsafe {
            instance.get(CountMap::new)
        }
    }
}

impl ::protobuf::Clear for CountMap {
    fn clear(&mut self) {
        self.clear_int_map();
        self.clear_long_map();
        self.clear_string_map();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountMap {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperationResponse {
    // message fields
    pub success: bool,
    pub message: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl OperationResponse {
    pub fn new() -> OperationResponse {
        ::std::default::Default::default()
    }

    // bool success = 1;

    pub fn clear_success(&mut self) {
        self.success = false;
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = v;
    }

    pub fn get_success(&self) -> bool {
        self.success
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }
}

impl ::protobuf::Message for OperationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.success = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 2;
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperationResponse {
        OperationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "success",
                    |m: &OperationResponse| { &m.success },
                    |m: &mut OperationResponse| { &mut m.success },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &OperationResponse| { &m.message },
                    |m: &mut OperationResponse| { &mut m.message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OperationResponse>(
                    "OperationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OperationResponse {
        static mut instance: ::protobuf::lazy::Lazy<OperationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OperationResponse,
        };
        unsafe {
            instance.get(OperationResponse::new)
        }
    }
}

impl ::protobuf::Clear for OperationResponse {
    fn clear(&mut self) {
        self.clear_success();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoveDataflowRequest {
    // message fields
    pub dataflow_id: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RemoveDataflowRequest {
    pub fn new() -> RemoveDataflowRequest {
        ::std::default::Default::default()
    }

    // string dataflow_id = 1;

    pub fn clear_dataflow_id(&mut self) {
        self.dataflow_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataflow_id(&mut self, v: ::std::string::String) {
        self.dataflow_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataflow_id(&mut self) -> &mut ::std::string::String {
        &mut self.dataflow_id
    }

    // Take field
    pub fn take_dataflow_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataflow_id, ::std::string::String::new())
    }

    pub fn get_dataflow_id(&self) -> &str {
        &self.dataflow_id
    }
}

impl ::protobuf::Message for RemoveDataflowRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataflow_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataflow_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataflow_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.dataflow_id.is_empty() {
            os.write_string(1, &self.dataflow_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoveDataflowRequest {
        RemoveDataflowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dataflow_id",
                    |m: &RemoveDataflowRequest| { &m.dataflow_id },
                    |m: &mut RemoveDataflowRequest| { &mut m.dataflow_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemoveDataflowRequest>(
                    "RemoveDataflowRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemoveDataflowRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemoveDataflowRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemoveDataflowRequest,
        };
        unsafe {
            instance.get(RemoveDataflowRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemoveDataflowRequest {
    fn clear(&mut self) {
        self.clear_dataflow_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoveDataflowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveDataflowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimelyMessage {
    // message fields
    pub id: i64,
    pub class_type: ClassType,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TimelyMessage {
    pub fn new() -> TimelyMessage {
        ::std::default::Default::default()
    }

    // int64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }

    // .maxgraph.ClassType class_type = 2;

    pub fn clear_class_type(&mut self) {
        self.class_type = ClassType::VERTEX;
    }

    // Param is passed by value, moved
    pub fn set_class_type(&mut self, v: ClassType) {
        self.class_type = v;
    }

    pub fn get_class_type(&self) -> ClassType {
        self.class_type
    }

    // bytes payload = 3;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
}

impl ::protobuf::Message for TimelyMessage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.class_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.class_type != ClassType::VERTEX {
            my_size += ::protobuf::rt::enum_size(2, self.class_type);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if self.class_type != ClassType::VERTEX {
            os.write_enum(2, self.class_type.value())?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(3, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimelyMessage {
        TimelyMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &TimelyMessage| { &m.id },
                    |m: &mut TimelyMessage| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClassType>>(
                    "class_type",
                    |m: &TimelyMessage| { &m.class_type },
                    |m: &mut TimelyMessage| { &mut m.class_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &TimelyMessage| { &m.payload },
                    |m: &mut TimelyMessage| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimelyMessage>(
                    "TimelyMessage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimelyMessage {
        static mut instance: ::protobuf::lazy::Lazy<TimelyMessage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimelyMessage,
        };
        unsafe {
            instance.get(TimelyMessage::new)
        }
    }
}

impl ::protobuf::Clear for TimelyMessage {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_class_type();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimelyMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimelyMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ColumnLogicalCompare {
    // message fields
    pub column_name: ::std::string::String,
    pub compare: CompareType,
    pub value: ::protobuf::SingularPtrField<Value>,
    pub field_type: VariantType,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ColumnLogicalCompare {
    pub fn new() -> ColumnLogicalCompare {
        ::std::default::Default::default()
    }

    // string column_name = 1;

    pub fn clear_column_name(&mut self) {
        self.column_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_name(&mut self, v: ::std::string::String) {
        self.column_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_column_name(&mut self) -> &mut ::std::string::String {
        &mut self.column_name
    }

    // Take field
    pub fn take_column_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.column_name, ::std::string::String::new())
    }

    pub fn get_column_name(&self) -> &str {
        &self.column_name
    }

    // .maxgraph.CompareType compare = 2;

    pub fn clear_compare(&mut self) {
        self.compare = CompareType::GT;
    }

    // Param is passed by value, moved
    pub fn set_compare(&mut self, v: CompareType) {
        self.compare = v;
    }

    pub fn get_compare(&self) -> CompareType {
        self.compare
    }

    // .maxgraph.Value value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Value {
        self.value.take().unwrap_or_else(|| Value::new())
    }

    pub fn get_value(&self) -> &Value {
        self.value.as_ref().unwrap_or_else(|| Value::default_instance())
    }

    // .maxgraph.VariantType type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = VariantType::VT_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: VariantType) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> VariantType {
        self.field_type
    }
}

impl ::protobuf::Message for ColumnLogicalCompare {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.column_name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.compare, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.column_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.column_name);
        }
        if self.compare != CompareType::GT {
            my_size += ::protobuf::rt::enum_size(2, self.compare);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != VariantType::VT_BOOL {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.column_name.is_empty() {
            os.write_string(1, &self.column_name)?;
        }
        if self.compare != CompareType::GT {
            os.write_enum(2, self.compare.value())?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != VariantType::VT_BOOL {
            os.write_enum(4, self.field_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ColumnLogicalCompare {
        ColumnLogicalCompare::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "column_name",
                    |m: &ColumnLogicalCompare| { &m.column_name },
                    |m: &mut ColumnLogicalCompare| { &mut m.column_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompareType>>(
                    "compare",
                    |m: &ColumnLogicalCompare| { &m.compare },
                    |m: &mut ColumnLogicalCompare| { &mut m.compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "value",
                    |m: &ColumnLogicalCompare| { &m.value },
                    |m: &mut ColumnLogicalCompare| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VariantType>>(
                    "type",
                    |m: &ColumnLogicalCompare| { &m.field_type },
                    |m: &mut ColumnLogicalCompare| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ColumnLogicalCompare>(
                    "ColumnLogicalCompare",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ColumnLogicalCompare {
        static mut instance: ::protobuf::lazy::Lazy<ColumnLogicalCompare> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ColumnLogicalCompare,
        };
        unsafe {
            instance.get(ColumnLogicalCompare::new)
        }
    }
}

impl ::protobuf::Clear for ColumnLogicalCompare {
    fn clear(&mut self) {
        self.clear_column_name();
        self.clear_compare();
        self.clear_value();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ColumnLogicalCompare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ColumnLogicalCompare {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogicalCompare {
    // message fields
    pub prop_id: i32,
    pub compare: CompareType,
    pub value: ::protobuf::SingularPtrField<Value>,
    pub field_type: VariantType,
    pub index: i32,
    pub child_compare_list: ::protobuf::RepeatedField<LogicalCompare>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LogicalCompare {
    pub fn new() -> LogicalCompare {
        ::std::default::Default::default()
    }

    // int32 prop_id = 1;

    pub fn clear_prop_id(&mut self) {
        self.prop_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_prop_id(&mut self, v: i32) {
        self.prop_id = v;
    }

    pub fn get_prop_id(&self) -> i32 {
        self.prop_id
    }

    // .maxgraph.CompareType compare = 2;

    pub fn clear_compare(&mut self) {
        self.compare = CompareType::GT;
    }

    // Param is passed by value, moved
    pub fn set_compare(&mut self, v: CompareType) {
        self.compare = v;
    }

    pub fn get_compare(&self) -> CompareType {
        self.compare
    }

    // .maxgraph.Value value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Value {
        self.value.take().unwrap_or_else(|| Value::new())
    }

    pub fn get_value(&self) -> &Value {
        self.value.as_ref().unwrap_or_else(|| Value::default_instance())
    }

    // .maxgraph.VariantType type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type = VariantType::VT_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: VariantType) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> VariantType {
        self.field_type
    }

    // int32 index = 5;

    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    pub fn get_index(&self) -> i32 {
        self.index
    }

    // repeated .maxgraph.LogicalCompare child_compare_list = 6;

    pub fn clear_child_compare_list(&mut self) {
        self.child_compare_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_child_compare_list(&mut self, v: ::protobuf::RepeatedField<LogicalCompare>) {
        self.child_compare_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_child_compare_list(&mut self) -> &mut ::protobuf::RepeatedField<LogicalCompare> {
        &mut self.child_compare_list
    }

    // Take field
    pub fn take_child_compare_list(&mut self) -> ::protobuf::RepeatedField<LogicalCompare> {
        ::std::mem::replace(&mut self.child_compare_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_child_compare_list(&self) -> &[LogicalCompare] {
        &self.child_compare_list
    }
}

impl ::protobuf::Message for LogicalCompare {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child_compare_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.prop_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.compare, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.child_compare_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.prop_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.prop_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compare != CompareType::GT {
            my_size += ::protobuf::rt::enum_size(2, self.compare);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_type != VariantType::VT_BOOL {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.child_compare_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.prop_id != 0 {
            os.write_int32(1, self.prop_id)?;
        }
        if self.compare != CompareType::GT {
            os.write_enum(2, self.compare.value())?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_type != VariantType::VT_BOOL {
            os.write_enum(4, self.field_type.value())?;
        }
        if self.index != 0 {
            os.write_int32(5, self.index)?;
        }
        for v in &self.child_compare_list {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalCompare {
        LogicalCompare::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_id",
                    |m: &LogicalCompare| { &m.prop_id },
                    |m: &mut LogicalCompare| { &mut m.prop_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CompareType>>(
                    "compare",
                    |m: &LogicalCompare| { &m.compare },
                    |m: &mut LogicalCompare| { &mut m.compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "value",
                    |m: &LogicalCompare| { &m.value },
                    |m: &mut LogicalCompare| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VariantType>>(
                    "type",
                    |m: &LogicalCompare| { &m.field_type },
                    |m: &mut LogicalCompare| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &LogicalCompare| { &m.index },
                    |m: &mut LogicalCompare| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalCompare>>(
                    "child_compare_list",
                    |m: &LogicalCompare| { &m.child_compare_list },
                    |m: &mut LogicalCompare| { &mut m.child_compare_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LogicalCompare>(
                    "LogicalCompare",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LogicalCompare {
        static mut instance: ::protobuf::lazy::Lazy<LogicalCompare> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LogicalCompare,
        };
        unsafe {
            instance.get(LogicalCompare::new)
        }
    }
}

impl ::protobuf::Clear for LogicalCompare {
    fn clear(&mut self) {
        self.clear_prop_id();
        self.clear_compare();
        self.clear_value();
        self.clear_field_type();
        self.clear_index();
        self.clear_child_compare_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalCompare {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalCompare {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EdgeInput {
    // message fields
    pub project: ::std::string::String,
    pub ds: ::std::string::String,
    pub table: ::std::string::String,
    pub type_name: ::std::string::String,
    pub src_primary_key: ::std::string::String,
    pub src_type_name: ::std::string::String,
    pub dst_primary_key: ::std::string::String,
    pub dst_type_name: ::std::string::String,
    pub direction: EdgeDirection,
    pub column_name: ::protobuf::RepeatedField<::std::string::String>,
    pub logical_compare: ::protobuf::RepeatedField<ColumnLogicalCompare>,
    pub not_output_vertex_id: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EdgeInput {
    pub fn new() -> EdgeInput {
        ::std::default::Default::default()
    }

    // string project = 1;

    pub fn clear_project(&mut self) {
        self.project.clear();
    }

    // Param is passed by value, moved
    pub fn set_project(&mut self, v: ::std::string::String) {
        self.project = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project(&mut self) -> &mut ::std::string::String {
        &mut self.project
    }

    // Take field
    pub fn take_project(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project, ::std::string::String::new())
    }

    pub fn get_project(&self) -> &str {
        &self.project
    }

    // string ds = 2;

    pub fn clear_ds(&mut self) {
        self.ds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ds(&mut self, v: ::std::string::String) {
        self.ds = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ds(&mut self) -> &mut ::std::string::String {
        &mut self.ds
    }

    // Take field
    pub fn take_ds(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ds, ::std::string::String::new())
    }

    pub fn get_ds(&self) -> &str {
        &self.ds
    }

    // string table = 3;

    pub fn clear_table(&mut self) {
        self.table.clear();
    }

    // Param is passed by value, moved
    pub fn set_table(&mut self, v: ::std::string::String) {
        self.table = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_table(&mut self) -> &mut ::std::string::String {
        &mut self.table
    }

    // Take field
    pub fn take_table(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.table, ::std::string::String::new())
    }

    pub fn get_table(&self) -> &str {
        &self.table
    }

    // string type_name = 4;

    pub fn clear_type_name(&mut self) {
        self.type_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: ::std::string::String) {
        self.type_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut ::std::string::String {
        &mut self.type_name
    }

    // Take field
    pub fn take_type_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_name, ::std::string::String::new())
    }

    pub fn get_type_name(&self) -> &str {
        &self.type_name
    }

    // string src_primary_key = 5;

    pub fn clear_src_primary_key(&mut self) {
        self.src_primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_primary_key(&mut self, v: ::std::string::String) {
        self.src_primary_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_primary_key(&mut self) -> &mut ::std::string::String {
        &mut self.src_primary_key
    }

    // Take field
    pub fn take_src_primary_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_primary_key, ::std::string::String::new())
    }

    pub fn get_src_primary_key(&self) -> &str {
        &self.src_primary_key
    }

    // string src_type_name = 6;

    pub fn clear_src_type_name(&mut self) {
        self.src_type_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_type_name(&mut self, v: ::std::string::String) {
        self.src_type_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_type_name(&mut self) -> &mut ::std::string::String {
        &mut self.src_type_name
    }

    // Take field
    pub fn take_src_type_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_type_name, ::std::string::String::new())
    }

    pub fn get_src_type_name(&self) -> &str {
        &self.src_type_name
    }

    // string dst_primary_key = 7;

    pub fn clear_dst_primary_key(&mut self) {
        self.dst_primary_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_primary_key(&mut self, v: ::std::string::String) {
        self.dst_primary_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_primary_key(&mut self) -> &mut ::std::string::String {
        &mut self.dst_primary_key
    }

    // Take field
    pub fn take_dst_primary_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_primary_key, ::std::string::String::new())
    }

    pub fn get_dst_primary_key(&self) -> &str {
        &self.dst_primary_key
    }

    // string dst_type_name = 8;

    pub fn clear_dst_type_name(&mut self) {
        self.dst_type_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_type_name(&mut self, v: ::std::string::String) {
        self.dst_type_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_type_name(&mut self) -> &mut ::std::string::String {
        &mut self.dst_type_name
    }

    // Take field
    pub fn take_dst_type_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_type_name, ::std::string::String::new())
    }

    pub fn get_dst_type_name(&self) -> &str {
        &self.dst_type_name
    }

    // .maxgraph.EdgeDirection direction = 9;

    pub fn clear_direction(&mut self) {
        self.direction = EdgeDirection::DIR_OUT;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeDirection) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> EdgeDirection {
        self.direction
    }

    // repeated string column_name = 10;

    pub fn clear_column_name(&mut self) {
        self.column_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_column_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.column_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_column_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.column_name
    }

    // Take field
    pub fn take_column_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.column_name, ::protobuf::RepeatedField::new())
    }

    pub fn get_column_name(&self) -> &[::std::string::String] {
        &self.column_name
    }

    // repeated .maxgraph.ColumnLogicalCompare logical_compare = 11;

    pub fn clear_logical_compare(&mut self) {
        self.logical_compare.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_compare(&mut self, v: ::protobuf::RepeatedField<ColumnLogicalCompare>) {
        self.logical_compare = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_compare(&mut self) -> &mut ::protobuf::RepeatedField<ColumnLogicalCompare> {
        &mut self.logical_compare
    }

    // Take field
    pub fn take_logical_compare(&mut self) -> ::protobuf::RepeatedField<ColumnLogicalCompare> {
        ::std::mem::replace(&mut self.logical_compare, ::protobuf::RepeatedField::new())
    }

    pub fn get_logical_compare(&self) -> &[ColumnLogicalCompare] {
        &self.logical_compare
    }

    // bool not_output_vertex_id = 12;

    pub fn clear_not_output_vertex_id(&mut self) {
        self.not_output_vertex_id = false;
    }

    // Param is passed by value, moved
    pub fn set_not_output_vertex_id(&mut self, v: bool) {
        self.not_output_vertex_id = v;
    }

    pub fn get_not_output_vertex_id(&self) -> bool {
        self.not_output_vertex_id
    }
}

impl ::protobuf::Message for EdgeInput {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_compare {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ds)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.table)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.type_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_primary_key)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_type_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_primary_key)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_type_name)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.column_name)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_compare)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.not_output_vertex_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project);
        }
        if !self.ds.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ds);
        }
        if !self.table.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.table);
        }
        if !self.type_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.type_name);
        }
        if !self.src_primary_key.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.src_primary_key);
        }
        if !self.src_type_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.src_type_name);
        }
        if !self.dst_primary_key.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.dst_primary_key);
        }
        if !self.dst_type_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.dst_type_name);
        }
        if self.direction != EdgeDirection::DIR_OUT {
            my_size += ::protobuf::rt::enum_size(9, self.direction);
        }
        for value in &self.column_name {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in &self.logical_compare {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.not_output_vertex_id != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.project.is_empty() {
            os.write_string(1, &self.project)?;
        }
        if !self.ds.is_empty() {
            os.write_string(2, &self.ds)?;
        }
        if !self.table.is_empty() {
            os.write_string(3, &self.table)?;
        }
        if !self.type_name.is_empty() {
            os.write_string(4, &self.type_name)?;
        }
        if !self.src_primary_key.is_empty() {
            os.write_string(5, &self.src_primary_key)?;
        }
        if !self.src_type_name.is_empty() {
            os.write_string(6, &self.src_type_name)?;
        }
        if !self.dst_primary_key.is_empty() {
            os.write_string(7, &self.dst_primary_key)?;
        }
        if !self.dst_type_name.is_empty() {
            os.write_string(8, &self.dst_type_name)?;
        }
        if self.direction != EdgeDirection::DIR_OUT {
            os.write_enum(9, self.direction.value())?;
        }
        for v in &self.column_name {
            os.write_string(10, &v)?;
        };
        for v in &self.logical_compare {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.not_output_vertex_id != false {
            os.write_bool(12, self.not_output_vertex_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EdgeInput {
        EdgeInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "project",
                    |m: &EdgeInput| { &m.project },
                    |m: &mut EdgeInput| { &mut m.project },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ds",
                    |m: &EdgeInput| { &m.ds },
                    |m: &mut EdgeInput| { &mut m.ds },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "table",
                    |m: &EdgeInput| { &m.table },
                    |m: &mut EdgeInput| { &mut m.table },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type_name",
                    |m: &EdgeInput| { &m.type_name },
                    |m: &mut EdgeInput| { &mut m.type_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src_primary_key",
                    |m: &EdgeInput| { &m.src_primary_key },
                    |m: &mut EdgeInput| { &mut m.src_primary_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "src_type_name",
                    |m: &EdgeInput| { &m.src_type_name },
                    |m: &mut EdgeInput| { &mut m.src_type_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst_primary_key",
                    |m: &EdgeInput| { &m.dst_primary_key },
                    |m: &mut EdgeInput| { &mut m.dst_primary_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dst_type_name",
                    |m: &EdgeInput| { &m.dst_type_name },
                    |m: &mut EdgeInput| { &mut m.dst_type_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeDirection>>(
                    "direction",
                    |m: &EdgeInput| { &m.direction },
                    |m: &mut EdgeInput| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "column_name",
                    |m: &EdgeInput| { &m.column_name },
                    |m: &mut EdgeInput| { &mut m.column_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ColumnLogicalCompare>>(
                    "logical_compare",
                    |m: &EdgeInput| { &m.logical_compare },
                    |m: &mut EdgeInput| { &mut m.logical_compare },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "not_output_vertex_id",
                    |m: &EdgeInput| { &m.not_output_vertex_id },
                    |m: &mut EdgeInput| { &mut m.not_output_vertex_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EdgeInput>(
                    "EdgeInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EdgeInput {
        static mut instance: ::protobuf::lazy::Lazy<EdgeInput> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EdgeInput,
        };
        unsafe {
            instance.get(EdgeInput::new)
        }
    }
}

impl ::protobuf::Clear for EdgeInput {
    fn clear(&mut self) {
        self.clear_project();
        self.clear_ds();
        self.clear_table();
        self.clear_type_name();
        self.clear_src_primary_key();
        self.clear_src_type_name();
        self.clear_dst_primary_key();
        self.clear_dst_type_name();
        self.clear_direction();
        self.clear_column_name();
        self.clear_logical_compare();
        self.clear_not_output_vertex_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EdgeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeInput {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BranchOptionList {
    // message fields
    pub option_value: ::protobuf::RepeatedField<Value>,
    pub none_flag: bool,
    pub any_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BranchOptionList {
    pub fn new() -> BranchOptionList {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.Value option_value = 1;

    pub fn clear_option_value(&mut self) {
        self.option_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_option_value(&mut self, v: ::protobuf::RepeatedField<Value>) {
        self.option_value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_option_value(&mut self) -> &mut ::protobuf::RepeatedField<Value> {
        &mut self.option_value
    }

    // Take field
    pub fn take_option_value(&mut self) -> ::protobuf::RepeatedField<Value> {
        ::std::mem::replace(&mut self.option_value, ::protobuf::RepeatedField::new())
    }

    pub fn get_option_value(&self) -> &[Value] {
        &self.option_value
    }

    // bool none_flag = 2;

    pub fn clear_none_flag(&mut self) {
        self.none_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_none_flag(&mut self, v: bool) {
        self.none_flag = v;
    }

    pub fn get_none_flag(&self) -> bool {
        self.none_flag
    }

    // bool any_flag = 3;

    pub fn clear_any_flag(&mut self) {
        self.any_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_any_flag(&mut self, v: bool) {
        self.any_flag = v;
    }

    pub fn get_any_flag(&self) -> bool {
        self.any_flag
    }
}

impl ::protobuf::Message for BranchOptionList {
    fn is_initialized(&self) -> bool {
        for v in &self.option_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.option_value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.none_flag = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.any_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.option_value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.none_flag != false {
            my_size += 2;
        }
        if self.any_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.option_value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.none_flag != false {
            os.write_bool(2, self.none_flag)?;
        }
        if self.any_flag != false {
            os.write_bool(3, self.any_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BranchOptionList {
        BranchOptionList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "option_value",
                    |m: &BranchOptionList| { &m.option_value },
                    |m: &mut BranchOptionList| { &mut m.option_value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "none_flag",
                    |m: &BranchOptionList| { &m.none_flag },
                    |m: &mut BranchOptionList| { &mut m.none_flag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "any_flag",
                    |m: &BranchOptionList| { &m.any_flag },
                    |m: &mut BranchOptionList| { &mut m.any_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BranchOptionList>(
                    "BranchOptionList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BranchOptionList {
        static mut instance: ::protobuf::lazy::Lazy<BranchOptionList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BranchOptionList,
        };
        unsafe {
            instance.get(BranchOptionList::new)
        }
    }
}

impl ::protobuf::Clear for BranchOptionList {
    fn clear(&mut self) {
        self.clear_option_value();
        self.clear_none_flag();
        self.clear_any_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BranchOptionList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BranchOptionList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RawMessageProto {
    // message fields
    pub type_id: i32,
    pub id: i64,
    pub message_type: MessageType,
    pub extra: ::protobuf::SingularPtrField<ExtraMessageProto>,
    pub bulk: i64,
    pub store_id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RawMessageProto {
    pub fn new() -> RawMessageProto {
        ::std::default::Default::default()
    }

    // int32 type_id = 1;

    pub fn clear_type_id(&mut self) {
        self.type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = v;
    }

    pub fn get_type_id(&self) -> i32 {
        self.type_id
    }

    // int64 id = 2;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    pub fn get_id(&self) -> i64 {
        self.id
    }

    // .maxgraph.MessageType message_type = 3;

    pub fn clear_message_type(&mut self) {
        self.message_type = MessageType::MSG_VERTEX_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: MessageType) {
        self.message_type = v;
    }

    pub fn get_message_type(&self) -> MessageType {
        self.message_type
    }

    // .maxgraph.ExtraMessageProto extra = 4;

    pub fn clear_extra(&mut self) {
        self.extra.clear();
    }

    pub fn has_extra(&self) -> bool {
        self.extra.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra(&mut self, v: ExtraMessageProto) {
        self.extra = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra(&mut self) -> &mut ExtraMessageProto {
        if self.extra.is_none() {
            self.extra.set_default();
        }
        self.extra.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra(&mut self) -> ExtraMessageProto {
        self.extra.take().unwrap_or_else(|| ExtraMessageProto::new())
    }

    pub fn get_extra(&self) -> &ExtraMessageProto {
        self.extra.as_ref().unwrap_or_else(|| ExtraMessageProto::default_instance())
    }

    // int64 bulk = 5;

    pub fn clear_bulk(&mut self) {
        self.bulk = 0;
    }

    // Param is passed by value, moved
    pub fn set_bulk(&mut self, v: i64) {
        self.bulk = v;
    }

    pub fn get_bulk(&self) -> i64 {
        self.bulk
    }

    // int32 store_id = 6;

    pub fn clear_store_id(&mut self) {
        self.store_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_store_id(&mut self, v: i32) {
        self.store_id = v;
    }

    pub fn get_store_id(&self) -> i32 {
        self.store_id
    }
}

impl ::protobuf::Message for RawMessageProto {
    fn is_initialized(&self) -> bool {
        for v in &self.extra {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.type_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.message_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.extra)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bulk = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.store_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.type_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.message_type != MessageType::MSG_VERTEX_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.message_type);
        }
        if let Some(ref v) = self.extra.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bulk != 0 {
            my_size += ::protobuf::rt::value_size(5, self.bulk, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.store_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.store_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.type_id != 0 {
            os.write_int32(1, self.type_id)?;
        }
        if self.id != 0 {
            os.write_int64(2, self.id)?;
        }
        if self.message_type != MessageType::MSG_VERTEX_TYPE {
            os.write_enum(3, self.message_type.value())?;
        }
        if let Some(ref v) = self.extra.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bulk != 0 {
            os.write_int64(5, self.bulk)?;
        }
        if self.store_id != 0 {
            os.write_int32(6, self.store_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawMessageProto {
        RawMessageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "type_id",
                    |m: &RawMessageProto| { &m.type_id },
                    |m: &mut RawMessageProto| { &mut m.type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "id",
                    |m: &RawMessageProto| { &m.id },
                    |m: &mut RawMessageProto| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageType>>(
                    "message_type",
                    |m: &RawMessageProto| { &m.message_type },
                    |m: &mut RawMessageProto| { &mut m.message_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExtraMessageProto>>(
                    "extra",
                    |m: &RawMessageProto| { &m.extra },
                    |m: &mut RawMessageProto| { &mut m.extra },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bulk",
                    |m: &RawMessageProto| { &m.bulk },
                    |m: &mut RawMessageProto| { &mut m.bulk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "store_id",
                    |m: &RawMessageProto| { &m.store_id },
                    |m: &mut RawMessageProto| { &mut m.store_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RawMessageProto>(
                    "RawMessageProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RawMessageProto {
        static mut instance: ::protobuf::lazy::Lazy<RawMessageProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RawMessageProto,
        };
        unsafe {
            instance.get(RawMessageProto::new)
        }
    }
}

impl ::protobuf::Clear for RawMessageProto {
    fn clear(&mut self) {
        self.clear_type_id();
        self.clear_id();
        self.clear_message_type();
        self.clear_extra();
        self.clear_bulk();
        self.clear_store_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawMessageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtraEdgeEntityProto {
    // message fields
    pub src_type_id: i32,
    pub src_id: i64,
    pub dst_type_id: i32,
    pub dst_id: i64,
    pub is_out: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ExtraEdgeEntityProto {
    pub fn new() -> ExtraEdgeEntityProto {
        ::std::default::Default::default()
    }

    // int32 src_type_id = 1;

    pub fn clear_src_type_id(&mut self) {
        self.src_type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_type_id(&mut self, v: i32) {
        self.src_type_id = v;
    }

    pub fn get_src_type_id(&self) -> i32 {
        self.src_type_id
    }

    // int64 src_id = 2;

    pub fn clear_src_id(&mut self) {
        self.src_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_id(&mut self, v: i64) {
        self.src_id = v;
    }

    pub fn get_src_id(&self) -> i64 {
        self.src_id
    }

    // int32 dst_type_id = 3;

    pub fn clear_dst_type_id(&mut self) {
        self.dst_type_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_type_id(&mut self, v: i32) {
        self.dst_type_id = v;
    }

    pub fn get_dst_type_id(&self) -> i32 {
        self.dst_type_id
    }

    // int64 dst_id = 4;

    pub fn clear_dst_id(&mut self) {
        self.dst_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dst_id(&mut self, v: i64) {
        self.dst_id = v;
    }

    pub fn get_dst_id(&self) -> i64 {
        self.dst_id
    }

    // bool is_out = 5;

    pub fn clear_is_out(&mut self) {
        self.is_out = false;
    }

    // Param is passed by value, moved
    pub fn set_is_out(&mut self, v: bool) {
        self.is_out = v;
    }

    pub fn get_is_out(&self) -> bool {
        self.is_out
    }
}

impl ::protobuf::Message for ExtraEdgeEntityProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.src_type_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.src_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dst_type_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dst_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_out = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.src_type_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.src_type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.src_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_type_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dst_type_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dst_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.dst_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_out != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.src_type_id != 0 {
            os.write_int32(1, self.src_type_id)?;
        }
        if self.src_id != 0 {
            os.write_int64(2, self.src_id)?;
        }
        if self.dst_type_id != 0 {
            os.write_int32(3, self.dst_type_id)?;
        }
        if self.dst_id != 0 {
            os.write_int64(4, self.dst_id)?;
        }
        if self.is_out != false {
            os.write_bool(5, self.is_out)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtraEdgeEntityProto {
        ExtraEdgeEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "src_type_id",
                    |m: &ExtraEdgeEntityProto| { &m.src_type_id },
                    |m: &mut ExtraEdgeEntityProto| { &mut m.src_type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "src_id",
                    |m: &ExtraEdgeEntityProto| { &m.src_id },
                    |m: &mut ExtraEdgeEntityProto| { &mut m.src_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "dst_type_id",
                    |m: &ExtraEdgeEntityProto| { &m.dst_type_id },
                    |m: &mut ExtraEdgeEntityProto| { &mut m.dst_type_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "dst_id",
                    |m: &ExtraEdgeEntityProto| { &m.dst_id },
                    |m: &mut ExtraEdgeEntityProto| { &mut m.dst_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_out",
                    |m: &ExtraEdgeEntityProto| { &m.is_out },
                    |m: &mut ExtraEdgeEntityProto| { &mut m.is_out },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtraEdgeEntityProto>(
                    "ExtraEdgeEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtraEdgeEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<ExtraEdgeEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtraEdgeEntityProto,
        };
        unsafe {
            instance.get(ExtraEdgeEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for ExtraEdgeEntityProto {
    fn clear(&mut self) {
        self.clear_src_type_id();
        self.clear_src_id();
        self.clear_dst_type_id();
        self.clear_dst_id();
        self.clear_is_out();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtraEdgeEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraEdgeEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathEntityProto {
    // message fields
    pub message: ::protobuf::SingularPtrField<RawMessageProto>,
    pub label_list: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PathEntityProto {
    pub fn new() -> PathEntityProto {
        ::std::default::Default::default()
    }

    // .maxgraph.RawMessageProto message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: RawMessageProto) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut RawMessageProto {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> RawMessageProto {
        self.message.take().unwrap_or_else(|| RawMessageProto::new())
    }

    pub fn get_message(&self) -> &RawMessageProto {
        self.message.as_ref().unwrap_or_else(|| RawMessageProto::default_instance())
    }

    // repeated int32 label_list = 2;

    pub fn clear_label_list(&mut self) {
        self.label_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.label_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.label_list
    }

    // Take field
    pub fn take_label_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.label_list, ::std::vec::Vec::new())
    }

    pub fn get_label_list(&self) -> &[i32] {
        &self.label_list
    }
}

impl ::protobuf::Message for PathEntityProto {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.label_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.label_list {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.label_list {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathEntityProto {
        PathEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMessageProto>>(
                    "message",
                    |m: &PathEntityProto| { &m.message },
                    |m: &mut PathEntityProto| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_list",
                    |m: &PathEntityProto| { &m.label_list },
                    |m: &mut PathEntityProto| { &mut m.label_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PathEntityProto>(
                    "PathEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PathEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<PathEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PathEntityProto,
        };
        unsafe {
            instance.get(PathEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for PathEntityProto {
    fn clear(&mut self) {
        self.clear_message();
        self.clear_label_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelEntityProto {
    // message fields
    pub message: ::protobuf::SingularPtrField<RawMessageProto>,
    pub label_id: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl LabelEntityProto {
    pub fn new() -> LabelEntityProto {
        ::std::default::Default::default()
    }

    // .maxgraph.RawMessageProto message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: RawMessageProto) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut RawMessageProto {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> RawMessageProto {
        self.message.take().unwrap_or_else(|| RawMessageProto::new())
    }

    pub fn get_message(&self) -> &RawMessageProto {
        self.message.as_ref().unwrap_or_else(|| RawMessageProto::default_instance())
    }

    // int32 label_id = 2;

    pub fn clear_label_id(&mut self) {
        self.label_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_label_id(&mut self, v: i32) {
        self.label_id = v;
    }

    pub fn get_label_id(&self) -> i32 {
        self.label_id
    }
}

impl ::protobuf::Message for LabelEntityProto {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.label_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.label_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.label_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.label_id != 0 {
            os.write_int32(2, self.label_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelEntityProto {
        LabelEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMessageProto>>(
                    "message",
                    |m: &LabelEntityProto| { &m.message },
                    |m: &mut LabelEntityProto| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "label_id",
                    |m: &LabelEntityProto| { &m.label_id },
                    |m: &mut LabelEntityProto| { &mut m.label_id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LabelEntityProto>(
                    "LabelEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LabelEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<LabelEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LabelEntityProto,
        };
        unsafe {
            instance.get(LabelEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for LabelEntityProto {
    fn clear(&mut self) {
        self.clear_message();
        self.clear_label_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathEntityListProto {
    // message fields
    pub path_val_list: ::protobuf::RepeatedField<PathEntityProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PathEntityListProto {
    pub fn new() -> PathEntityListProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.PathEntityProto path_val_list = 1;

    pub fn clear_path_val_list(&mut self) {
        self.path_val_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_val_list(&mut self, v: ::protobuf::RepeatedField<PathEntityProto>) {
        self.path_val_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path_val_list(&mut self) -> &mut ::protobuf::RepeatedField<PathEntityProto> {
        &mut self.path_val_list
    }

    // Take field
    pub fn take_path_val_list(&mut self) -> ::protobuf::RepeatedField<PathEntityProto> {
        ::std::mem::replace(&mut self.path_val_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_path_val_list(&self) -> &[PathEntityProto] {
        &self.path_val_list
    }
}

impl ::protobuf::Message for PathEntityListProto {
    fn is_initialized(&self) -> bool {
        for v in &self.path_val_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path_val_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.path_val_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.path_val_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathEntityListProto {
        PathEntityListProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathEntityProto>>(
                    "path_val_list",
                    |m: &PathEntityListProto| { &m.path_val_list },
                    |m: &mut PathEntityListProto| { &mut m.path_val_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PathEntityListProto>(
                    "PathEntityListProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PathEntityListProto {
        static mut instance: ::protobuf::lazy::Lazy<PathEntityListProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PathEntityListProto,
        };
        unsafe {
            instance.get(PathEntityListProto::new)
        }
    }
}

impl ::protobuf::Clear for PathEntityListProto {
    fn clear(&mut self) {
        self.clear_path_val_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathEntityListProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathEntityListProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValuePropertyEntityProto {
    // message fields
    pub prop_list: ::protobuf::RepeatedField<PropertyEntityProto>,
    pub value_entity: ::protobuf::SingularPtrField<ValueEntityProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ValuePropertyEntityProto {
    pub fn new() -> ValuePropertyEntityProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.PropertyEntityProto prop_list = 1;

    pub fn clear_prop_list(&mut self) {
        self.prop_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_prop_list(&mut self, v: ::protobuf::RepeatedField<PropertyEntityProto>) {
        self.prop_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_prop_list(&mut self) -> &mut ::protobuf::RepeatedField<PropertyEntityProto> {
        &mut self.prop_list
    }

    // Take field
    pub fn take_prop_list(&mut self) -> ::protobuf::RepeatedField<PropertyEntityProto> {
        ::std::mem::replace(&mut self.prop_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_prop_list(&self) -> &[PropertyEntityProto] {
        &self.prop_list
    }

    // .maxgraph.ValueEntityProto value_entity = 2;

    pub fn clear_value_entity(&mut self) {
        self.value_entity.clear();
    }

    pub fn has_value_entity(&self) -> bool {
        self.value_entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_entity(&mut self, v: ValueEntityProto) {
        self.value_entity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_entity(&mut self) -> &mut ValueEntityProto {
        if self.value_entity.is_none() {
            self.value_entity.set_default();
        }
        self.value_entity.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_entity(&mut self) -> ValueEntityProto {
        self.value_entity.take().unwrap_or_else(|| ValueEntityProto::new())
    }

    pub fn get_value_entity(&self) -> &ValueEntityProto {
        self.value_entity.as_ref().unwrap_or_else(|| ValueEntityProto::default_instance())
    }
}

impl ::protobuf::Message for ValuePropertyEntityProto {
    fn is_initialized(&self) -> bool {
        for v in &self.prop_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_entity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.prop_list)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_entity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.prop_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.value_entity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.prop_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.value_entity.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValuePropertyEntityProto {
        ValuePropertyEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PropertyEntityProto>>(
                    "prop_list",
                    |m: &ValuePropertyEntityProto| { &m.prop_list },
                    |m: &mut ValuePropertyEntityProto| { &mut m.prop_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueEntityProto>>(
                    "value_entity",
                    |m: &ValuePropertyEntityProto| { &m.value_entity },
                    |m: &mut ValuePropertyEntityProto| { &mut m.value_entity },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValuePropertyEntityProto>(
                    "ValuePropertyEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValuePropertyEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<ValuePropertyEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValuePropertyEntityProto,
        };
        unsafe {
            instance.get(ValuePropertyEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for ValuePropertyEntityProto {
    fn clear(&mut self) {
        self.clear_prop_list();
        self.clear_value_entity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValuePropertyEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValuePropertyEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValueEntityProto {
    // message fields
    pub value_type: VariantType,
    pub payload: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ValueEntityProto {
    pub fn new() -> ValueEntityProto {
        ::std::default::Default::default()
    }

    // .maxgraph.VariantType value_type = 1;

    pub fn clear_value_type(&mut self) {
        self.value_type = VariantType::VT_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: VariantType) {
        self.value_type = v;
    }

    pub fn get_value_type(&self) -> VariantType {
        self.value_type
    }

    // bytes payload = 2;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.payload
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.payload, ::std::vec::Vec::new())
    }

    pub fn get_payload(&self) -> &[u8] {
        &self.payload
    }
}

impl ::protobuf::Message for ValueEntityProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.value_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value_type != VariantType::VT_BOOL {
            my_size += ::protobuf::rt::enum_size(1, self.value_type);
        }
        if !self.payload.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.payload);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.value_type != VariantType::VT_BOOL {
            os.write_enum(1, self.value_type.value())?;
        }
        if !self.payload.is_empty() {
            os.write_bytes(2, &self.payload)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValueEntityProto {
        ValueEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VariantType>>(
                    "value_type",
                    |m: &ValueEntityProto| { &m.value_type },
                    |m: &mut ValueEntityProto| { &mut m.value_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "payload",
                    |m: &ValueEntityProto| { &m.payload },
                    |m: &mut ValueEntityProto| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValueEntityProto>(
                    "ValueEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValueEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<ValueEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValueEntityProto,
        };
        unsafe {
            instance.get(ValueEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for ValueEntityProto {
    fn clear(&mut self) {
        self.clear_value_type();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValueEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValueEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PropertyEntityProto {
    // message fields
    pub prop_id: i32,
    pub prop_value: ::protobuf::SingularPtrField<ValueEntityProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl PropertyEntityProto {
    pub fn new() -> PropertyEntityProto {
        ::std::default::Default::default()
    }

    // int32 prop_id = 1;

    pub fn clear_prop_id(&mut self) {
        self.prop_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_prop_id(&mut self, v: i32) {
        self.prop_id = v;
    }

    pub fn get_prop_id(&self) -> i32 {
        self.prop_id
    }

    // .maxgraph.ValueEntityProto prop_value = 2;

    pub fn clear_prop_value(&mut self) {
        self.prop_value.clear();
    }

    pub fn has_prop_value(&self) -> bool {
        self.prop_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prop_value(&mut self, v: ValueEntityProto) {
        self.prop_value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prop_value(&mut self) -> &mut ValueEntityProto {
        if self.prop_value.is_none() {
            self.prop_value.set_default();
        }
        self.prop_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_prop_value(&mut self) -> ValueEntityProto {
        self.prop_value.take().unwrap_or_else(|| ValueEntityProto::new())
    }

    pub fn get_prop_value(&self) -> &ValueEntityProto {
        self.prop_value.as_ref().unwrap_or_else(|| ValueEntityProto::default_instance())
    }
}

impl ::protobuf::Message for PropertyEntityProto {
    fn is_initialized(&self) -> bool {
        for v in &self.prop_value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.prop_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prop_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.prop_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.prop_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.prop_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.prop_id != 0 {
            os.write_int32(1, self.prop_id)?;
        }
        if let Some(ref v) = self.prop_value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PropertyEntityProto {
        PropertyEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "prop_id",
                    |m: &PropertyEntityProto| { &m.prop_id },
                    |m: &mut PropertyEntityProto| { &mut m.prop_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValueEntityProto>>(
                    "prop_value",
                    |m: &PropertyEntityProto| { &m.prop_value },
                    |m: &mut PropertyEntityProto| { &mut m.prop_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PropertyEntityProto>(
                    "PropertyEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PropertyEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<PropertyEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PropertyEntityProto,
        };
        unsafe {
            instance.get(PropertyEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for PropertyEntityProto {
    fn clear(&mut self) {
        self.clear_prop_id();
        self.clear_prop_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PropertyEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtraPathLabelEntityProto {
    // message fields
    pub path_list: ::protobuf::RepeatedField<PathEntityListProto>,
    pub label_list: ::protobuf::RepeatedField<LabelEntityProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ExtraPathLabelEntityProto {
    pub fn new() -> ExtraPathLabelEntityProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.PathEntityListProto path_list = 1;

    pub fn clear_path_list(&mut self) {
        self.path_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_list(&mut self, v: ::protobuf::RepeatedField<PathEntityListProto>) {
        self.path_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path_list(&mut self) -> &mut ::protobuf::RepeatedField<PathEntityListProto> {
        &mut self.path_list
    }

    // Take field
    pub fn take_path_list(&mut self) -> ::protobuf::RepeatedField<PathEntityListProto> {
        ::std::mem::replace(&mut self.path_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_path_list(&self) -> &[PathEntityListProto] {
        &self.path_list
    }

    // repeated .maxgraph.LabelEntityProto label_list = 2;

    pub fn clear_label_list(&mut self) {
        self.label_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_list(&mut self, v: ::protobuf::RepeatedField<LabelEntityProto>) {
        self.label_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_label_list(&mut self) -> &mut ::protobuf::RepeatedField<LabelEntityProto> {
        &mut self.label_list
    }

    // Take field
    pub fn take_label_list(&mut self) -> ::protobuf::RepeatedField<LabelEntityProto> {
        ::std::mem::replace(&mut self.label_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_label_list(&self) -> &[LabelEntityProto] {
        &self.label_list
    }
}

impl ::protobuf::Message for ExtraPathLabelEntityProto {
    fn is_initialized(&self) -> bool {
        for v in &self.path_list {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.label_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path_list)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.label_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.path_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.label_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.path_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.label_list {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtraPathLabelEntityProto {
        ExtraPathLabelEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathEntityListProto>>(
                    "path_list",
                    |m: &ExtraPathLabelEntityProto| { &m.path_list },
                    |m: &mut ExtraPathLabelEntityProto| { &mut m.path_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelEntityProto>>(
                    "label_list",
                    |m: &ExtraPathLabelEntityProto| { &m.label_list },
                    |m: &mut ExtraPathLabelEntityProto| { &mut m.label_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtraPathLabelEntityProto>(
                    "ExtraPathLabelEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtraPathLabelEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<ExtraPathLabelEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtraPathLabelEntityProto,
        };
        unsafe {
            instance.get(ExtraPathLabelEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for ExtraPathLabelEntityProto {
    fn clear(&mut self) {
        self.clear_path_list();
        self.clear_label_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtraPathLabelEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraPathLabelEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtraMessageProto {
    // message fields
    pub extra_edge: ::protobuf::SingularPtrField<ExtraEdgeEntityProto>,
    pub extra_value_prop: ::protobuf::SingularPtrField<ValuePropertyEntityProto>,
    pub extra_path_label: ::protobuf::SingularPtrField<ExtraPathLabelEntityProto>,
    pub extra_key: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ExtraMessageProto {
    pub fn new() -> ExtraMessageProto {
        ::std::default::Default::default()
    }

    // .maxgraph.ExtraEdgeEntityProto extra_edge = 1;

    pub fn clear_extra_edge(&mut self) {
        self.extra_edge.clear();
    }

    pub fn has_extra_edge(&self) -> bool {
        self.extra_edge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_edge(&mut self, v: ExtraEdgeEntityProto) {
        self.extra_edge = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_edge(&mut self) -> &mut ExtraEdgeEntityProto {
        if self.extra_edge.is_none() {
            self.extra_edge.set_default();
        }
        self.extra_edge.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_edge(&mut self) -> ExtraEdgeEntityProto {
        self.extra_edge.take().unwrap_or_else(|| ExtraEdgeEntityProto::new())
    }

    pub fn get_extra_edge(&self) -> &ExtraEdgeEntityProto {
        self.extra_edge.as_ref().unwrap_or_else(|| ExtraEdgeEntityProto::default_instance())
    }

    // .maxgraph.ValuePropertyEntityProto extra_value_prop = 2;

    pub fn clear_extra_value_prop(&mut self) {
        self.extra_value_prop.clear();
    }

    pub fn has_extra_value_prop(&self) -> bool {
        self.extra_value_prop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_value_prop(&mut self, v: ValuePropertyEntityProto) {
        self.extra_value_prop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_value_prop(&mut self) -> &mut ValuePropertyEntityProto {
        if self.extra_value_prop.is_none() {
            self.extra_value_prop.set_default();
        }
        self.extra_value_prop.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_value_prop(&mut self) -> ValuePropertyEntityProto {
        self.extra_value_prop.take().unwrap_or_else(|| ValuePropertyEntityProto::new())
    }

    pub fn get_extra_value_prop(&self) -> &ValuePropertyEntityProto {
        self.extra_value_prop.as_ref().unwrap_or_else(|| ValuePropertyEntityProto::default_instance())
    }

    // .maxgraph.ExtraPathLabelEntityProto extra_path_label = 3;

    pub fn clear_extra_path_label(&mut self) {
        self.extra_path_label.clear();
    }

    pub fn has_extra_path_label(&self) -> bool {
        self.extra_path_label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_path_label(&mut self, v: ExtraPathLabelEntityProto) {
        self.extra_path_label = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_path_label(&mut self) -> &mut ExtraPathLabelEntityProto {
        if self.extra_path_label.is_none() {
            self.extra_path_label.set_default();
        }
        self.extra_path_label.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_path_label(&mut self) -> ExtraPathLabelEntityProto {
        self.extra_path_label.take().unwrap_or_else(|| ExtraPathLabelEntityProto::new())
    }

    pub fn get_extra_path_label(&self) -> &ExtraPathLabelEntityProto {
        self.extra_path_label.as_ref().unwrap_or_else(|| ExtraPathLabelEntityProto::default_instance())
    }

    // bytes extra_key = 4;

    pub fn clear_extra_key(&mut self) {
        self.extra_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.extra_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extra_key
    }

    // Take field
    pub fn take_extra_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extra_key, ::std::vec::Vec::new())
    }

    pub fn get_extra_key(&self) -> &[u8] {
        &self.extra_key
    }
}

impl ::protobuf::Message for ExtraMessageProto {
    fn is_initialized(&self) -> bool {
        for v in &self.extra_edge {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extra_value_prop {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extra_path_label {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.extra_edge)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.extra_value_prop)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.extra_path_label)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extra_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.extra_edge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_value_prop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.extra_path_label.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.extra_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.extra_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.extra_edge.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_value_prop.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.extra_path_label.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.extra_key.is_empty() {
            os.write_bytes(4, &self.extra_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtraMessageProto {
        ExtraMessageProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExtraEdgeEntityProto>>(
                    "extra_edge",
                    |m: &ExtraMessageProto| { &m.extra_edge },
                    |m: &mut ExtraMessageProto| { &mut m.extra_edge },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ValuePropertyEntityProto>>(
                    "extra_value_prop",
                    |m: &ExtraMessageProto| { &m.extra_value_prop },
                    |m: &mut ExtraMessageProto| { &mut m.extra_value_prop },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExtraPathLabelEntityProto>>(
                    "extra_path_label",
                    |m: &ExtraMessageProto| { &m.extra_path_label },
                    |m: &mut ExtraMessageProto| { &mut m.extra_path_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extra_key",
                    |m: &ExtraMessageProto| { &m.extra_key },
                    |m: &mut ExtraMessageProto| { &mut m.extra_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtraMessageProto>(
                    "ExtraMessageProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtraMessageProto {
        static mut instance: ::protobuf::lazy::Lazy<ExtraMessageProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtraMessageProto,
        };
        unsafe {
            instance.get(ExtraMessageProto::new)
        }
    }
}

impl ::protobuf::Clear for ExtraMessageProto {
    fn clear(&mut self) {
        self.clear_extra_edge();
        self.clear_extra_value_prop();
        self.clear_extra_path_label();
        self.clear_extra_key();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtraMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraMessageProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtraKeyEntityProto {
    // message fields
    pub message: ::protobuf::SingularPtrField<RawMessageProto>,
    pub key_rand: i64,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ExtraKeyEntityProto {
    pub fn new() -> ExtraKeyEntityProto {
        ::std::default::Default::default()
    }

    // .maxgraph.RawMessageProto message = 1;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: RawMessageProto) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut RawMessageProto {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> RawMessageProto {
        self.message.take().unwrap_or_else(|| RawMessageProto::new())
    }

    pub fn get_message(&self) -> &RawMessageProto {
        self.message.as_ref().unwrap_or_else(|| RawMessageProto::default_instance())
    }

    // int64 key_rand = 2;

    pub fn clear_key_rand(&mut self) {
        self.key_rand = 0;
    }

    // Param is passed by value, moved
    pub fn set_key_rand(&mut self, v: i64) {
        self.key_rand = v;
    }

    pub fn get_key_rand(&self) -> i64 {
        self.key_rand
    }
}

impl ::protobuf::Message for ExtraKeyEntityProto {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.key_rand = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.key_rand != 0 {
            my_size += ::protobuf::rt::value_size(2, self.key_rand, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.key_rand != 0 {
            os.write_int64(2, self.key_rand)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtraKeyEntityProto {
        ExtraKeyEntityProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMessageProto>>(
                    "message",
                    |m: &ExtraKeyEntityProto| { &m.message },
                    |m: &mut ExtraKeyEntityProto| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "key_rand",
                    |m: &ExtraKeyEntityProto| { &m.key_rand },
                    |m: &mut ExtraKeyEntityProto| { &mut m.key_rand },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExtraKeyEntityProto>(
                    "ExtraKeyEntityProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ExtraKeyEntityProto {
        static mut instance: ::protobuf::lazy::Lazy<ExtraKeyEntityProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExtraKeyEntityProto,
        };
        unsafe {
            instance.get(ExtraKeyEntityProto::new)
        }
    }
}

impl ::protobuf::Clear for ExtraKeyEntityProto {
    fn clear(&mut self) {
        self.clear_message();
        self.clear_key_rand();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtraKeyEntityProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtraKeyEntityProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EntryProto {
    // message fields
    pub key: ::protobuf::SingularPtrField<RawMessageProto>,
    pub value: ::protobuf::SingularPtrField<RawMessageProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl EntryProto {
    pub fn new() -> EntryProto {
        ::std::default::Default::default()
    }

    // .maxgraph.RawMessageProto key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: RawMessageProto) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut RawMessageProto {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> RawMessageProto {
        self.key.take().unwrap_or_else(|| RawMessageProto::new())
    }

    pub fn get_key(&self) -> &RawMessageProto {
        self.key.as_ref().unwrap_or_else(|| RawMessageProto::default_instance())
    }

    // .maxgraph.RawMessageProto value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: RawMessageProto) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut RawMessageProto {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> RawMessageProto {
        self.value.take().unwrap_or_else(|| RawMessageProto::new())
    }

    pub fn get_value(&self) -> &RawMessageProto {
        self.value.as_ref().unwrap_or_else(|| RawMessageProto::default_instance())
    }
}

impl ::protobuf::Message for EntryProto {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EntryProto {
        EntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMessageProto>>(
                    "key",
                    |m: &EntryProto| { &m.key },
                    |m: &mut EntryProto| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMessageProto>>(
                    "value",
                    |m: &EntryProto| { &m.value },
                    |m: &mut EntryProto| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EntryProto>(
                    "EntryProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EntryProto {
        static mut instance: ::protobuf::lazy::Lazy<EntryProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EntryProto,
        };
        unsafe {
            instance.get(EntryProto::new)
        }
    }
}

impl ::protobuf::Clear for EntryProto {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapProto {
    // message fields
    pub entry_list: ::protobuf::RepeatedField<EntryProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MapProto {
    pub fn new() -> MapProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.EntryProto entry_list = 1;

    pub fn clear_entry_list(&mut self) {
        self.entry_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_list(&mut self, v: ::protobuf::RepeatedField<EntryProto>) {
        self.entry_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entry_list(&mut self) -> &mut ::protobuf::RepeatedField<EntryProto> {
        &mut self.entry_list
    }

    // Take field
    pub fn take_entry_list(&mut self) -> ::protobuf::RepeatedField<EntryProto> {
        ::std::mem::replace(&mut self.entry_list, ::protobuf::RepeatedField::new())
    }

    pub fn get_entry_list(&self) -> &[EntryProto] {
        &self.entry_list
    }
}

impl ::protobuf::Message for MapProto {
    fn is_initialized(&self) -> bool {
        for v in &self.entry_list {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entry_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entry_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entry_list {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapProto {
        MapProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EntryProto>>(
                    "entry_list",
                    |m: &MapProto| { &m.entry_list },
                    |m: &mut MapProto| { &mut m.entry_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MapProto>(
                    "MapProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MapProto {
        static mut instance: ::protobuf::lazy::Lazy<MapProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MapProto,
        };
        unsafe {
            instance.get(MapProto::new)
        }
    }
}

impl ::protobuf::Clear for MapProto {
    fn clear(&mut self) {
        self.clear_entry_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListProto {
    // message fields
    pub value: ::protobuf::RepeatedField<RawMessageProto>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListProto {
    pub fn new() -> ListProto {
        ::std::default::Default::default()
    }

    // repeated .maxgraph.RawMessageProto value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<RawMessageProto>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<RawMessageProto> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<RawMessageProto> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }

    pub fn get_value(&self) -> &[RawMessageProto] {
        &self.value
    }
}

impl ::protobuf::Message for ListProto {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListProto {
        ListProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RawMessageProto>>(
                    "value",
                    |m: &ListProto| { &m.value },
                    |m: &mut ListProto| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListProto>(
                    "ListProto",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListProto {
        static mut instance: ::protobuf::lazy::Lazy<ListProto> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListProto,
        };
        unsafe {
            instance.get(ListProto::new)
        }
    }
}

impl ::protobuf::Clear for ListProto {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListProto {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubgraphVertexList {
    // message fields
    pub source_vertex_list: ::std::vec::Vec<i32>,
    pub target_vertex_list: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl SubgraphVertexList {
    pub fn new() -> SubgraphVertexList {
        ::std::default::Default::default()
    }

    // repeated int32 source_vertex_list = 1;

    pub fn clear_source_vertex_list(&mut self) {
        self.source_vertex_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_vertex_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.source_vertex_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_vertex_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.source_vertex_list
    }

    // Take field
    pub fn take_source_vertex_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.source_vertex_list, ::std::vec::Vec::new())
    }

    pub fn get_source_vertex_list(&self) -> &[i32] {
        &self.source_vertex_list
    }

    // repeated int32 target_vertex_list = 2;

    pub fn clear_target_vertex_list(&mut self) {
        self.target_vertex_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_vertex_list(&mut self, v: ::std::vec::Vec<i32>) {
        self.target_vertex_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_vertex_list(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.target_vertex_list
    }

    // Take field
    pub fn take_target_vertex_list(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.target_vertex_list, ::std::vec::Vec::new())
    }

    pub fn get_target_vertex_list(&self) -> &[i32] {
        &self.target_vertex_list
    }
}

impl ::protobuf::Message for SubgraphVertexList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.source_vertex_list)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.target_vertex_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.source_vertex_list {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.target_vertex_list {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.source_vertex_list {
            os.write_int32(1, *v)?;
        };
        for v in &self.target_vertex_list {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubgraphVertexList {
        SubgraphVertexList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "source_vertex_list",
                    |m: &SubgraphVertexList| { &m.source_vertex_list },
                    |m: &mut SubgraphVertexList| { &mut m.source_vertex_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_vertex_list",
                    |m: &SubgraphVertexList| { &m.target_vertex_list },
                    |m: &mut SubgraphVertexList| { &mut m.target_vertex_list },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SubgraphVertexList>(
                    "SubgraphVertexList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubgraphVertexList {
        static mut instance: ::protobuf::lazy::Lazy<SubgraphVertexList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubgraphVertexList,
        };
        unsafe {
            instance.get(SubgraphVertexList::new)
        }
    }
}

impl ::protobuf::Clear for SubgraphVertexList {
    fn clear(&mut self) {
        self.clear_source_vertex_list();
        self.clear_target_vertex_list();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubgraphVertexList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubgraphVertexList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramCCArg {
    // message fields
    pub property_cc_id: i32,
    pub loop_limit: i32,
    pub edge_labels: ::std::vec::Vec<i32>,
    pub direction: EdgeDirection,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramCCArg {
    pub fn new() -> ProgramCCArg {
        ::std::default::Default::default()
    }

    // int32 property_cc_id = 1;

    pub fn clear_property_cc_id(&mut self) {
        self.property_cc_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_cc_id(&mut self, v: i32) {
        self.property_cc_id = v;
    }

    pub fn get_property_cc_id(&self) -> i32 {
        self.property_cc_id
    }

    // int32 loop_limit = 2;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // repeated int32 edge_labels = 3;

    pub fn clear_edge_labels(&mut self) {
        self.edge_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_labels(&mut self, v: ::std::vec::Vec<i32>) {
        self.edge_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_labels(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.edge_labels
    }

    // Take field
    pub fn take_edge_labels(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.edge_labels, ::std::vec::Vec::new())
    }

    pub fn get_edge_labels(&self) -> &[i32] {
        &self.edge_labels
    }

    // .maxgraph.EdgeDirection direction = 4;

    pub fn clear_direction(&mut self) {
        self.direction = EdgeDirection::DIR_OUT;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeDirection) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> EdgeDirection {
        self.direction
    }
}

impl ::protobuf::Message for ProgramCCArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_cc_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.edge_labels)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_cc_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_cc_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.edge_labels {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.direction != EdgeDirection::DIR_OUT {
            my_size += ::protobuf::rt::enum_size(4, self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.property_cc_id != 0 {
            os.write_int32(1, self.property_cc_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(2, self.loop_limit)?;
        }
        for v in &self.edge_labels {
            os.write_int32(3, *v)?;
        };
        if self.direction != EdgeDirection::DIR_OUT {
            os.write_enum(4, self.direction.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramCCArg {
        ProgramCCArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_cc_id",
                    |m: &ProgramCCArg| { &m.property_cc_id },
                    |m: &mut ProgramCCArg| { &mut m.property_cc_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &ProgramCCArg| { &m.loop_limit },
                    |m: &mut ProgramCCArg| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_labels",
                    |m: &ProgramCCArg| { &m.edge_labels },
                    |m: &mut ProgramCCArg| { &mut m.edge_labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeDirection>>(
                    "direction",
                    |m: &ProgramCCArg| { &m.direction },
                    |m: &mut ProgramCCArg| { &mut m.direction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramCCArg>(
                    "ProgramCCArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramCCArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramCCArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramCCArg,
        };
        unsafe {
            instance.get(ProgramCCArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramCCArg {
    fn clear(&mut self) {
        self.clear_property_cc_id();
        self.clear_loop_limit();
        self.clear_edge_labels();
        self.clear_direction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramCCArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramCCArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramLPAArg {
    // message fields
    pub direction: EdgeDirection,
    pub seed_label: i32,
    pub target_label: i32,
    pub edge_labels: ::std::vec::Vec<i32>,
    pub iteration: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramLPAArg {
    pub fn new() -> ProgramLPAArg {
        ::std::default::Default::default()
    }

    // .maxgraph.EdgeDirection direction = 1;

    pub fn clear_direction(&mut self) {
        self.direction = EdgeDirection::DIR_OUT;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeDirection) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> EdgeDirection {
        self.direction
    }

    // int32 seed_label = 2;

    pub fn clear_seed_label(&mut self) {
        self.seed_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_seed_label(&mut self, v: i32) {
        self.seed_label = v;
    }

    pub fn get_seed_label(&self) -> i32 {
        self.seed_label
    }

    // int32 target_label = 3;

    pub fn clear_target_label(&mut self) {
        self.target_label = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_label(&mut self, v: i32) {
        self.target_label = v;
    }

    pub fn get_target_label(&self) -> i32 {
        self.target_label
    }

    // repeated int32 edge_labels = 4;

    pub fn clear_edge_labels(&mut self) {
        self.edge_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_labels(&mut self, v: ::std::vec::Vec<i32>) {
        self.edge_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_labels(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.edge_labels
    }

    // Take field
    pub fn take_edge_labels(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.edge_labels, ::std::vec::Vec::new())
    }

    pub fn get_edge_labels(&self) -> &[i32] {
        &self.edge_labels
    }

    // int32 iteration = 5;

    pub fn clear_iteration(&mut self) {
        self.iteration = 0;
    }

    // Param is passed by value, moved
    pub fn set_iteration(&mut self, v: i32) {
        self.iteration = v;
    }

    pub fn get_iteration(&self) -> i32 {
        self.iteration
    }
}

impl ::protobuf::Message for ProgramLPAArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seed_label = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_label = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.edge_labels)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.iteration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.direction != EdgeDirection::DIR_OUT {
            my_size += ::protobuf::rt::enum_size(1, self.direction);
        }
        if self.seed_label != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seed_label, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target_label != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_label, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.edge_labels {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.iteration != 0 {
            my_size += ::protobuf::rt::value_size(5, self.iteration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.direction != EdgeDirection::DIR_OUT {
            os.write_enum(1, self.direction.value())?;
        }
        if self.seed_label != 0 {
            os.write_int32(2, self.seed_label)?;
        }
        if self.target_label != 0 {
            os.write_int32(3, self.target_label)?;
        }
        for v in &self.edge_labels {
            os.write_int32(4, *v)?;
        };
        if self.iteration != 0 {
            os.write_int32(5, self.iteration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramLPAArg {
        ProgramLPAArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeDirection>>(
                    "direction",
                    |m: &ProgramLPAArg| { &m.direction },
                    |m: &mut ProgramLPAArg| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "seed_label",
                    |m: &ProgramLPAArg| { &m.seed_label },
                    |m: &mut ProgramLPAArg| { &mut m.seed_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_label",
                    |m: &ProgramLPAArg| { &m.target_label },
                    |m: &mut ProgramLPAArg| { &mut m.target_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_labels",
                    |m: &ProgramLPAArg| { &m.edge_labels },
                    |m: &mut ProgramLPAArg| { &mut m.edge_labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "iteration",
                    |m: &ProgramLPAArg| { &m.iteration },
                    |m: &mut ProgramLPAArg| { &mut m.iteration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramLPAArg>(
                    "ProgramLPAArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramLPAArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramLPAArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramLPAArg,
        };
        unsafe {
            instance.get(ProgramLPAArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramLPAArg {
    fn clear(&mut self) {
        self.clear_direction();
        self.clear_seed_label();
        self.clear_target_label();
        self.clear_edge_labels();
        self.clear_iteration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramLPAArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramLPAArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramGraphHITSArg {
    // message fields
    pub property_auth_id: i32,
    pub property_hub_id: i32,
    pub loop_limit: i32,
    pub edge_labels: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramGraphHITSArg {
    pub fn new() -> ProgramGraphHITSArg {
        ::std::default::Default::default()
    }

    // int32 property_auth_id = 1;

    pub fn clear_property_auth_id(&mut self) {
        self.property_auth_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_auth_id(&mut self, v: i32) {
        self.property_auth_id = v;
    }

    pub fn get_property_auth_id(&self) -> i32 {
        self.property_auth_id
    }

    // int32 property_hub_id = 2;

    pub fn clear_property_hub_id(&mut self) {
        self.property_hub_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_hub_id(&mut self, v: i32) {
        self.property_hub_id = v;
    }

    pub fn get_property_hub_id(&self) -> i32 {
        self.property_hub_id
    }

    // int32 loop_limit = 3;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // repeated int32 edge_labels = 4;

    pub fn clear_edge_labels(&mut self) {
        self.edge_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_labels(&mut self, v: ::std::vec::Vec<i32>) {
        self.edge_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_labels(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.edge_labels
    }

    // Take field
    pub fn take_edge_labels(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.edge_labels, ::std::vec::Vec::new())
    }

    pub fn get_edge_labels(&self) -> &[i32] {
        &self.edge_labels
    }
}

impl ::protobuf::Message for ProgramGraphHITSArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_auth_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_hub_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.edge_labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_auth_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_auth_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.property_hub_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.property_hub_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.edge_labels {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.property_auth_id != 0 {
            os.write_int32(1, self.property_auth_id)?;
        }
        if self.property_hub_id != 0 {
            os.write_int32(2, self.property_hub_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(3, self.loop_limit)?;
        }
        for v in &self.edge_labels {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramGraphHITSArg {
        ProgramGraphHITSArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_auth_id",
                    |m: &ProgramGraphHITSArg| { &m.property_auth_id },
                    |m: &mut ProgramGraphHITSArg| { &mut m.property_auth_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_hub_id",
                    |m: &ProgramGraphHITSArg| { &m.property_hub_id },
                    |m: &mut ProgramGraphHITSArg| { &mut m.property_hub_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &ProgramGraphHITSArg| { &m.loop_limit },
                    |m: &mut ProgramGraphHITSArg| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_labels",
                    |m: &ProgramGraphHITSArg| { &m.edge_labels },
                    |m: &mut ProgramGraphHITSArg| { &mut m.edge_labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramGraphHITSArg>(
                    "ProgramGraphHITSArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramGraphHITSArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramGraphHITSArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramGraphHITSArg,
        };
        unsafe {
            instance.get(ProgramGraphHITSArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramGraphHITSArg {
    fn clear(&mut self) {
        self.clear_property_auth_id();
        self.clear_property_hub_id();
        self.clear_loop_limit();
        self.clear_edge_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramGraphHITSArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramGraphHITSArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramPageRankArg {
    // message fields
    pub property_pr_id: i32,
    pub alpha: f64,
    pub loop_limit: i32,
    pub direction: EdgeDirection,
    pub edge_labels: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramPageRankArg {
    pub fn new() -> ProgramPageRankArg {
        ::std::default::Default::default()
    }

    // int32 property_pr_id = 1;

    pub fn clear_property_pr_id(&mut self) {
        self.property_pr_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_pr_id(&mut self, v: i32) {
        self.property_pr_id = v;
    }

    pub fn get_property_pr_id(&self) -> i32 {
        self.property_pr_id
    }

    // double alpha = 2;

    pub fn clear_alpha(&mut self) {
        self.alpha = 0.;
    }

    // Param is passed by value, moved
    pub fn set_alpha(&mut self, v: f64) {
        self.alpha = v;
    }

    pub fn get_alpha(&self) -> f64 {
        self.alpha
    }

    // int32 loop_limit = 3;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // .maxgraph.EdgeDirection direction = 4;

    pub fn clear_direction(&mut self) {
        self.direction = EdgeDirection::DIR_OUT;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeDirection) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> EdgeDirection {
        self.direction
    }

    // repeated int32 edge_labels = 5;

    pub fn clear_edge_labels(&mut self) {
        self.edge_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_labels(&mut self, v: ::std::vec::Vec<i32>) {
        self.edge_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_labels(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.edge_labels
    }

    // Take field
    pub fn take_edge_labels(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.edge_labels, ::std::vec::Vec::new())
    }

    pub fn get_edge_labels(&self) -> &[i32] {
        &self.edge_labels
    }
}

impl ::protobuf::Message for ProgramPageRankArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_pr_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.alpha = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.edge_labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_pr_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_pr_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.alpha != 0. {
            my_size += 9;
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.direction != EdgeDirection::DIR_OUT {
            my_size += ::protobuf::rt::enum_size(4, self.direction);
        }
        for value in &self.edge_labels {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.property_pr_id != 0 {
            os.write_int32(1, self.property_pr_id)?;
        }
        if self.alpha != 0. {
            os.write_double(2, self.alpha)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(3, self.loop_limit)?;
        }
        if self.direction != EdgeDirection::DIR_OUT {
            os.write_enum(4, self.direction.value())?;
        }
        for v in &self.edge_labels {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramPageRankArg {
        ProgramPageRankArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_pr_id",
                    |m: &ProgramPageRankArg| { &m.property_pr_id },
                    |m: &mut ProgramPageRankArg| { &mut m.property_pr_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "alpha",
                    |m: &ProgramPageRankArg| { &m.alpha },
                    |m: &mut ProgramPageRankArg| { &mut m.alpha },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &ProgramPageRankArg| { &m.loop_limit },
                    |m: &mut ProgramPageRankArg| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeDirection>>(
                    "direction",
                    |m: &ProgramPageRankArg| { &m.direction },
                    |m: &mut ProgramPageRankArg| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_labels",
                    |m: &ProgramPageRankArg| { &m.edge_labels },
                    |m: &mut ProgramPageRankArg| { &mut m.edge_labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramPageRankArg>(
                    "ProgramPageRankArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramPageRankArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramPageRankArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramPageRankArg,
        };
        unsafe {
            instance.get(ProgramPageRankArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramPageRankArg {
    fn clear(&mut self) {
        self.clear_property_pr_id();
        self.clear_alpha();
        self.clear_loop_limit();
        self.clear_direction();
        self.clear_edge_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramPageRankArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramPageRankArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramShortestPathArg {
    // message fields
    pub sid: i64,
    pub tid: i64,
    pub property_id_id: i32,
    pub property_path_id: i32,
    pub property_edge_weight_id: i32,
    pub loop_limit: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramShortestPathArg {
    pub fn new() -> ProgramShortestPathArg {
        ::std::default::Default::default()
    }

    // int64 sid = 1;

    pub fn clear_sid(&mut self) {
        self.sid = 0;
    }

    // Param is passed by value, moved
    pub fn set_sid(&mut self, v: i64) {
        self.sid = v;
    }

    pub fn get_sid(&self) -> i64 {
        self.sid
    }

    // int64 tid = 2;

    pub fn clear_tid(&mut self) {
        self.tid = 0;
    }

    // Param is passed by value, moved
    pub fn set_tid(&mut self, v: i64) {
        self.tid = v;
    }

    pub fn get_tid(&self) -> i64 {
        self.tid
    }

    // int32 property_id_id = 3;

    pub fn clear_property_id_id(&mut self) {
        self.property_id_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_id_id(&mut self, v: i32) {
        self.property_id_id = v;
    }

    pub fn get_property_id_id(&self) -> i32 {
        self.property_id_id
    }

    // int32 property_path_id = 4;

    pub fn clear_property_path_id(&mut self) {
        self.property_path_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_path_id(&mut self, v: i32) {
        self.property_path_id = v;
    }

    pub fn get_property_path_id(&self) -> i32 {
        self.property_path_id
    }

    // int32 property_edge_weight_id = 5;

    pub fn clear_property_edge_weight_id(&mut self) {
        self.property_edge_weight_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_edge_weight_id(&mut self, v: i32) {
        self.property_edge_weight_id = v;
    }

    pub fn get_property_edge_weight_id(&self) -> i32 {
        self.property_edge_weight_id
    }

    // int32 loop_limit = 6;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }
}

impl ::protobuf::Message for ProgramShortestPathArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tid = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_id_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_path_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_edge_weight_id = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tid != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.property_id_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.property_id_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.property_path_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.property_path_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.property_edge_weight_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.property_edge_weight_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(6, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.sid != 0 {
            os.write_int64(1, self.sid)?;
        }
        if self.tid != 0 {
            os.write_int64(2, self.tid)?;
        }
        if self.property_id_id != 0 {
            os.write_int32(3, self.property_id_id)?;
        }
        if self.property_path_id != 0 {
            os.write_int32(4, self.property_path_id)?;
        }
        if self.property_edge_weight_id != 0 {
            os.write_int32(5, self.property_edge_weight_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(6, self.loop_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramShortestPathArg {
        ProgramShortestPathArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sid",
                    |m: &ProgramShortestPathArg| { &m.sid },
                    |m: &mut ProgramShortestPathArg| { &mut m.sid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tid",
                    |m: &ProgramShortestPathArg| { &m.tid },
                    |m: &mut ProgramShortestPathArg| { &mut m.tid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_id_id",
                    |m: &ProgramShortestPathArg| { &m.property_id_id },
                    |m: &mut ProgramShortestPathArg| { &mut m.property_id_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_path_id",
                    |m: &ProgramShortestPathArg| { &m.property_path_id },
                    |m: &mut ProgramShortestPathArg| { &mut m.property_path_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_edge_weight_id",
                    |m: &ProgramShortestPathArg| { &m.property_edge_weight_id },
                    |m: &mut ProgramShortestPathArg| { &mut m.property_edge_weight_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &ProgramShortestPathArg| { &m.loop_limit },
                    |m: &mut ProgramShortestPathArg| { &mut m.loop_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramShortestPathArg>(
                    "ProgramShortestPathArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramShortestPathArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramShortestPathArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramShortestPathArg,
        };
        unsafe {
            instance.get(ProgramShortestPathArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramShortestPathArg {
    fn clear(&mut self) {
        self.clear_sid();
        self.clear_tid();
        self.clear_property_id_id();
        self.clear_property_path_id();
        self.clear_property_edge_weight_id();
        self.clear_loop_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramShortestPathArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramShortestPathArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VertexProgramShortestPathArg {
    // message fields
    pub property_edge_weight_id: i32,
    pub loop_limit: i32,
    pub target: ::protobuf::SingularPtrField<Value>,
    pub has_target: bool,
    pub direction: EdgeDirection,
    pub edge_labels: ::std::vec::Vec<i32>,
    pub weight_lb: f64,
    pub weight_flag: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl VertexProgramShortestPathArg {
    pub fn new() -> VertexProgramShortestPathArg {
        ::std::default::Default::default()
    }

    // int32 property_edge_weight_id = 1;

    pub fn clear_property_edge_weight_id(&mut self) {
        self.property_edge_weight_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_edge_weight_id(&mut self, v: i32) {
        self.property_edge_weight_id = v;
    }

    pub fn get_property_edge_weight_id(&self) -> i32 {
        self.property_edge_weight_id
    }

    // int32 loop_limit = 2;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // .maxgraph.Value target = 3;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: Value) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut Value {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> Value {
        self.target.take().unwrap_or_else(|| Value::new())
    }

    pub fn get_target(&self) -> &Value {
        self.target.as_ref().unwrap_or_else(|| Value::default_instance())
    }

    // bool has_target = 4;

    pub fn clear_has_target(&mut self) {
        self.has_target = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target(&mut self, v: bool) {
        self.has_target = v;
    }

    pub fn get_has_target(&self) -> bool {
        self.has_target
    }

    // .maxgraph.EdgeDirection direction = 5;

    pub fn clear_direction(&mut self) {
        self.direction = EdgeDirection::DIR_OUT;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeDirection) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> EdgeDirection {
        self.direction
    }

    // repeated int32 edge_labels = 6;

    pub fn clear_edge_labels(&mut self) {
        self.edge_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_labels(&mut self, v: ::std::vec::Vec<i32>) {
        self.edge_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_labels(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.edge_labels
    }

    // Take field
    pub fn take_edge_labels(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.edge_labels, ::std::vec::Vec::new())
    }

    pub fn get_edge_labels(&self) -> &[i32] {
        &self.edge_labels
    }

    // double weight_lb = 7;

    pub fn clear_weight_lb(&mut self) {
        self.weight_lb = 0.;
    }

    // Param is passed by value, moved
    pub fn set_weight_lb(&mut self, v: f64) {
        self.weight_lb = v;
    }

    pub fn get_weight_lb(&self) -> f64 {
        self.weight_lb
    }

    // bool weight_flag = 8;

    pub fn clear_weight_flag(&mut self) {
        self.weight_flag = false;
    }

    // Param is passed by value, moved
    pub fn set_weight_flag(&mut self, v: bool) {
        self.weight_flag = v;
    }

    pub fn get_weight_flag(&self) -> bool {
        self.weight_flag
    }
}

impl ::protobuf::Message for VertexProgramShortestPathArg {
    fn is_initialized(&self) -> bool {
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_edge_weight_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.edge_labels)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.weight_lb = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.weight_flag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_edge_weight_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_edge_weight_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.has_target != false {
            my_size += 2;
        }
        if self.direction != EdgeDirection::DIR_OUT {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        for value in &self.edge_labels {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.weight_lb != 0. {
            my_size += 9;
        }
        if self.weight_flag != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.property_edge_weight_id != 0 {
            os.write_int32(1, self.property_edge_weight_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(2, self.loop_limit)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.has_target != false {
            os.write_bool(4, self.has_target)?;
        }
        if self.direction != EdgeDirection::DIR_OUT {
            os.write_enum(5, self.direction.value())?;
        }
        for v in &self.edge_labels {
            os.write_int32(6, *v)?;
        };
        if self.weight_lb != 0. {
            os.write_double(7, self.weight_lb)?;
        }
        if self.weight_flag != false {
            os.write_bool(8, self.weight_flag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VertexProgramShortestPathArg {
        VertexProgramShortestPathArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_edge_weight_id",
                    |m: &VertexProgramShortestPathArg| { &m.property_edge_weight_id },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.property_edge_weight_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &VertexProgramShortestPathArg| { &m.loop_limit },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Value>>(
                    "target",
                    |m: &VertexProgramShortestPathArg| { &m.target },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.target },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "has_target",
                    |m: &VertexProgramShortestPathArg| { &m.has_target },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.has_target },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeDirection>>(
                    "direction",
                    |m: &VertexProgramShortestPathArg| { &m.direction },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_labels",
                    |m: &VertexProgramShortestPathArg| { &m.edge_labels },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.edge_labels },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "weight_lb",
                    |m: &VertexProgramShortestPathArg| { &m.weight_lb },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.weight_lb },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "weight_flag",
                    |m: &VertexProgramShortestPathArg| { &m.weight_flag },
                    |m: &mut VertexProgramShortestPathArg| { &mut m.weight_flag },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VertexProgramShortestPathArg>(
                    "VertexProgramShortestPathArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VertexProgramShortestPathArg {
        static mut instance: ::protobuf::lazy::Lazy<VertexProgramShortestPathArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VertexProgramShortestPathArg,
        };
        unsafe {
            instance.get(VertexProgramShortestPathArg::new)
        }
    }
}

impl ::protobuf::Clear for VertexProgramShortestPathArg {
    fn clear(&mut self) {
        self.clear_property_edge_weight_id();
        self.clear_loop_limit();
        self.clear_target();
        self.clear_has_target();
        self.clear_direction();
        self.clear_edge_labels();
        self.clear_weight_lb();
        self.clear_weight_flag();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VertexProgramShortestPathArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VertexProgramShortestPathArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramAllPathArg {
    // message fields
    pub sid: i64,
    pub tid: i64,
    pub property_id_id: i32,
    pub property_path_id: i32,
    pub loop_limit: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramAllPathArg {
    pub fn new() -> ProgramAllPathArg {
        ::std::default::Default::default()
    }

    // int64 sid = 1;

    pub fn clear_sid(&mut self) {
        self.sid = 0;
    }

    // Param is passed by value, moved
    pub fn set_sid(&mut self, v: i64) {
        self.sid = v;
    }

    pub fn get_sid(&self) -> i64 {
        self.sid
    }

    // int64 tid = 2;

    pub fn clear_tid(&mut self) {
        self.tid = 0;
    }

    // Param is passed by value, moved
    pub fn set_tid(&mut self, v: i64) {
        self.tid = v;
    }

    pub fn get_tid(&self) -> i64 {
        self.tid
    }

    // int32 property_id_id = 3;

    pub fn clear_property_id_id(&mut self) {
        self.property_id_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_id_id(&mut self, v: i32) {
        self.property_id_id = v;
    }

    pub fn get_property_id_id(&self) -> i32 {
        self.property_id_id
    }

    // int32 property_path_id = 4;

    pub fn clear_property_path_id(&mut self) {
        self.property_path_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_path_id(&mut self, v: i32) {
        self.property_path_id = v;
    }

    pub fn get_property_path_id(&self) -> i32 {
        self.property_path_id
    }

    // int32 loop_limit = 5;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }
}

impl ::protobuf::Message for ProgramAllPathArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sid = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tid = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_id_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_path_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sid != 0 {
            my_size += ::protobuf::rt::value_size(1, self.sid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tid != 0 {
            my_size += ::protobuf::rt::value_size(2, self.tid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.property_id_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.property_id_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.property_path_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.property_path_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.sid != 0 {
            os.write_int64(1, self.sid)?;
        }
        if self.tid != 0 {
            os.write_int64(2, self.tid)?;
        }
        if self.property_id_id != 0 {
            os.write_int32(3, self.property_id_id)?;
        }
        if self.property_path_id != 0 {
            os.write_int32(4, self.property_path_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(5, self.loop_limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramAllPathArg {
        ProgramAllPathArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sid",
                    |m: &ProgramAllPathArg| { &m.sid },
                    |m: &mut ProgramAllPathArg| { &mut m.sid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tid",
                    |m: &ProgramAllPathArg| { &m.tid },
                    |m: &mut ProgramAllPathArg| { &mut m.tid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_id_id",
                    |m: &ProgramAllPathArg| { &m.property_id_id },
                    |m: &mut ProgramAllPathArg| { &mut m.property_id_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_path_id",
                    |m: &ProgramAllPathArg| { &m.property_path_id },
                    |m: &mut ProgramAllPathArg| { &mut m.property_path_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &ProgramAllPathArg| { &m.loop_limit },
                    |m: &mut ProgramAllPathArg| { &mut m.loop_limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramAllPathArg>(
                    "ProgramAllPathArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramAllPathArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramAllPathArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramAllPathArg,
        };
        unsafe {
            instance.get(ProgramAllPathArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramAllPathArg {
    fn clear(&mut self) {
        self.clear_sid();
        self.clear_tid();
        self.clear_property_id_id();
        self.clear_property_path_id();
        self.clear_loop_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramAllPathArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramAllPathArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramPeerPressureArg {
    // message fields
    pub property_pp_id: i32,
    pub loop_limit: i32,
    pub direction: EdgeDirection,
    pub edge_labels: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ProgramPeerPressureArg {
    pub fn new() -> ProgramPeerPressureArg {
        ::std::default::Default::default()
    }

    // int32 property_pp_id = 1;

    pub fn clear_property_pp_id(&mut self) {
        self.property_pp_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_property_pp_id(&mut self, v: i32) {
        self.property_pp_id = v;
    }

    pub fn get_property_pp_id(&self) -> i32 {
        self.property_pp_id
    }

    // int32 loop_limit = 2;

    pub fn clear_loop_limit(&mut self) {
        self.loop_limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_loop_limit(&mut self, v: i32) {
        self.loop_limit = v;
    }

    pub fn get_loop_limit(&self) -> i32 {
        self.loop_limit
    }

    // .maxgraph.EdgeDirection direction = 3;

    pub fn clear_direction(&mut self) {
        self.direction = EdgeDirection::DIR_OUT;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EdgeDirection) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> EdgeDirection {
        self.direction
    }

    // repeated int32 edge_labels = 4;

    pub fn clear_edge_labels(&mut self) {
        self.edge_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_edge_labels(&mut self, v: ::std::vec::Vec<i32>) {
        self.edge_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_edge_labels(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.edge_labels
    }

    // Take field
    pub fn take_edge_labels(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.edge_labels, ::std::vec::Vec::new())
    }

    pub fn get_edge_labels(&self) -> &[i32] {
        &self.edge_labels
    }
}

impl ::protobuf::Message for ProgramPeerPressureArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.property_pp_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loop_limit = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.edge_labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.property_pp_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.property_pp_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.loop_limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.loop_limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.direction != EdgeDirection::DIR_OUT {
            my_size += ::protobuf::rt::enum_size(3, self.direction);
        }
        for value in &self.edge_labels {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.property_pp_id != 0 {
            os.write_int32(1, self.property_pp_id)?;
        }
        if self.loop_limit != 0 {
            os.write_int32(2, self.loop_limit)?;
        }
        if self.direction != EdgeDirection::DIR_OUT {
            os.write_enum(3, self.direction.value())?;
        }
        for v in &self.edge_labels {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramPeerPressureArg {
        ProgramPeerPressureArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "property_pp_id",
                    |m: &ProgramPeerPressureArg| { &m.property_pp_id },
                    |m: &mut ProgramPeerPressureArg| { &mut m.property_pp_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "loop_limit",
                    |m: &ProgramPeerPressureArg| { &m.loop_limit },
                    |m: &mut ProgramPeerPressureArg| { &mut m.loop_limit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EdgeDirection>>(
                    "direction",
                    |m: &ProgramPeerPressureArg| { &m.direction },
                    |m: &mut ProgramPeerPressureArg| { &mut m.direction },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "edge_labels",
                    |m: &ProgramPeerPressureArg| { &m.edge_labels },
                    |m: &mut ProgramPeerPressureArg| { &mut m.edge_labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgramPeerPressureArg>(
                    "ProgramPeerPressureArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgramPeerPressureArg {
        static mut instance: ::protobuf::lazy::Lazy<ProgramPeerPressureArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgramPeerPressureArg,
        };
        unsafe {
            instance.get(ProgramPeerPressureArg::new)
        }
    }
}

impl ::protobuf::Clear for ProgramPeerPressureArg {
    fn clear(&mut self) {
        self.clear_property_pp_id();
        self.clear_loop_limit();
        self.clear_direction();
        self.clear_edge_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramPeerPressureArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramPeerPressureArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MetapathSampleArg {
    // message fields
    pub amountToSample: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl MetapathSampleArg {
    pub fn new() -> MetapathSampleArg {
        ::std::default::Default::default()
    }

    // int32 amountToSample = 1;

    pub fn clear_amountToSample(&mut self) {
        self.amountToSample = 0;
    }

    // Param is passed by value, moved
    pub fn set_amountToSample(&mut self, v: i32) {
        self.amountToSample = v;
    }

    pub fn get_amountToSample(&self) -> i32 {
        self.amountToSample
    }
}

impl ::protobuf::Message for MetapathSampleArg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.amountToSample = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.amountToSample != 0 {
            my_size += ::protobuf::rt::value_size(1, self.amountToSample, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.amountToSample != 0 {
            os.write_int32(1, self.amountToSample)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MetapathSampleArg {
        MetapathSampleArg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "amountToSample",
                    |m: &MetapathSampleArg| { &m.amountToSample },
                    |m: &mut MetapathSampleArg| { &mut m.amountToSample },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MetapathSampleArg>(
                    "MetapathSampleArg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MetapathSampleArg {
        static mut instance: ::protobuf::lazy::Lazy<MetapathSampleArg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MetapathSampleArg,
        };
        unsafe {
            instance.get(MetapathSampleArg::new)
        }
    }
}

impl ::protobuf::Clear for MetapathSampleArg {
    fn clear(&mut self) {
        self.clear_amountToSample();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MetapathSampleArg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetapathSampleArg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClassType {
    VERTEX = 0,
    EDGE = 1,
    PROPERTY = 2,
    LIST = 3,
    MAP = 4,
    ENTRY = 5,
    PATH_ENTRY = 6,
    ERROR = 7,
    DFS_CMD = 8,
}

impl ::protobuf::ProtobufEnum for ClassType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClassType> {
        match value {
            0 => ::std::option::Option::Some(ClassType::VERTEX),
            1 => ::std::option::Option::Some(ClassType::EDGE),
            2 => ::std::option::Option::Some(ClassType::PROPERTY),
            3 => ::std::option::Option::Some(ClassType::LIST),
            4 => ::std::option::Option::Some(ClassType::MAP),
            5 => ::std::option::Option::Some(ClassType::ENTRY),
            6 => ::std::option::Option::Some(ClassType::PATH_ENTRY),
            7 => ::std::option::Option::Some(ClassType::ERROR),
            8 => ::std::option::Option::Some(ClassType::DFS_CMD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClassType] = &[
            ClassType::VERTEX,
            ClassType::EDGE,
            ClassType::PROPERTY,
            ClassType::LIST,
            ClassType::MAP,
            ClassType::ENTRY,
            ClassType::PATH_ENTRY,
            ClassType::ERROR,
            ClassType::DFS_CMD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ClassType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ClassType {
}

impl ::std::default::Default for ClassType {
    fn default() -> Self {
        ClassType::VERTEX
    }
}

impl ::protobuf::reflect::ProtobufValue for ClassType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ErrorCode {
    OK = 0,
    UNIMPLEMENT = 1,
    LABEL_NOT_FOUND = 2,
    DATA_TYPE_NOT_SUPPORT = 3,
    CLASS_TYPE_NOT_SUPPORT = 4,
    INTERNAL_ERROR = 5,
    PROPERTY_NOT_FOUND = 6,
    DATAFLOW_ERROR = 7,
}

impl ::protobuf::ProtobufEnum for ErrorCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ErrorCode::OK),
            1 => ::std::option::Option::Some(ErrorCode::UNIMPLEMENT),
            2 => ::std::option::Option::Some(ErrorCode::LABEL_NOT_FOUND),
            3 => ::std::option::Option::Some(ErrorCode::DATA_TYPE_NOT_SUPPORT),
            4 => ::std::option::Option::Some(ErrorCode::CLASS_TYPE_NOT_SUPPORT),
            5 => ::std::option::Option::Some(ErrorCode::INTERNAL_ERROR),
            6 => ::std::option::Option::Some(ErrorCode::PROPERTY_NOT_FOUND),
            7 => ::std::option::Option::Some(ErrorCode::DATAFLOW_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ErrorCode] = &[
            ErrorCode::OK,
            ErrorCode::UNIMPLEMENT,
            ErrorCode::LABEL_NOT_FOUND,
            ErrorCode::DATA_TYPE_NOT_SUPPORT,
            ErrorCode::CLASS_TYPE_NOT_SUPPORT,
            ErrorCode::INTERNAL_ERROR,
            ErrorCode::PROPERTY_NOT_FOUND,
            ErrorCode::DATAFLOW_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ErrorCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ErrorCode {
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        ErrorCode::OK
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PopType {
    FIRST = 0,
    LAST = 1,
    ALL = 2,
    POP_EMPTY = 3,
}

impl ::protobuf::ProtobufEnum for PopType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PopType> {
        match value {
            0 => ::std::option::Option::Some(PopType::FIRST),
            1 => ::std::option::Option::Some(PopType::LAST),
            2 => ::std::option::Option::Some(PopType::ALL),
            3 => ::std::option::Option::Some(PopType::POP_EMPTY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PopType] = &[
            PopType::FIRST,
            PopType::LAST,
            PopType::ALL,
            PopType::POP_EMPTY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PopType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PopType {
}

impl ::std::default::Default for PopType {
    fn default() -> Self {
        PopType::FIRST
    }
}

impl ::protobuf::reflect::ProtobufValue for PopType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PropKeyValueType {
    PROP_KEY_TYPE = 0,
    PROP_VALUE_TYPE = 1,
}

impl ::protobuf::ProtobufEnum for PropKeyValueType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PropKeyValueType> {
        match value {
            0 => ::std::option::Option::Some(PropKeyValueType::PROP_KEY_TYPE),
            1 => ::std::option::Option::Some(PropKeyValueType::PROP_VALUE_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PropKeyValueType] = &[
            PropKeyValueType::PROP_KEY_TYPE,
            PropKeyValueType::PROP_VALUE_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PropKeyValueType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PropKeyValueType {
}

impl ::std::default::Default for PropKeyValueType {
    fn default() -> Self {
        PropKeyValueType::PROP_KEY_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for PropKeyValueType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PathOutType {
    PATH_VALUE = 0,
    PATH_PROP = 1,
}

impl ::protobuf::ProtobufEnum for PathOutType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PathOutType> {
        match value {
            0 => ::std::option::Option::Some(PathOutType::PATH_VALUE),
            1 => ::std::option::Option::Some(PathOutType::PATH_PROP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PathOutType] = &[
            PathOutType::PATH_VALUE,
            PathOutType::PATH_PROP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PathOutType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PathOutType {
}

impl ::std::default::Default for PathOutType {
    fn default() -> Self {
        PathOutType::PATH_VALUE
    }
}

impl ::protobuf::reflect::ProtobufValue for PathOutType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PropertyType {
    PROP_TYPE = 0,
    VALUE_TYPE = 1,
}

impl ::protobuf::ProtobufEnum for PropertyType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PropertyType> {
        match value {
            0 => ::std::option::Option::Some(PropertyType::PROP_TYPE),
            1 => ::std::option::Option::Some(PropertyType::VALUE_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PropertyType] = &[
            PropertyType::PROP_TYPE,
            PropertyType::VALUE_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("PropertyType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PropertyType {
}

impl ::std::default::Default for PropertyType {
    fn default() -> Self {
        PropertyType::PROP_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for PropertyType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OrderType {
    INCR = 0,
    DECR = 1,
    SHUFFLE = 2,
    ASC = 3,
    DESC = 4,
}

impl ::protobuf::ProtobufEnum for OrderType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OrderType> {
        match value {
            0 => ::std::option::Option::Some(OrderType::INCR),
            1 => ::std::option::Option::Some(OrderType::DECR),
            2 => ::std::option::Option::Some(OrderType::SHUFFLE),
            3 => ::std::option::Option::Some(OrderType::ASC),
            4 => ::std::option::Option::Some(OrderType::DESC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OrderType] = &[
            OrderType::INCR,
            OrderType::DECR,
            OrderType::SHUFFLE,
            OrderType::ASC,
            OrderType::DESC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OrderType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OrderType {
}

impl ::std::default::Default for OrderType {
    fn default() -> Self {
        OrderType::INCR
    }
}

impl ::protobuf::reflect::ProtobufValue for OrderType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VariantType {
    VT_BOOL = 0,
    VT_CHAR = 1,
    VT_SHORT = 2,
    VT_INTEGER = 3,
    VT_LONG = 4,
    VT_FLOAT = 5,
    VT_DOUBLE = 6,
    VT_BINARY = 7,
    VT_STRING = 8,
    VT_DATE = 9,
    VT_INTEGER_LIST = 10,
    VT_LONG_LIST = 11,
    VT_FLOAT_LIST = 12,
    VT_DOUBLE_LIST = 13,
    VT_STRING_LIST = 14,
    VT_BYTES_LIST = 15,
    VT_DIM_ODPS = 900,
    VT_UNKNOWN = 1001,
}

impl ::protobuf::ProtobufEnum for VariantType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VariantType> {
        match value {
            0 => ::std::option::Option::Some(VariantType::VT_BOOL),
            1 => ::std::option::Option::Some(VariantType::VT_CHAR),
            2 => ::std::option::Option::Some(VariantType::VT_SHORT),
            3 => ::std::option::Option::Some(VariantType::VT_INTEGER),
            4 => ::std::option::Option::Some(VariantType::VT_LONG),
            5 => ::std::option::Option::Some(VariantType::VT_FLOAT),
            6 => ::std::option::Option::Some(VariantType::VT_DOUBLE),
            7 => ::std::option::Option::Some(VariantType::VT_BINARY),
            8 => ::std::option::Option::Some(VariantType::VT_STRING),
            9 => ::std::option::Option::Some(VariantType::VT_DATE),
            10 => ::std::option::Option::Some(VariantType::VT_INTEGER_LIST),
            11 => ::std::option::Option::Some(VariantType::VT_LONG_LIST),
            12 => ::std::option::Option::Some(VariantType::VT_FLOAT_LIST),
            13 => ::std::option::Option::Some(VariantType::VT_DOUBLE_LIST),
            14 => ::std::option::Option::Some(VariantType::VT_STRING_LIST),
            15 => ::std::option::Option::Some(VariantType::VT_BYTES_LIST),
            900 => ::std::option::Option::Some(VariantType::VT_DIM_ODPS),
            1001 => ::std::option::Option::Some(VariantType::VT_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VariantType] = &[
            VariantType::VT_BOOL,
            VariantType::VT_CHAR,
            VariantType::VT_SHORT,
            VariantType::VT_INTEGER,
            VariantType::VT_LONG,
            VariantType::VT_FLOAT,
            VariantType::VT_DOUBLE,
            VariantType::VT_BINARY,
            VariantType::VT_STRING,
            VariantType::VT_DATE,
            VariantType::VT_INTEGER_LIST,
            VariantType::VT_LONG_LIST,
            VariantType::VT_FLOAT_LIST,
            VariantType::VT_DOUBLE_LIST,
            VariantType::VT_STRING_LIST,
            VariantType::VT_BYTES_LIST,
            VariantType::VT_DIM_ODPS,
            VariantType::VT_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VariantType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VariantType {
}

impl ::std::default::Default for VariantType {
    fn default() -> Self {
        VariantType::VT_BOOL
    }
}

impl ::protobuf::reflect::ProtobufValue for VariantType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EdgeDirection {
    DIR_OUT = 0,
    DIR_IN = 1,
    DIR_NONE = 2,
}

impl ::protobuf::ProtobufEnum for EdgeDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EdgeDirection> {
        match value {
            0 => ::std::option::Option::Some(EdgeDirection::DIR_OUT),
            1 => ::std::option::Option::Some(EdgeDirection::DIR_IN),
            2 => ::std::option::Option::Some(EdgeDirection::DIR_NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EdgeDirection] = &[
            EdgeDirection::DIR_OUT,
            EdgeDirection::DIR_IN,
            EdgeDirection::DIR_NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("EdgeDirection", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for EdgeDirection {
}

impl ::std::default::Default for EdgeDirection {
    fn default() -> Self {
        EdgeDirection::DIR_OUT
    }
}

impl ::protobuf::reflect::ProtobufValue for EdgeDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CompareType {
    GT = 0,
    LT = 1,
    GTE = 2,
    LTE = 3,
    EQ = 4,
    NEQ = 5,
    WITHIN = 6,
    WITHOUT = 7,
    REGEX = 8,
    STARTSWITH = 9,
    ENDSWITH = 10,
    CONTAINS = 11,
    LIST_CONTAINS = 12,
    LIST_CONTAINS_ANY = 13,
    LIST_CONTAINS_ALL = 14,
    DIM_WITHIN = 15,
    DIM_WITHOUT = 16,
    EXIST = 17,
    OR_RELATION = 18,
    AND_RELATION = 19,
}

impl ::protobuf::ProtobufEnum for CompareType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompareType> {
        match value {
            0 => ::std::option::Option::Some(CompareType::GT),
            1 => ::std::option::Option::Some(CompareType::LT),
            2 => ::std::option::Option::Some(CompareType::GTE),
            3 => ::std::option::Option::Some(CompareType::LTE),
            4 => ::std::option::Option::Some(CompareType::EQ),
            5 => ::std::option::Option::Some(CompareType::NEQ),
            6 => ::std::option::Option::Some(CompareType::WITHIN),
            7 => ::std::option::Option::Some(CompareType::WITHOUT),
            8 => ::std::option::Option::Some(CompareType::REGEX),
            9 => ::std::option::Option::Some(CompareType::STARTSWITH),
            10 => ::std::option::Option::Some(CompareType::ENDSWITH),
            11 => ::std::option::Option::Some(CompareType::CONTAINS),
            12 => ::std::option::Option::Some(CompareType::LIST_CONTAINS),
            13 => ::std::option::Option::Some(CompareType::LIST_CONTAINS_ANY),
            14 => ::std::option::Option::Some(CompareType::LIST_CONTAINS_ALL),
            15 => ::std::option::Option::Some(CompareType::DIM_WITHIN),
            16 => ::std::option::Option::Some(CompareType::DIM_WITHOUT),
            17 => ::std::option::Option::Some(CompareType::EXIST),
            18 => ::std::option::Option::Some(CompareType::OR_RELATION),
            19 => ::std::option::Option::Some(CompareType::AND_RELATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CompareType] = &[
            CompareType::GT,
            CompareType::LT,
            CompareType::GTE,
            CompareType::LTE,
            CompareType::EQ,
            CompareType::NEQ,
            CompareType::WITHIN,
            CompareType::WITHOUT,
            CompareType::REGEX,
            CompareType::STARTSWITH,
            CompareType::ENDSWITH,
            CompareType::CONTAINS,
            CompareType::LIST_CONTAINS,
            CompareType::LIST_CONTAINS_ANY,
            CompareType::LIST_CONTAINS_ALL,
            CompareType::DIM_WITHIN,
            CompareType::DIM_WITHOUT,
            CompareType::EXIST,
            CompareType::OR_RELATION,
            CompareType::AND_RELATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CompareType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CompareType {
}

impl ::std::default::Default for CompareType {
    fn default() -> Self {
        CompareType::GT
    }
}

impl ::protobuf::reflect::ProtobufValue for CompareType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageType {
    MSG_VERTEX_TYPE = 0,
    MSG_EDGE_TYPE = 1,
    MSG_PROP_TYPE = 2,
    MSG_ENTRY_TYPE = 3,
    MSG_PATH_ENTRY_TYPE = 4,
    MSG_VALUE_TYPE = 5,
    MSG_DFS_CMD_TYPE = 6,
    MSG_LIST_TYPE = 7,
    MSG_MAP_TYPE = 8,
    MSG_ERROR_TYPE = 100,
}

impl ::protobuf::ProtobufEnum for MessageType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            0 => ::std::option::Option::Some(MessageType::MSG_VERTEX_TYPE),
            1 => ::std::option::Option::Some(MessageType::MSG_EDGE_TYPE),
            2 => ::std::option::Option::Some(MessageType::MSG_PROP_TYPE),
            3 => ::std::option::Option::Some(MessageType::MSG_ENTRY_TYPE),
            4 => ::std::option::Option::Some(MessageType::MSG_PATH_ENTRY_TYPE),
            5 => ::std::option::Option::Some(MessageType::MSG_VALUE_TYPE),
            6 => ::std::option::Option::Some(MessageType::MSG_DFS_CMD_TYPE),
            7 => ::std::option::Option::Some(MessageType::MSG_LIST_TYPE),
            8 => ::std::option::Option::Some(MessageType::MSG_MAP_TYPE),
            100 => ::std::option::Option::Some(MessageType::MSG_ERROR_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageType] = &[
            MessageType::MSG_VERTEX_TYPE,
            MessageType::MSG_EDGE_TYPE,
            MessageType::MSG_PROP_TYPE,
            MessageType::MSG_ENTRY_TYPE,
            MessageType::MSG_PATH_ENTRY_TYPE,
            MessageType::MSG_VALUE_TYPE,
            MessageType::MSG_DFS_CMD_TYPE,
            MessageType::MSG_LIST_TYPE,
            MessageType::MSG_MAP_TYPE,
            MessageType::MSG_ERROR_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MessageType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MessageType {
}

impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::MSG_VERTEX_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11sdk/message.proto\x12\x08maxgraph\x1a\x10sdk/schema.proto\"J\n\x05\
    Error\x12'\n\x04code\x18\x01\x20\x01(\x0e2\x13.maxgraph.ErrorCodeR\x04co\
    de\x12\x18\n\x07message\x18\x02\x20\x01(\x0cR\x07message\"\xeb\x01\n\x08\
    Property\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12)\n\x04type\x18\
    \x02\x20\x01(\x0e2\x15.maxgraph.VariantTypeR\x04type\x12\x14\n\x05value\
    \x18\x03\x20\x01(\x0cR\x05value\x125\n\x0blabel_value\x18\x04\x20\x03(\
    \x0b2\x14.maxgraph.LabelValueR\nlabelValue\x12'\n\x04path\x18\x05\x20\
    \x03(\x0b2\x13.maxgraph.PathValueR\x04path\x12.\n\x13not_vertex_property\
    \x18\x06\x20\x01(\x08R\x11notVertexProperty\"\xc1\x01\n\x06Vertex\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x17\n\x07type_id\x18\x02\
    \x20\x01(\x05R\x06typeId\x12'\n\x04path\x18\x03\x20\x03(\x0b2\x13.maxgra\
    ph.PathValueR\x04path\x125\n\x0blabel_value\x18\x04\x20\x03(\x0b2\x14.ma\
    xgraph.LabelValueR\nlabelValue\x12.\n\x08property\x18\x05\x20\x03(\x0b2\
    \x12.maxgraph.PropertyR\x08property\"\xac\x02\n\x04Edge\x12\"\n\x03src\
    \x18\x01\x20\x01(\x0b2\x10.maxgraph.VertexR\x03src\x12\"\n\x03dst\x18\
    \x02\x20\x01(\x0b2\x10.maxgraph.VertexR\x03dst\x12#\n\rout_direction\x18\
    \x03\x20\x01(\x08R\x0coutDirection\x12\x17\n\x07type_id\x18\x04\x20\x01(\
    \x05R\x06typeId\x12.\n\x08property\x18\x05\x20\x03(\x0b2\x12.maxgraph.Pr\
    opertyR\x08property\x12'\n\x04path\x18\x06\x20\x03(\x0b2\x13.maxgraph.Pa\
    thValueR\x04path\x125\n\x0blabel_value\x18\x07\x20\x03(\x0b2\x14.maxgrap\
    h.LabelValueR\nlabelValue\x12\x0e\n\x02id\x18\x08\x20\x01(\x03R\x02id\"J\
    \n\nDfsCommand\x12\x1d\n\nbatch_size\x18\x01\x20\x01(\x03R\tbatchSize\
    \x12\x1d\n\nsend_count\x18\x02\x20\x01(\x03R\tsendCount\"2\n\x06Object\
    \x12(\n\x05field\x18\x01\x20\x03(\x0b2\x12.maxgraph.PropertyR\x05field\"\
    Z\n\nClassValue\x122\n\nclass_type\x18\x01\x20\x01(\x0e2\x13.maxgraph.Cl\
    assTypeR\tclassType\x12\x18\n\x07payload\x18\x02\x20\x01(\x0cR\x07payloa\
    d\"^\n\nLabelValue\x125\n\x0bclass_value\x18\x01\x20\x01(\x0b2\x14.maxgr\
    aph.ClassValueR\nclassValue\x12\x19\n\x08label_id\x18\x02\x20\x01(\x05R\
    \x07labelId\"\xc6\x01\n\tPathValue\x125\n\x0bclass_value\x18\x01\x20\x01\
    (\x0b2\x14.maxgraph.ClassValueR\nclassValue\x12\"\n\rlabel_id_list\x18\
    \x02\x20\x03(\x05R\x0blabelIdList\x125\n\x0blabel_value\x18\x03\x20\x03(\
    \x0b2\x14.maxgraph.LabelValueR\nlabelValue\x12'\n\x04path\x18\x04\x20\
    \x03(\x0b2\x13.maxgraph.PathValueR\x04path\"\x92\x01\n\x04List\x12*\n\
    \x05value\x18\x01\x20\x03(\x0b2\x14.maxgraph.ClassValueR\x05value\x125\n\
    \x0blabel_value\x18\x02\x20\x03(\x0b2\x14.maxgraph.LabelValueR\nlabelVal\
    ue\x12'\n\x04path\x18\x03\x20\x03(\x0b2\x13.maxgraph.PathValueR\x04path\
    \"\xbb\x01\n\x05Entry\x12&\n\x03key\x18\x01\x20\x01(\x0b2\x14.maxgraph.C\
    lassValueR\x03key\x12*\n\x05value\x18\x02\x20\x01(\x0b2\x14.maxgraph.Cla\
    ssValueR\x05value\x125\n\x0blabel_value\x18\x03\x20\x03(\x0b2\x14.maxgra\
    ph.LabelValueR\nlabelValue\x12'\n\x04path\x18\x04\x20\x03(\x0b2\x13.maxg\
    raph.PathValueR\x04path\"\x95\x01\n\x03Map\x12.\n\nentry_list\x18\x01\
    \x20\x03(\x0b2\x0f.maxgraph.EntryR\tentryList\x125\n\x0blabel_value\x18\
    \x02\x20\x03(\x0b2\x14.maxgraph.LabelValueR\nlabelValue\x12'\n\x04path\
    \x18\x03\x20\x03(\x0b2\x13.maxgraph.PathValueR\x04path\"\x94\x05\n\x05Va\
    lue\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\x05index\x12\x1b\n\tint_val\
    ue\x18\x02\x20\x01(\x05R\x08intValue\x12\x1d\n\nlong_value\x18\x03\x20\
    \x01(\x03R\tlongValue\x12\x1f\n\x0bfloat_value\x18\x04\x20\x01(\x02R\nfl\
    oatValue\x12!\n\x0cdouble_value\x18\x05\x20\x01(\x01R\x0bdoubleValue\x12\
    \x1d\n\nbool_value\x18\x06\x20\x01(\x08R\tboolValue\x12\x1b\n\tstr_value\
    \x18\x07\x20\x01(\tR\x08strValue\x12$\n\x0eint_value_list\x18\x08\x20\
    \x03(\x05R\x0cintValueList\x12&\n\x0flong_value_list\x18\t\x20\x03(\x03R\
    \rlongValueList\x12$\n\x0estr_value_list\x18\n\x20\x03(\tR\x0cstrValueLi\
    st\x12\x18\n\x07payload\x18\x0b\x20\x01(\x0cR\x07payload\x124\n\nvalue_t\
    ype\x18\x0c\x20\x01(\x0e2\x15.maxgraph.VariantTypeR\tvalueType\x12<\n\
    \x0epath_out_value\x18\r\x20\x03(\x0b2\x16.maxgraph.PathOutValueR\x0cpat\
    hOutValue\x12\x1b\n\tbool_flag\x18\x0e\x20\x01(\x08R\x08boolFlag\x12\x1d\
    \n\norder_flag\x18\x0f\x20\x01(\x08R\torderFlag\x12#\n\rsubquery_flag\
    \x18\x10\x20\x01(\x08R\x0csubqueryFlag\x12(\n\x10dedup_local_flag\x18\
    \x11\x20\x01(\x08R\x0ededupLocalFlag\x12,\n\x12exec_local_disable\x18\
    \x12\x20\x01(\x08R\x10execLocalDisable\"^\n\rQueryResponse\x12\x14\n\x05\
    value\x18\x01\x20\x03(\x0cR\x05value\x12\x1d\n\nerror_code\x18\x02\x20\
    \x01(\x05R\terrorCode\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07messag\
    e\"\x1f\n\x07ListInt\x12\x14\n\x05value\x18\x01\x20\x03(\x05R\x05value\"\
    \x20\n\x08ListLong\x12\x14\n\x05value\x18\x01\x20\x03(\x03R\x05value\"\"\
    \n\nListString\x12\x14\n\x05value\x18\x01\x20\x03(\tR\x05value\"!\n\tLis\
    tFloat\x12\x14\n\x05value\x18\x01\x20\x03(\x02R\x05value\"\"\n\nListDoub\
    le\x12\x14\n\x05value\x18\x01\x20\x03(\x01R\x05value\"\"\n\nListBinary\
    \x12\x14\n\x05value\x18\x01\x20\x03(\x0cR\x05value\"k\n\x0cPathOutValue\
    \x129\n\rpath_out_type\x18\x01\x20\x01(\x0e2\x15.maxgraph.PathOutTypeR\
    \x0bpathOutType\x12\x20\n\x0cpath_prop_id\x18\x02\x20\x01(\x05R\npathPro\
    pId\"\x92\x01\n\x0fOrderComparator\x12\x17\n\x07prop_id\x18\x01\x20\x01(\
    \x05R\x06propId\x122\n\norder_type\x18\x02\x20\x01(\x0e2\x13.maxgraph.Or\
    derTypeR\torderType\x122\n\tprop_type\x18\x03\x20\x01(\x0e2\x15.maxgraph\
    .VariantTypeR\x08propType\"[\n\x13OrderComparatorList\x12D\n\x10order_co\
    mparator\x18\x01\x20\x03(\x0b2\x19.maxgraph.OrderComparatorR\x0forderCom\
    parator\"\xf6\x02\n\x08CountMap\x127\n\x07int_map\x18\x01\x20\x03(\x0b2\
    \x1e.maxgraph.CountMap.IntMapEntryR\x06intMap\x12:\n\x08long_map\x18\x02\
    \x20\x03(\x0b2\x1f.maxgraph.CountMap.LongMapEntryR\x07longMap\x12@\n\nst\
    ring_map\x18\x03\x20\x03(\x0b2!.maxgraph.CountMap.StringMapEntryR\tstrin\
    gMap\x1a9\n\x0bIntMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value:\x028\x01\x1a:\n\x0cL\
    ongMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x05R\x05value:\x028\x01\x1a<\n\x0eStringMapEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x05R\x05value:\x028\x01\"G\n\x11OperationResponse\x12\x18\n\
    \x07success\x18\x01\x20\x01(\x08R\x07success\x12\x18\n\x07message\x18\
    \x02\x20\x01(\tR\x07message\"8\n\x15RemoveDataflowRequest\x12\x1f\n\x0bd\
    ataflow_id\x18\x01\x20\x01(\tR\ndataflowId\"m\n\rTimelyMessage\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\x03R\x02id\x122\n\nclass_type\x18\x02\x20\x01(\
    \x0e2\x13.maxgraph.ClassTypeR\tclassType\x12\x18\n\x07payload\x18\x03\
    \x20\x01(\x0cR\x07payload\"\xba\x01\n\x14ColumnLogicalCompare\x12\x1f\n\
    \x0bcolumn_name\x18\x01\x20\x01(\tR\ncolumnName\x12/\n\x07compare\x18\
    \x02\x20\x01(\x0e2\x15.maxgraph.CompareTypeR\x07compare\x12%\n\x05value\
    \x18\x03\x20\x01(\x0b2\x0f.maxgraph.ValueR\x05value\x12)\n\x04type\x18\
    \x04\x20\x01(\x0e2\x15.maxgraph.VariantTypeR\x04type\"\x8a\x02\n\x0eLogi\
    calCompare\x12\x17\n\x07prop_id\x18\x01\x20\x01(\x05R\x06propId\x12/\n\
    \x07compare\x18\x02\x20\x01(\x0e2\x15.maxgraph.CompareTypeR\x07compare\
    \x12%\n\x05value\x18\x03\x20\x01(\x0b2\x0f.maxgraph.ValueR\x05value\x12)\
    \n\x04type\x18\x04\x20\x01(\x0e2\x15.maxgraph.VariantTypeR\x04type\x12\
    \x14\n\x05index\x18\x05\x20\x01(\x05R\x05index\x12F\n\x12child_compare_l\
    ist\x18\x06\x20\x03(\x0b2\x18.maxgraph.LogicalCompareR\x10childCompareLi\
    st\"\xd2\x03\n\tEdgeInput\x12\x18\n\x07project\x18\x01\x20\x01(\tR\x07pr\
    oject\x12\x0e\n\x02ds\x18\x02\x20\x01(\tR\x02ds\x12\x14\n\x05table\x18\
    \x03\x20\x01(\tR\x05table\x12\x1b\n\ttype_name\x18\x04\x20\x01(\tR\x08ty\
    peName\x12&\n\x0fsrc_primary_key\x18\x05\x20\x01(\tR\rsrcPrimaryKey\x12\
    \"\n\rsrc_type_name\x18\x06\x20\x01(\tR\x0bsrcTypeName\x12&\n\x0fdst_pri\
    mary_key\x18\x07\x20\x01(\tR\rdstPrimaryKey\x12\"\n\rdst_type_name\x18\
    \x08\x20\x01(\tR\x0bdstTypeName\x125\n\tdirection\x18\t\x20\x01(\x0e2\
    \x17.maxgraph.EdgeDirectionR\tdirection\x12\x1f\n\x0bcolumn_name\x18\n\
    \x20\x03(\tR\ncolumnName\x12G\n\x0flogical_compare\x18\x0b\x20\x03(\x0b2\
    \x1e.maxgraph.ColumnLogicalCompareR\x0elogicalCompare\x12/\n\x14not_outp\
    ut_vertex_id\x18\x0c\x20\x01(\x08R\x11notOutputVertexId\"~\n\x10BranchOp\
    tionList\x122\n\x0coption_value\x18\x01\x20\x03(\x0b2\x0f.maxgraph.Value\
    R\x0boptionValue\x12\x1b\n\tnone_flag\x18\x02\x20\x01(\x08R\x08noneFlag\
    \x12\x19\n\x08any_flag\x18\x03\x20\x01(\x08R\x07anyFlag\"\xd6\x01\n\x0fR\
    awMessageProto\x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06typeId\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\x03R\x02id\x128\n\x0cmessage_type\x18\x03\
    \x20\x01(\x0e2\x15.maxgraph.MessageTypeR\x0bmessageType\x121\n\x05extra\
    \x18\x04\x20\x01(\x0b2\x1b.maxgraph.ExtraMessageProtoR\x05extra\x12\x12\
    \n\x04bulk\x18\x05\x20\x01(\x03R\x04bulk\x12\x19\n\x08store_id\x18\x06\
    \x20\x01(\x05R\x07storeId\"\x9b\x01\n\x14ExtraEdgeEntityProto\x12\x1e\n\
    \x0bsrc_type_id\x18\x01\x20\x01(\x05R\tsrcTypeId\x12\x15\n\x06src_id\x18\
    \x02\x20\x01(\x03R\x05srcId\x12\x1e\n\x0bdst_type_id\x18\x03\x20\x01(\
    \x05R\tdstTypeId\x12\x15\n\x06dst_id\x18\x04\x20\x01(\x03R\x05dstId\x12\
    \x15\n\x06is_out\x18\x05\x20\x01(\x08R\x05isOut\"e\n\x0fPathEntityProto\
    \x123\n\x07message\x18\x01\x20\x01(\x0b2\x19.maxgraph.RawMessageProtoR\
    \x07message\x12\x1d\n\nlabel_list\x18\x02\x20\x03(\x05R\tlabelList\"b\n\
    \x10LabelEntityProto\x123\n\x07message\x18\x01\x20\x01(\x0b2\x19.maxgrap\
    h.RawMessageProtoR\x07message\x12\x19\n\x08label_id\x18\x02\x20\x01(\x05\
    R\x07labelId\"T\n\x13PathEntityListProto\x12=\n\rpath_val_list\x18\x01\
    \x20\x03(\x0b2\x19.maxgraph.PathEntityProtoR\x0bpathValList\"\x95\x01\n\
    \x18ValuePropertyEntityProto\x12:\n\tprop_list\x18\x01\x20\x03(\x0b2\x1d\
    .maxgraph.PropertyEntityProtoR\x08propList\x12=\n\x0cvalue_entity\x18\
    \x02\x20\x01(\x0b2\x1a.maxgraph.ValueEntityProtoR\x0bvalueEntity\"b\n\
    \x10ValueEntityProto\x124\n\nvalue_type\x18\x01\x20\x01(\x0e2\x15.maxgra\
    ph.VariantTypeR\tvalueType\x12\x18\n\x07payload\x18\x02\x20\x01(\x0cR\
    \x07payload\"i\n\x13PropertyEntityProto\x12\x17\n\x07prop_id\x18\x01\x20\
    \x01(\x05R\x06propId\x129\n\nprop_value\x18\x02\x20\x01(\x0b2\x1a.maxgra\
    ph.ValueEntityProtoR\tpropValue\"\x92\x01\n\x19ExtraPathLabelEntityProto\
    \x12:\n\tpath_list\x18\x01\x20\x03(\x0b2\x1d.maxgraph.PathEntityListProt\
    oR\x08pathList\x129\n\nlabel_list\x18\x02\x20\x03(\x0b2\x1a.maxgraph.Lab\
    elEntityProtoR\tlabelList\"\x8c\x02\n\x11ExtraMessageProto\x12=\n\nextra\
    _edge\x18\x01\x20\x01(\x0b2\x1e.maxgraph.ExtraEdgeEntityProtoR\textraEdg\
    e\x12L\n\x10extra_value_prop\x18\x02\x20\x01(\x0b2\".maxgraph.ValuePrope\
    rtyEntityProtoR\x0eextraValueProp\x12M\n\x10extra_path_label\x18\x03\x20\
    \x01(\x0b2#.maxgraph.ExtraPathLabelEntityProtoR\x0eextraPathLabel\x12\
    \x1b\n\textra_key\x18\x04\x20\x01(\x0cR\x08extraKey\"e\n\x13ExtraKeyEnti\
    tyProto\x123\n\x07message\x18\x01\x20\x01(\x0b2\x19.maxgraph.RawMessageP\
    rotoR\x07message\x12\x19\n\x08key_rand\x18\x02\x20\x01(\x03R\x07keyRand\
    \"j\n\nEntryProto\x12+\n\x03key\x18\x01\x20\x01(\x0b2\x19.maxgraph.RawMe\
    ssageProtoR\x03key\x12/\n\x05value\x18\x02\x20\x01(\x0b2\x19.maxgraph.Ra\
    wMessageProtoR\x05value\"?\n\x08MapProto\x123\n\nentry_list\x18\x01\x20\
    \x03(\x0b2\x14.maxgraph.EntryProtoR\tentryList\"<\n\tListProto\x12/\n\
    \x05value\x18\x01\x20\x03(\x0b2\x19.maxgraph.RawMessageProtoR\x05value\"\
    p\n\x12SubgraphVertexList\x12,\n\x12source_vertex_list\x18\x01\x20\x03(\
    \x05R\x10sourceVertexList\x12,\n\x12target_vertex_list\x18\x02\x20\x03(\
    \x05R\x10targetVertexList\"\xab\x01\n\x0cProgramCCArg\x12$\n\x0eproperty\
    _cc_id\x18\x01\x20\x01(\x05R\x0cpropertyCcId\x12\x1d\n\nloop_limit\x18\
    \x02\x20\x01(\x05R\tloopLimit\x12\x1f\n\x0bedge_labels\x18\x03\x20\x03(\
    \x05R\nedgeLabels\x125\n\tdirection\x18\x04\x20\x01(\x0e2\x17.maxgraph.E\
    dgeDirectionR\tdirection\"\xc7\x01\n\rProgramLPAArg\x125\n\tdirection\
    \x18\x01\x20\x01(\x0e2\x17.maxgraph.EdgeDirectionR\tdirection\x12\x1d\n\
    \nseed_label\x18\x02\x20\x01(\x05R\tseedLabel\x12!\n\x0ctarget_label\x18\
    \x03\x20\x01(\x05R\x0btargetLabel\x12\x1f\n\x0bedge_labels\x18\x04\x20\
    \x03(\x05R\nedgeLabels\x12\x1c\n\titeration\x18\x05\x20\x01(\x05R\titera\
    tion\"\xa7\x01\n\x13ProgramGraphHITSArg\x12(\n\x10property_auth_id\x18\
    \x01\x20\x01(\x05R\x0epropertyAuthId\x12&\n\x0fproperty_hub_id\x18\x02\
    \x20\x01(\x05R\rpropertyHubId\x12\x1d\n\nloop_limit\x18\x03\x20\x01(\x05\
    R\tloopLimit\x12\x1f\n\x0bedge_labels\x18\x04\x20\x03(\x05R\nedgeLabels\
    \"\xc7\x01\n\x12ProgramPageRankArg\x12$\n\x0eproperty_pr_id\x18\x01\x20\
    \x01(\x05R\x0cpropertyPrId\x12\x14\n\x05alpha\x18\x02\x20\x01(\x01R\x05a\
    lpha\x12\x1d\n\nloop_limit\x18\x03\x20\x01(\x05R\tloopLimit\x125\n\tdire\
    ction\x18\x04\x20\x01(\x0e2\x17.maxgraph.EdgeDirectionR\tdirection\x12\
    \x1f\n\x0bedge_labels\x18\x05\x20\x03(\x05R\nedgeLabels\"\xe2\x01\n\x16P\
    rogramShortestPathArg\x12\x10\n\x03sid\x18\x01\x20\x01(\x03R\x03sid\x12\
    \x10\n\x03tid\x18\x02\x20\x01(\x03R\x03tid\x12$\n\x0eproperty_id_id\x18\
    \x03\x20\x01(\x05R\x0cpropertyIdId\x12(\n\x10property_path_id\x18\x04\
    \x20\x01(\x05R\x0epropertyPathId\x125\n\x17property_edge_weight_id\x18\
    \x05\x20\x01(\x05R\x14propertyEdgeWeightId\x12\x1d\n\nloop_limit\x18\x06\
    \x20\x01(\x05R\tloopLimit\"\xd2\x02\n\x1cVertexProgramShortestPathArg\
    \x125\n\x17property_edge_weight_id\x18\x01\x20\x01(\x05R\x14propertyEdge\
    WeightId\x12\x1d\n\nloop_limit\x18\x02\x20\x01(\x05R\tloopLimit\x12'\n\
    \x06target\x18\x03\x20\x01(\x0b2\x0f.maxgraph.ValueR\x06target\x12\x1d\n\
    \nhas_target\x18\x04\x20\x01(\x08R\thasTarget\x125\n\tdirection\x18\x05\
    \x20\x01(\x0e2\x17.maxgraph.EdgeDirectionR\tdirection\x12\x1f\n\x0bedge_\
    labels\x18\x06\x20\x03(\x05R\nedgeLabels\x12\x1b\n\tweight_lb\x18\x07\
    \x20\x01(\x01R\x08weightLb\x12\x1f\n\x0bweight_flag\x18\x08\x20\x01(\x08\
    R\nweightFlag\"\xa6\x01\n\x11ProgramAllPathArg\x12\x10\n\x03sid\x18\x01\
    \x20\x01(\x03R\x03sid\x12\x10\n\x03tid\x18\x02\x20\x01(\x03R\x03tid\x12$\
    \n\x0eproperty_id_id\x18\x03\x20\x01(\x05R\x0cpropertyIdId\x12(\n\x10pro\
    perty_path_id\x18\x04\x20\x01(\x05R\x0epropertyPathId\x12\x1d\n\nloop_li\
    mit\x18\x05\x20\x01(\x05R\tloopLimit\"\xb5\x01\n\x16ProgramPeerPressureA\
    rg\x12$\n\x0eproperty_pp_id\x18\x01\x20\x01(\x05R\x0cpropertyPpId\x12\
    \x1d\n\nloop_limit\x18\x02\x20\x01(\x05R\tloopLimit\x125\n\tdirection\
    \x18\x03\x20\x01(\x0e2\x17.maxgraph.EdgeDirectionR\tdirection\x12\x1f\n\
    \x0bedge_labels\x18\x04\x20\x03(\x05R\nedgeLabels\";\n\x11MetapathSample\
    Arg\x12&\n\x0eamountToSample\x18\x01\x20\x01(\x05R\x0eamountToSample*u\n\
    \tClassType\x12\n\n\x06VERTEX\x10\0\x12\x08\n\x04EDGE\x10\x01\x12\x0c\n\
    \x08PROPERTY\x10\x02\x12\x08\n\x04LIST\x10\x03\x12\x07\n\x03MAP\x10\x04\
    \x12\t\n\x05ENTRY\x10\x05\x12\x0e\n\nPATH_ENTRY\x10\x06\x12\t\n\x05ERROR\
    \x10\x07\x12\x0b\n\x07DFS_CMD\x10\x08*\xb0\x01\n\tErrorCode\x12\x06\n\
    \x02OK\x10\0\x12\x0f\n\x0bUNIMPLEMENT\x10\x01\x12\x13\n\x0fLABEL_NOT_FOU\
    ND\x10\x02\x12\x19\n\x15DATA_TYPE_NOT_SUPPORT\x10\x03\x12\x1a\n\x16CLASS\
    _TYPE_NOT_SUPPORT\x10\x04\x12\x12\n\x0eINTERNAL_ERROR\x10\x05\x12\x16\n\
    \x12PROPERTY_NOT_FOUND\x10\x06\x12\x12\n\x0eDATAFLOW_ERROR\x10\x07*6\n\
    \x07PopType\x12\t\n\x05FIRST\x10\0\x12\x08\n\x04LAST\x10\x01\x12\x07\n\
    \x03ALL\x10\x02\x12\r\n\tPOP_EMPTY\x10\x03*:\n\x10PropKeyValueType\x12\
    \x11\n\rPROP_KEY_TYPE\x10\0\x12\x13\n\x0fPROP_VALUE_TYPE\x10\x01*,\n\x0b\
    PathOutType\x12\x0e\n\nPATH_VALUE\x10\0\x12\r\n\tPATH_PROP\x10\x01*-\n\
    \x0cPropertyType\x12\r\n\tPROP_TYPE\x10\0\x12\x0e\n\nVALUE_TYPE\x10\x01*\
    ?\n\tOrderType\x12\x08\n\x04INCR\x10\0\x12\x08\n\x04DECR\x10\x01\x12\x0b\
    \n\x07SHUFFLE\x10\x02\x12\x07\n\x03ASC\x10\x03\x12\x08\n\x04DESC\x10\x04\
    *\xb2\x02\n\x0bVariantType\x12\x0b\n\x07VT_BOOL\x10\0\x12\x0b\n\x07VT_CH\
    AR\x10\x01\x12\x0c\n\x08VT_SHORT\x10\x02\x12\x0e\n\nVT_INTEGER\x10\x03\
    \x12\x0b\n\x07VT_LONG\x10\x04\x12\x0c\n\x08VT_FLOAT\x10\x05\x12\r\n\tVT_\
    DOUBLE\x10\x06\x12\r\n\tVT_BINARY\x10\x07\x12\r\n\tVT_STRING\x10\x08\x12\
    \x0b\n\x07VT_DATE\x10\t\x12\x13\n\x0fVT_INTEGER_LIST\x10\n\x12\x10\n\x0c\
    VT_LONG_LIST\x10\x0b\x12\x11\n\rVT_FLOAT_LIST\x10\x0c\x12\x12\n\x0eVT_DO\
    UBLE_LIST\x10\r\x12\x12\n\x0eVT_STRING_LIST\x10\x0e\x12\x11\n\rVT_BYTES_\
    LIST\x10\x0f\x12\x10\n\x0bVT_DIM_ODPS\x10\x84\x07\x12\x0f\n\nVT_UNKNOWN\
    \x10\xe9\x07*6\n\rEdgeDirection\x12\x0b\n\x07DIR_OUT\x10\0\x12\n\n\x06DI\
    R_IN\x10\x01\x12\x0c\n\x08DIR_NONE\x10\x02*\xa0\x02\n\x0bCompareType\x12\
    \x06\n\x02GT\x10\0\x12\x06\n\x02LT\x10\x01\x12\x07\n\x03GTE\x10\x02\x12\
    \x07\n\x03LTE\x10\x03\x12\x06\n\x02EQ\x10\x04\x12\x07\n\x03NEQ\x10\x05\
    \x12\n\n\x06WITHIN\x10\x06\x12\x0b\n\x07WITHOUT\x10\x07\x12\t\n\x05REGEX\
    \x10\x08\x12\x0e\n\nSTARTSWITH\x10\t\x12\x0c\n\x08ENDSWITH\x10\n\x12\x0c\
    \n\x08CONTAINS\x10\x0b\x12\x11\n\rLIST_CONTAINS\x10\x0c\x12\x15\n\x11LIS\
    T_CONTAINS_ANY\x10\r\x12\x15\n\x11LIST_CONTAINS_ALL\x10\x0e\x12\x0e\n\nD\
    IM_WITHIN\x10\x0f\x12\x0f\n\x0bDIM_WITHOUT\x10\x10\x12\t\n\x05EXIST\x10\
    \x11\x12\x0f\n\x0bOR_RELATION\x10\x12\x12\x10\n\x0cAND_RELATION\x10\x13*\
    \xd8\x01\n\x0bMessageType\x12\x13\n\x0fMSG_VERTEX_TYPE\x10\0\x12\x11\n\r\
    MSG_EDGE_TYPE\x10\x01\x12\x11\n\rMSG_PROP_TYPE\x10\x02\x12\x12\n\x0eMSG_\
    ENTRY_TYPE\x10\x03\x12\x17\n\x13MSG_PATH_ENTRY_TYPE\x10\x04\x12\x12\n\
    \x0eMSG_VALUE_TYPE\x10\x05\x12\x14\n\x10MSG_DFS_CMD_TYPE\x10\x06\x12\x11\
    \n\rMSG_LIST_TYPE\x10\x07\x12\x10\n\x0cMSG_MAP_TYPE\x10\x08\x12\x12\n\
    \x0eMSG_ERROR_TYPE\x10dB\x16\n\x14com.alibaba.maxgraphb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
